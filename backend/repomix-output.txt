This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.prettierrc
ch·ª©c nƒÉng kiotviet.txt
eslint.config.mjs
nest-cli.json
package.json
README.md
src/app.controller.spec.ts
src/app.controller.ts
src/app.module.ts
src/app.service.ts
src/database/database.module.ts
src/main.ts
src/modules/attendance/attendance.module.ts
src/modules/attendance/controllers/attendance.controller.ts
src/modules/attendance/dtos/create-attendance.dto.ts
src/modules/attendance/dtos/update-attendance.dto.ts
src/modules/attendance/schemas/attendance.schema.ts
src/modules/attendance/services/attendance.service.ts
src/modules/auth/controllers/user.controller.ts
src/modules/auth/guard/auth.guard.ts
src/modules/auth/schemas/user.schema.ts
src/modules/auth/services/user.service.ts
src/modules/auth/user.module.ts
src/modules/branch/branch.module.ts
src/modules/branch/controllers/branch.controller.ts
src/modules/branch/dtos/create-branch.dto.ts
src/modules/branch/schemas/branch.schema.ts
src/modules/branch/services/branch.service.ts
src/modules/brand/brand.module.ts
src/modules/brand/controllers/brand.controller.ts
src/modules/brand/schemas/brand.schema.ts
src/modules/brand/services/brand.service.ts
src/modules/carrier-group/carrier-group.module.ts
src/modules/carrier-group/controllers/carrier-group.controller.ts
src/modules/carrier-group/schemas/carrier-group.schema.ts
src/modules/carrier-group/services/carrier-group.service.ts
src/modules/carrier/carrier.module.ts
src/modules/carrier/controllers/carrier.controller.ts
src/modules/carrier/schemas/carrier.schema.ts
src/modules/carrier/services/carrier.service.ts
src/modules/cash-book/cash-book.module.ts
src/modules/cash-book/controllers/cash-book.controller.ts
src/modules/cash-book/schemas/cash-book.schema.ts
src/modules/cash-book/services/cash-book.service.ts
src/modules/category/categories.module.ts
src/modules/category/controllers/categories.controller.ts
src/modules/category/schemas/categories.schema.ts
src/modules/category/services/categories.service.ts
src/modules/commission-setting/commission-setting.module.ts
src/modules/commission-setting/controllers/commission-setting.controller.ts
src/modules/commission-setting/schemas/commission-setting.schema.ts
src/modules/commission-setting/services/commission-setting.service.ts
src/modules/customer/controllers/customer.controller.ts
src/modules/customer/customer.module.ts
src/modules/customer/schemas/customer.schema.ts
src/modules/customer/services/customer.service.ts
src/modules/department/controllers/department.controller.ts
src/modules/department/department.module.ts
src/modules/department/schemas/department.schema.ts
src/modules/department/services/department.service.ts
src/modules/employee/controllers/employee.controller.ts
src/modules/employee/employee.module.ts
src/modules/employee/schemas/employee.schema.ts
src/modules/employee/services/employee.service.ts
src/modules/holiday/controllers/holiday.controller.ts
src/modules/holiday/holiday.module.ts
src/modules/holiday/schemas/holiday.schema.ts
src/modules/holiday/services/holiday.service.ts
src/modules/invoice/controllers/invoice.controller.ts
src/modules/invoice/invoice.module.ts
src/modules/invoice/schemas/invoice.schema.ts
src/modules/invoice/services/invoice.service.ts
src/modules/order/controllers/order.controller.ts
src/modules/order/order.module.ts
src/modules/order/schemas/order.schema.ts
src/modules/order/services/order.service.ts
src/modules/payroll/controllers/payroll.controller.ts
src/modules/payroll/payroll.module.ts
src/modules/payroll/schemas/payroll.schema.ts
src/modules/payroll/services/payroll.service.ts
src/modules/position/controllers/position.controller.ts
src/modules/position/position.module.ts
src/modules/position/schemas/position.schema.ts
src/modules/position/services/position.service.ts
src/modules/product/controllers/product.controller.ts
src/modules/product/product.module.ts
src/modules/product/schemas/product.schema.ts
src/modules/product/services/product.service.ts
src/modules/purchase-history/controllers/purchase-history.controller.ts
src/modules/purchase-history/purchase-history.module.ts
src/modules/purchase-history/schemas/purchase-history.schema.ts
src/modules/purchase-history/services/purchase-history.service.ts
src/modules/purchase-order/controllers/purchase-orders.controller.ts
src/modules/purchase-order/purchase-orders.module.ts
src/modules/purchase-order/schemas/purchase-orders.schema.ts
src/modules/purchase-order/services/purchase-orders.service.ts
src/modules/ruturn/controllers/return.controller.ts
src/modules/ruturn/return.module.ts
src/modules/ruturn/schemas/return.schema.ts
src/modules/ruturn/services/return.service.ts
src/modules/service-package/controllers/service-package.controller.ts
src/modules/service-package/schemas/service-package.schems.ts
src/modules/service-package/service-package.module.ts
src/modules/service-package/services/service-package.service.ts
src/modules/shipment/controllers/shipment.controller.ts
src/modules/shipment/schemas/shipment.schema.ts
src/modules/shipment/services/shipment.service.ts
src/modules/shipment/shipment.module.ts
src/modules/store/controllers/store.controller.ts
src/modules/store/schemas/store.schema.ts
src/modules/store/services/store.service.ts
src/modules/store/store.module.ts
src/modules/supplier-group/controllers/supplier-group.controller.ts
src/modules/supplier-group/schemas/supplier-group.schema.ts
src/modules/supplier-group/services/supplier-group.service.ts
src/modules/supplier-group/supplier-group.module.ts
src/modules/supplier/controllers/supplier.controller.ts
src/modules/supplier/schemas/supplier.schema.ts
src/modules/supplier/services/supplier.service.ts
src/modules/supplier/supplier.module.ts
test/app.e2e-spec.ts
test/jest-e2e.json
tsconfig.build.json
tsconfig.json

================================================================
Files
================================================================

================
File: .gitignore
================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

================
File: .prettierrc
================
{
  "singleQuote": true,
  "trailingComma": "all"
}

================
File: ch·ª©c nƒÉng kiotviet.txt
================
D·ª±a tr√™n ƒëo·∫°n vƒÉn b·∫£n ƒë∆∞·ª£c cung c·∫•p trong truy v·∫•n, t√¥i s·∫Ω ph√¢n t√≠ch v√† li·ªát k√™ c·ª• th·ªÉ c√°c ch·ª©c nƒÉng c·ªßa Website KiotViet. C√°c ch·ª©c nƒÉng n√†y ƒë∆∞·ª£c t·ªï ch·ª©c theo t·ª´ng trang ch√≠nh v√† c√°c m·ª•c con t∆∞∆°ng ·ª©ng, ƒë·∫£m b·∫£o bao qu√°t to√†n b·ªô th√¥ng tin ƒë√£ cho.

---

### 1. Trang T·ªïng Quan
Trang n√†y cung c·∫•p th√¥ng tin t·ªïng th·ªÉ v·ªÅ gian h√†ng v√† c√°c ho·∫°t ƒë·ªông li√™n quan ƒë·∫øn g√≥i d·ªãch v·ª•, thanh to√°n.

#### 1.1. Th√¥ng tin gian h√†ng
- Hi·ªÉn th·ªã th√¥ng tin c∆° b·∫£n v·ªÅ t√†i kho·∫£n:
  - **Lo·∫°i t√†i kho·∫£n**: C√° nh√¢n ho·∫∑c doanh nghi·ªáp.
  - **Ng∆∞·ªùi ƒë·∫°i di·ªán**: Ng∆∞·ªùi t·∫°o t√†i kho·∫£n.
  - **S·ªë ƒëi·ªán tho·∫°i**: ƒê∆∞·ª£c cung c·∫•p khi t·∫°o t√†i kho·∫£n.
  - **Email**.
  - **Gi·ªõi t√≠nh**.
  - **Ng√†y sinh**.
  - **CCCD/H·ªô chi·∫øu**, bao g·ªìm ng√†y c·∫•p v√† n∆°i c·∫•p.
  - **ƒê·ªãa ch·ªâ**.
  - **T√™n gian h√†ng**: Y√™u c·∫ßu khi t·∫°o t√†i kho·∫£n.
  - **Ng√†nh h√†ng**: L·ª±a ch·ªçn khi ƒëƒÉng k√Ω.
  - **S·ªë chi nh√°nh**.
  - **S·ªë nh√¢n vi√™n**.
  - **T√¨nh tr·∫°ng**: ƒêang s·ª≠ d·ª•ng ho·∫∑c ng·ª´ng s·ª≠ d·ª•ng.
  - **Ng√†y h·∫øt h·∫°n**: Ph·ª• thu·ªôc v√†o g√≥i d·ªãch v·ª• ƒë√£ mua.
  - **G√≥i d·ªãch v·ª•**: M·∫∑c ƒë·ªãnh l√† g√≥i d√πng th·ª≠ 7 ng√†y khi t·∫°o t√†i kho·∫£n.
  - **S·ªë l∆∞·ª£ng kho**.

#### 1.2. G√≥i d·ªãch v·ª•
- **Xem v√† mua g√≥i d·ªãch v·ª•**:
  - Bao g·ªìm c√°c g√≥i nh∆∞:
    - **G√≥i h·ªó tr·ª£**: C√°c ch·ª©c nƒÉng c∆° b·∫£n.
    - **G√≥i chuy√™n nghi·ªáp**: N√¢ng cao, c√≥ h·ªó tr·ª£ ri√™ng.
    - **G√≥i cao c·∫•p**: Bao g·ªìm t·∫•t c·∫£ ch·ª©c nƒÉng.
  - Quy tr√¨nh mua:
    - Ch·ªçn g√≥i v√† th·ªùi gian s·ª≠ d·ª•ng (1-5 nƒÉm), th√™m s·∫£n ph·∫©m mua k√®m.
    - Nh·∫≠p th√¥ng tin c√° nh√¢n: Ng∆∞·ªùi ƒë·∫°i di·ªán, gi·ªõi t√≠nh, s·ªë ƒëi·ªán tho·∫°i, email, CCCD/h·ªô chi·∫øu, ƒë·ªãa ch·ªâ.
    - Thanh to√°n.

#### 1.3. L·ªãch s·ª≠ mua h√†ng
- Theo d√µi c√°c giao d·ªãch mua g√≥i d·ªãch v·ª• tr√™n website.

#### 1.4. Thanh to√°n
- **N·∫°p ti·ªÅn** v√†o t√†i kho·∫£n.
- **Xem s·ªë d∆∞**: S·ªë d∆∞ hi·ªán t·∫°i, s·ªë d∆∞ ƒë·∫ßu k·ª≥, t·ªïng ti·ªÅn n·∫°p, t·ªïng ti·ªÅn chi.
- **Theo d√µi giao d·ªãch**: Xem l·ªãch s·ª≠ c√°c giao d·ªãch ƒë√£ th·ª±c hi·ªán.

---

### 2. Trang Dashboard
Cung c·∫•p c√°i nh√¨n t·ªïng quan v·ªÅ hi·ªáu su·∫•t b√°n h√†ng.
- **K·∫øt qu·∫£ b√°n h√†ng**: S·ªë h√≥a ƒë∆°n, doanh thu, ph·∫ßn trƒÉm thu nh·∫≠p so v·ªõi th√°ng tr∆∞·ªõc.
- **Xem doanh thu**: Theo ng√†y, th√°ng, ho·∫∑c gi·ªù.
- **H√†ng h√≥a b√°n ch·∫°y**: Danh s√°ch s·∫£n ph·∫©m b√°n t·ªët.
- **Th√¥ng b√°o ho·∫°t ƒë·ªông**: V√≠ d·ª•: ‚Äú‚Ä¶ v·ª´a nh·∫≠n ƒë·∫∑t h√†ng v·ªõi gi√° tr·ªã ‚Ä¶‚Äù.

---

### 3. Trang H√†ng H√≥a
Qu·∫£n l√Ω s·∫£n ph·∫©m v√† c√°c ho·∫°t ƒë·ªông li√™n quan, bao g·ªìm 3 m·ª•c ch√≠nh.

#### 3.1. Danh m·ª•c
- **L·ªçc s·∫£n ph·∫©m**: Qua sidebar v·ªõi c√°c ti√™u ch√≠ nh∆∞ lo·∫°i h√†ng, nh√≥m h√†ng, t·ªìn kho, th∆∞∆°ng hi·ªáu, b√°n tr·ª±c ti·∫øp, th·ªùi gian t·∫°o, ng√†y d·ª± ki·∫øn h·∫øt h√†ng, nh√† cung c·∫•p, v·ªã tr√≠, li√™n k·∫øt k√™nh b√°n, l·ª±a ch·ªçn hi·ªÉn th·ªã.
- **Th√¥ng tin s·∫£n ph·∫©m**:
  - H√¨nh ·∫£nh, m√£ h√†ng (t·ª± ƒë·ªông), m√£ v·∫°ch, t√™n h√†ng, nh√≥m h√†ng, lo·∫°i h√†ng, li√™n k·∫øt k√™nh b√°n, gi√° b√°n, gi√° v·ªën, th∆∞∆°ng hi·ªáu, t·ªìn kho, v·ªã tr√≠, s·ªë kh√°ch ƒë·∫∑t, th·ªùi gian t·∫°o, th·ªùi gian d·ª± ki·∫øn h·∫øt h√†ng, ƒë·ªãnh m·ª©c t·ªìn (√≠t nh·∫•t/nhi·ªÅu nh·∫•t), tr·∫°ng th√°i (cho ph√©p kinh doanh/ng·ª´ng kinh doanh).
- **Th√™m s·∫£n ph·∫©m**:
  - Nh·∫≠p th√¥ng tin: M√£ h√†ng (t·ª± ƒë·ªông), m√£ v·∫°ch, t√™n h√†ng, nh√≥m h√†ng (ch·ªçn ho·∫∑c t·∫°o m·ªõi), th∆∞∆°ng hi·ªáu (ch·ªçn ho·∫∑c t·∫°o m·ªõi), v·ªã tr√≠, h√¨nh ·∫£nh, gi√° v·ªën, gi√° b√°n, t·ªìn kho, tr·ªçng l∆∞·ª£ng, b√°n tr·ª±c ti·∫øp (checkbox), ƒë∆°n v·ªã t√≠nh (th√™m ƒë∆°n v·ªã m·ªõi n·∫øu c·∫ßn), ƒë·ªãnh m·ª©c t·ªìn, m√¥ t·∫£, ghi ch√∫.
- **Xu·∫•t file s·∫£n ph·∫©m**: D·ª±a tr√™n c√°c ti√™u ch√≠ nh∆∞ t·ªìn kho, nh√≥m h√†ng, th∆∞∆°ng hi·ªáu.

#### 3.2. Thi·∫øt l·∫≠p gi√°
- **L·ªçc s·∫£n ph·∫©m**: Qua sidebar v·ªõi c√°c ti√™u ch√≠ nh∆∞ b·∫£ng gi√°, nh√≥m h√†ng, t·ªìn kho (d∆∞·ªõi ƒë·ªãnh m·ª©c, v∆∞·ª£t ƒë·ªãnh m·ª©c, c√≤n h√†ng, h·∫øt h√†ng), gi√° b√°n.
- **T·∫°o b·∫£ng gi√°**: T√™n b·∫£ng gi√°, th·ªùi gian hi·ªáu l·ª±c, tr·∫°ng th√°i (√°p d·ª•ng/ch∆∞a √°p d·ª•ng), ph·∫°m vi √°p d·ª•ng (to√†n h·ªá th·ªëng/chi nh√°nh), ƒë·ªëi t∆∞·ª£ng giao d·ªãch, gi·∫£m gi√° (s·ªë ti·ªÅn ho·∫∑c %).
- **Hi·ªÉn th·ªã s·∫£n ph·∫©m**: M√£ h√†ng, t√™n h√†ng, t·ªìn kho, gi√° v·ªën, gi√° nh·∫≠p cu·ªëi, b·∫£ng gi√° chung (c√≥ th·ªÉ ch·ªânh s·ª≠a).

#### 3.3. Ki·ªÉm kho
- **Th√¥ng tin ki·ªÉm kho**: M√£ ki·ªÉm kho (t·ª± ƒë·ªông), th·ªùi gian t·∫°o, ng∆∞·ªùi t·∫°o, ng∆∞·ªùi ki·ªÉm duy·ªát, ng√†y ki·ªÉm duy·ªát, s·ªë l∆∞·ª£ng th·ª±c t·∫ø, t·ªïng gi√° ti·ªÅn, t·ªïng ch√™nh l·ªách, s·ªë l∆∞·ª£ng l·ªách, ghi ch√∫, tr·∫°ng th√°i (ƒë√£ ki·ªÉm tra, phi·∫øu t·∫°m, ƒë√£ h·ªßy), m√£ h√†ng, t√™n h√†ng, t·ªìn kho.
- **L·ªçc**: Theo tr·∫°ng th√°i, ng∆∞·ªùi t·∫°o.
- **Th√™m ki·ªÉm kho**: Nh·∫≠p th√¥ng tin nh∆∞ m√£ h√†ng, t√™n h√†ng, t·ªìn kho, s·ªë l∆∞·ª£ng th·ª±c t·∫ø, ch√™nh l·ªách, gi√° tr·ªã l·ªách, nh√¢n vi√™n ki·ªÉm tra, ghi ch√∫.

---

### 4. Trang Giao D·ªãch
Qu·∫£n l√Ω c√°c ho·∫°t ƒë·ªông giao d·ªãch b√°n h√†ng v√† nh·∫≠p h√†ng.

#### 4.1. ƒê·∫∑t h√†ng
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i (phi·∫øu t·∫°m, ƒë√£ x√°c nh·∫≠n, ƒëang giao, ho√†n th√†nh, ƒë√£ h·ªßy), ng∆∞·ªùi t·∫°o, ng∆∞·ªùi nh·∫≠n ƒë·∫∑t, k√™nh b√°n (th√™m k√™nh m·ªõi), ƒë·ªëi t√°c giao h√†ng, th·ªùi gian giao, khu v·ª±c, ph∆∞∆°ng th·ª©c thanh to√°n.
- **Th√¥ng tin**: M√£ v·∫≠n ƒë∆°n, m√£ ƒë·∫∑t h√†ng, m√£ h√≥a ƒë∆°n, th·ªùi gian t·∫°o, ng√†y c·∫≠p nh·∫≠t, th·ªùi gian giao, kh√°ch h√†ng, s·ªë ƒëi·ªán tho·∫°i, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, ng√†y sinh, ƒë·ªëi t√°c giao h√†ng, ng∆∞·ªùi nh·∫≠n ƒë·∫∑t, ng∆∞·ªùi t·∫°o, k√™nh b√°n, t·ªïng ti·ªÅn, gi·∫£m gi√°, kh√°ch c·∫ßn tr·∫£, kh√°ch ƒë√£ tr·∫£, tr·∫°ng th√°i, m√£ s·∫£n ph·∫©m, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.

#### 4.2. H√≥a ƒë∆°n
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i (ƒëang x·ª≠ l√Ω, ho√†n th√†nh, kh√¥ng giao ƒë∆∞·ª£c, ƒë√£ h·ªßy), ph∆∞∆°ng th·ª©c b√°n, ng∆∞·ªùi t·∫°o, ng∆∞·ªùi b√°n, tr·∫°ng th√°i giao h√†ng, k√™nh b√°n, ƒë·ªëi t√°c giao h√†ng, khu v·ª±c, ph∆∞∆°ng th·ª©c thanh to√°n, b·∫£ng gi√°.
- **Th√¥ng tin**: M√£ h√≥a ƒë∆°n, m√£ v·∫≠n ƒë∆°n, tr·∫°ng th√°i giao h√†ng, m√£ ƒë·ªëi so√°t, th·ªùi gian t·∫°o, ng√†y c·∫≠p nh·∫≠t, m√£ ƒë·∫∑t h√†ng, m√£ tr·∫£ h√†ng, kh√°ch h√†ng, email, s·ªë ƒëi·ªán tho·∫°i, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, ng√†y sinh, chi nh√°nh, ng∆∞·ªùi b√°n, ng∆∞·ªùi t·∫°o, k√™nh b√°n, ƒë·ªëi t√°c giao h√†ng, ghi ch√∫, t·ªïng ti·ªÅn, gi·∫£m gi√°, gi·∫£m thu·∫ø, kh√°ch c·∫ßn tr·∫£, kh√°ch ƒë√£ tr·∫£, c·∫ßn thu COD, ph√≠ tr·∫£ ƒë·ªëi t√°c, tr·∫°ng th√°i, m√£ h√†ng, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.

#### 4.3. V·∫≠n ƒë∆°n
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i giao h√†ng, ƒë·ªëi t√°c giao h√†ng, khu v·ª±c, thu h·ªô ti·ªÅn.
- **Th√¥ng tin**: M√£ v·∫≠n ƒë∆°n, th·ªùi gian t·∫°o, th·ªùi gian ho√†n th√†nh, ng∆∞·ªùi t·∫°o, m√£ h√≥a ƒë∆°n, kh√°ch h√†ng, chi nh√°nh, nh√¢n vi√™n b√°n, ng∆∞·ªùi nh·∫≠n, s·ªë ƒëi·ªán tho·∫°i, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, ƒë·ªëi t√°c giao h√†ng, ghi ch√∫, tr·∫°ng th√°i, d·ªãch v·ª•, c·∫ßn thu h·ªô, t·ªïng c∆∞·ªõc ph√≠, m√£ ƒë·ªëi so√°t, ph√≠ tr·∫£ ƒë·ªëi t√°c, m√£ h√†ng, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.

#### 4.4. Tr·∫£ h√†ng
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i (ƒë√£ tr·∫£, ƒë√£ h·ªßy), ng∆∞·ªùi t·∫°o, ng∆∞·ªùi nh·∫≠n tr·∫£, k√™nh b√°n, lo·∫°i phi·∫øu (theo h√≥a ƒë∆°n, tr·∫£ nhanh, chuy·ªÉn ho√†n).
- **Th√¥ng tin**: M√£ tr·∫£ h√†ng, m√£ h√≥a ƒë∆°n, m√£ v·∫≠n ƒë∆°n, ng∆∞·ªùi b√°n, th·ªùi gian t·∫°o, kh√°ch h√†ng, chi nh√°nh, ng∆∞·ªùi nh·∫≠n tr·∫£, ng∆∞·ªùi t·∫°o, k√™nh b√°n, ghi ch√∫, t·ªïng ti·ªÅn tr·∫£, gi·∫£m gi√°, t·ªïng sau gi·∫£m, gi·∫£m thu·∫ø ho√†n l·∫°i, ph√≠ tr·∫£ h√†ng, thu kh√°c ho√†n l·∫°i, c·∫ßn tr·∫£ kh√°ch, ƒë√£ tr·∫£ kh√°ch, tr·∫°ng th√°i, m√£ h√†ng, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.
- **Th√™m tr·∫£ h√†ng**: Ch·ªçn h√≥a ƒë∆°n t·ª´ danh s√°ch, nh·∫≠p th√¥ng tin nh√¢n vi√™n ho√†n tr·∫£, kh√°ch h√†ng, m√£ h√≥a ƒë∆°n.

#### 4.5. Nh·∫≠p h√†ng
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i (phi·∫øu t·∫°m, ƒë√£ nh·∫≠p, ƒë√£ h·ªßy), ng∆∞·ªùi t·∫°o, ng∆∞·ªùi nh·∫≠p.
- **Th√¥ng tin**: M√£ nh·∫≠p h√†ng, m√£ tr·∫£ nh·∫≠p h√†ng, th·ªùi gian t·∫°o, ng√†y c·∫≠p nh·∫≠t, nh√† cung c·∫•p, chi nh√°nh, ng∆∞·ªùi nh·∫≠p, ng∆∞·ªùi t·∫°o, t·ªïng s·ªë l∆∞·ª£ng, t·ªïng s·ªë m·∫∑t h√†ng, t·ªïng ti·ªÅn, gi·∫£m gi√°, c·∫ßn tr·∫£ nh√† cung c·∫•p, chi·∫øt kh·∫•u thanh to√°n, ti·ªÅn ƒë√£ tr·∫£, ghi ch√∫, tr·∫°ng th√°i, m√£ h√†ng, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.
- **Th√™m nh·∫≠p h√†ng**: Nh·∫≠p STT, m√£ h√†ng, t√™n h√†ng, ƒë∆°n v·ªã t√≠nh, t·ªìn kho, gi√° v·ªën, gi√° b√°n, tr·∫°ng th√°i (phi·∫øu t·∫°m), nh√† cung c·∫•p, nh√¢n vi√™n th·ª±c hi·ªán.

#### 4.6. Tr·∫£ h√†ng nh·∫≠p
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i (phi·∫øu t·∫°m, ƒë√£ tr·∫£, ƒë√£ h·ªßy), ng∆∞·ªùi t·∫°o, ng∆∞·ªùi tr·∫£.
- **Th√¥ng tin**: M√£ tr·∫£ h√†ng nh·∫≠p, th·ªùi gian t·∫°o, nh√† cung c·∫•p, chi nh√°nh, ng∆∞·ªùi tr·∫£, ng∆∞·ªùi t·∫°o, ghi ch√∫, t·ªïng s·ªë l∆∞·ª£ng, t·ªïng s·ªë m·∫∑t h√†ng, t·ªïng ti·ªÅn tr·∫£, gi·∫£m gi√°, nh√† cung c·∫•p c·∫ßn tr·∫£, nh√† cung c·∫•p ƒë√£ tr·∫£, tr·∫°ng th√°i, m√£ h√†ng, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.
- **Th√™m tr·∫£ nh·∫≠p h√†ng**: Nh·∫≠p STT, m√£ h√†ng, t√™n h√†ng, ƒë∆°n v·ªã t√≠nh, s·ªë l∆∞·ª£ng, gi√° nh·∫≠p, gi√° tr·∫£ l·∫°i, nh√† cung c·∫•p.

#### 4.7. Xu·∫•t h·ªßy
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i (phi·∫øu t·∫°m, ho√†n th√†nh, ƒë√£ h·ªßy), ng∆∞·ªùi t·∫°o, ng∆∞·ªùi xu·∫•t h·ªßy.
- **Th√¥ng tin**: M√£ xu·∫•t h·ªßy, t·ªïng gi√° tr·ªã h·ªßy, th·ªùi gian t·∫°o, chi nh√°nh, ng∆∞·ªùi xu·∫•t h·ªßy, ng∆∞·ªùi t·∫°o, ghi ch√∫, tr·∫°ng th√°i, m√£ h√†ng, t√™n h√†ng, s·ªë l∆∞·ª£ng, ƒë∆°n gi√°, gi·∫£m gi√°, th√†nh ti·ªÅn.
- **Th√™m xu·∫•t h·ªßy**: Nh·∫≠p STT, m√£ h√†ng, t√™n h√†ng, ƒë∆°n v·ªã t√≠nh, s·ªë l∆∞·ª£ng h·ªßy, gi√° v·ªën, gi√° tr·ªã h·ªßy, tr·∫°ng th√°i phi·∫øu.

---

### 5. Trang ƒê·ªëi T√°c
Qu·∫£n l√Ω th√¥ng tin v·ªÅ kh√°ch h√†ng, nh√† cung c·∫•p, v√† ƒë·ªëi t√°c giao h√†ng.

#### 5.1. Kh√°ch h√†ng
- **L·ªçc**: Nh√≥m kh√°ch h√†ng, ng√†y t·∫°o, ng∆∞·ªùi t·∫°o, sinh nh·∫≠t, ng√†y giao d·ªãch cu·ªëi, t·ªïng b√°n, n·ª£ hi·ªán t·∫°i, lo·∫°i kh√°ch, gi·ªõi t√≠nh, khu v·ª±c, tr·∫°ng th√°i.
- **Th√™m kh√°ch h√†ng**: H√¨nh ·∫£nh, m√£ kh√°ch h√†ng, t√™n, s·ªë ƒëi·ªán tho·∫°i, ng√†y sinh, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, lo·∫°i kh√°ch, m√£ s·ªë thu·∫ø, CMND/CCCD, email, Facebook, nh√≥m, ghi ch√∫.
- **Th√¥ng tin**: M√£ kh√°ch h√†ng, t√™n, lo·∫°i kh√°ch, s·ªë ƒëi·ªán tho·∫°i, nh√≥m, gi·ªõi t√≠nh, ng√†y sinh, email, Facebook, c√¥ng ty, m√£ s·ªë thu·∫ø, CMND/CCCD, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, ng∆∞·ªùi t·∫°o, ng√†y t·∫°o, ghi ch√∫, ng√†y giao d·ªãch cu·ªëi, n·ª£ hi·ªán t·∫°i, t·ªïng b√°n, t·ªïng b√°n tr·ª´ tr·∫£ h√†ng, tr·∫°ng th√°i.

#### 5.2. Nh√† cung c·∫•p
- **L·ªçc**: Nh√≥m nh√† cung c·∫•p, t·ªïng mua, n·ª£ hi·ªán t·∫°i, tr·∫°ng th√°i.
- **Th√™m nh√† cung c·∫•p**: M√£, t√™n, s·ªë ƒëi·ªán tho·∫°i, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, chi nh√°nh, email, c√¥ng ty, m√£ s·ªë thu·∫ø, nh√≥m, ghi ch√∫.
- **Th√¥ng tin**: M√£, t√™n, s·ªë ƒëi·ªán tho·∫°i, nh√≥m, email, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, c√¥ng ty, ghi ch√∫, m√£ s·ªë thu·∫ø, ng∆∞·ªùi t·∫°o, ng√†y t·∫°o, n·ª£ c·∫ßn tr·∫£, t·ªïng mua, t·ªïng mua tr·ª´ tr·∫£ h√†ng, tr·∫°ng th√°i.

#### 5.3. ƒê·ªëi t√°c giao h√†ng
- **L·ªçc**: Nh√≥m ƒë·ªëi t√°c, t·ªïng ph√≠ giao h√†ng, n·ª£ hi·ªán t·∫°i, tr·∫°ng th√°i.
- **Th√™m ƒë·ªëi t√°c**: Lo·∫°i ƒë·ªëi t√°c, m√£, t√™n, s·ªë ƒëi·ªán tho·∫°i, email, nh√≥m, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, ghi ch√∫.
- **Th√¥ng tin**: M√£, t√™n, s·ªë ƒëi·ªán tho·∫°i, email, t·ªïng ƒë∆°n h√†ng, c·∫ßn thu h·ªô, t·ªïng tr·ªçng l∆∞·ª£ng, n·ª£ c·∫ßn tr·∫£, t·ªïng ph√≠ giao h√†ng, tr·∫°ng th√°i.

---

### 6. Trang Nh√¢n Vi√™n
Qu·∫£n l√Ω nh√¢n vi√™n v√† c√°c ho·∫°t ƒë·ªông li√™n quan.

#### 6.1. Nh√¢n vi√™n
- **Th√™m nh√¢n vi√™n**:
  - Th√¥ng tin c∆° b·∫£n: H√¨nh ·∫£nh, m√£ (t·ª± ƒë·ªông), t√™n, s·ªë ƒëi·ªán tho·∫°i, ng√†y sinh, gi·ªõi t√≠nh, ghi ch√∫.
  - Chi nh√°nh & ch·ª©c danh: Chi nh√°nh tr·∫£ l∆∞∆°ng, chi nh√°nh l√†m vi·ªác, ng√†y b·∫Øt ƒë·∫ßu, ch·ª©c danh, ph√≤ng ban.
  - T√†i kho·∫£n ƒëƒÉng nh·∫≠p: T√™n ng∆∞·ªùi d√πng, t√™n ƒëƒÉng nh·∫≠p, m·∫≠t kh·∫©u, vai tr√≤, chi nh√°nh, email, ƒë·ªãa ch·ªâ, khu v·ª±c, ph∆∞·ªùng/x√£, s·ªë ƒëi·ªán tho·∫°i, quy·ªÅn admin.
  - Th√¥ng tin c√° nh√¢n: CMND/CCCD.
  - Th√¥ng tin li√™n h·ªá: ƒê·ªãa ch·ªâ, email, khu v·ª±c, ph∆∞·ªùng/x√£, Facebook.
  - Thi·∫øt l·∫≠p l∆∞∆°ng: H√¨nh th·ª©c (theo ca, gi·ªù, ng√†y c√¥ng, c·ªë ƒë·ªãnh), th∆∞·ªüng, hoa h·ªìng, ph·ª• c·∫•p, gi·∫£m tr·ª´.
- **Th√¥ng tin**: ·∫¢nh, m√£, m√£ ch·∫•m c√¥ng, t√™n, s·ªë ƒëi·ªán tho·∫°i, CMND/CCCD, n·ª£ v√† t·∫°m ·ª©ng, ghi ch√∫, thi·∫øt b·ªã di ƒë·ªông, ng√†y sinh, gi·ªõi t√≠nh, email, Facebook, ƒë·ªãa ch·ªâ, chi nh√°nh, ph√≤ng ban, ch·ª©c danh, ng√†y b·∫Øt ƒë·∫ßu, t√†i kho·∫£n ƒëƒÉng nh·∫≠p.
- **L·ªçc**: Tr·∫°ng th√°i, chi nh√°nh, ph√≤ng ban, ch·ª©c danh.

#### 6.2. L·ªãch l√†m vi·ªác
- **Th√™m l·ªãch**: T·∫°o ca l√†m vi·ªác (h√†nh ch√≠nh ho·∫∑c t√πy ch·ªânh), l·∫∑p l·∫°i h√†ng tu·∫ßn, l√†m vi·ªác ng√†y l·ªÖ, th√™m nh√¢n vi√™n c√πng l·ªãch.

#### 6.3. Ch·∫•m c√¥ng
- **Hi·ªÉn th·ªã**: ƒê√∫ng gi·ªù, ƒëi mu·ªôn/v·ªÅ s·ªõm, ch·∫•m c√¥ng thi·∫øu, ch∆∞a ch·∫•m c√¥ng, ngh·ªâ l√†m.

#### 6.4. B·∫£ng t√≠nh l∆∞∆°ng
- **L·ªçc**: Chi nh√°nh, k·ª≥ h·∫°n, tr·∫°ng th√°i (ƒëang t·∫°o, t·∫°m t√≠nh, ƒë√£ ch·ªët, ƒë√£ h·ªßy).
- **Th√¥ng tin**: M√£, t√™n, k·ª≥ h·∫°n, k·ª≥ l√†m vi·ªác, chi nh√°nh, s·ªë nh√¢n vi√™n, t·ªïng l∆∞∆°ng, ƒë√£ tr·∫£, c√≤n c·∫ßn tr·∫£, tr·∫°ng th√°i, ng∆∞·ªùi t·∫°o, ng√†y t·∫°o, ghi ch√∫, l·ªãch s·ª≠ thanh to√°n.

#### 6.5. Thi·∫øt l·∫≠p hoa h·ªìng
- **H√†ng h√≥a**: T·∫°o b·∫£ng hoa h·ªìng (t√™n, ph·∫°m vi, tr·∫°ng th√°i), hi·ªÉn th·ªã m√£ h√†ng, t√™n, ƒë∆°n v·ªã, gi√° b√°n, gi√° v·ªën, l·ª£i nhu·∫≠n.
- **Nh√¢n vi√™n**: T·∫°o b·∫£ng hoa h·ªìng, hi·ªÉn th·ªã lo·∫°i h√¨nh, doanh thu, b·∫£ng √°p d·ª•ng.

#### 6.6. Thi·∫øt l·∫≠p nh√¢n vi√™n
- **Kh·ªüi t·∫°o**: T√™n, s·ªë ƒëi·ªán tho·∫°i, b·∫£ng l∆∞∆°ng, lo·∫°i l∆∞∆°ng, chi ti·∫øt l∆∞∆°ng (th∆∞·ªüng, hoa h·ªìng, ph·ª• c·∫•p, gi·∫£m tr·ª´).
- **Ca l√†m vi·ªác**: Th√™m ca (h√†nh ch√≠nh ho·∫∑c t√πy ch·ªânh), th·ªùi gian, chi nh√°nh, tr·∫°ng th√°i.
- **Ch·∫•m c√¥ng**: Th√™m ng√†y l√†m, s·ªë gi·ªù chu·∫©n, ƒëi mu·ªôn/v·ªÅ s·ªõm, l√†m th√™m gi·ªù, t·ª± ƒë·ªông ch·∫•m c√¥ng.
- **T√≠nh l∆∞∆°ng**: Ch·ªçn ng√†y t√≠nh, t·ª± ƒë·ªông t·∫°o/c·∫≠p nh·∫≠t b·∫£ng l∆∞∆°ng, thi·∫øt l·∫≠p m·∫´u l∆∞∆°ng.
- **Qu·∫£n l√Ω l·ªÖ t·∫øt**: Th√™m ng√†y l·ªÖ, t·ª± ƒë·ªông ƒëi·ªÅn c√°c ng√†y l·ªÖ m·∫∑c ƒë·ªãnh.

---

### 7. Trang S·ªï Qu·ªπ
- **L·ªçc**: Qu·ªπ ti·ªÅn, th·ªùi gian, lo·∫°i ch·ª©ng t·ª´, lo·∫°i thu chi, tr·∫°ng th√°i, k·∫øt qu·∫£ kinh doanh, ng∆∞·ªùi t·∫°o, nh√¢n vi√™n, c√¥ng n·ª£, ƒë·ªëi t∆∞·ª£ng n·ªôp/nh·∫≠n.
- **Th√¥ng tin**: M√£ phi·∫øu, th·ªùi gian, ng∆∞·ªùi t·∫°o, nh√¢n vi√™n, chi nh√°nh, lo·∫°i thu chi, m√£ ng∆∞·ªùi n·ªôp/nh·∫≠n, t√™n, s·ªë ƒëi·ªán tho·∫°i, ƒë·ªãa ch·ªâ, gi√° tr·ªã, ghi ch√∫, tr·∫°ng th√°i.

---

### 8. Trang B√°o C√°o
Cung c·∫•p c√°c b√°o c√°o chi ti·∫øt v·ªÅ ho·∫°t ƒë·ªông kinh doanh.

#### 8.1. B√°o c√°o cu·ªëi ng√†y
- **L·ªçc**: Th·ªùi gian, kh√°ch h√†ng, nh√¢n vi√™n, ng∆∞·ªùi t·∫°o, ph∆∞∆°ng th·ª©c thanh to√°n, ph∆∞∆°ng th·ª©c b√°n.
- **Th√¥ng tin**: M√£ ch·ª©ng t·ª´, kh√°ch h√†ng, nh√¢n vi√™n, th·ªùi gian, s·ªë l∆∞·ª£ng, t·ªïng ti·ªÅn, gi·∫£m gi√°, doanh thu, VAT, ph√≠ tr·∫£ h√†ng, th·ª±c thu, ghi n·ª£.

#### 8.2. B√°n h√†ng
- **L·ªçc**: B·∫£ng gi√°, th·ªùi gian, ph∆∞∆°ng th·ª©c b√°n, k√™nh b√°n.
- **Th√¥ng tin**: Th·ªùi gian, s·ªë ƒë∆°n b√°n, t·ªïng ti·ªÅn, doanh thu, s·ªë ƒë∆°n tr·∫£, gi√° tr·ªã tr·∫£, doanh thu thu·∫ßn.

#### 8.3. ƒê·∫∑t h√†ng
- **L·ªçc**: Th·ªùi gian, tr·∫°ng th√°i, kh√°ch h√†ng, h√†ng h√≥a, lo·∫°i h√†ng, th∆∞∆°ng hi·ªáu, nh√≥m h√†ng, nh√¢n vi√™n.
- **Th√¥ng tin**: M√£ h√†ng, t√™n, s·ªë l∆∞·ª£ng ƒë·∫∑t, gi√° tr·ªã ni√™m y·∫øt, gi√° tr·ªã h√†ng ƒë·∫∑t, ch√™nh l·ªách, s·ªë l∆∞·ª£ng ƒë√£ nh·∫≠n, s·ªë l∆∞·ª£ng c√≤n l·∫°i.

#### 8.4. H√†ng h√≥a
- **L·ªçc**: M·ªëi quan t√¢m, b·∫£ng gi√°, th·ªùi gian, h√†ng h√≥a, lo·∫°i h√†ng, th∆∞∆°ng hi·ªáu, nh√≥m h√†ng.
- **Hi·ªÉn th·ªã**: Bi·ªÉu ƒë·ªì top 10 s·∫£n ph·∫©m (tr·ª´ tr·∫£ h√†ng).

#### 8.5. Kh√°ch h√†ng
- **L·ªçc**: M·ªëi quan t√¢m, th·ªùi gian, kh√°ch h√†ng.
- **Hi·ªÉn th·ªã**: Bi·ªÉu ƒë·ªì top 10 s·∫£n ph·∫©m (tr·ª´ tr·∫£ h√†ng).

#### 8.6. Nh√† cung c·∫•p
- **L·ªçc**: M·ªëi quan t√¢m, th·ªùi gian, nh√† cung c·∫•p.
- **Hi·ªÉn th·ªã**: Bi·ªÉu ƒë·ªì top 10 s·∫£n ph·∫©m (tr·ª´ tr·∫£ h√†ng).

#### 8.7. Nh√¢n vi√™n
- **L·ªçc**: M·ªëi quan t√¢m, th·ªùi gian, ng∆∞·ªùi b√°n, k√™nh b√°n.
- **Hi·ªÉn th·ªã**: Bi·ªÉu ƒë·ªì top 10 s·∫£n ph·∫©m (tr·ª´ tr·∫£ h√†ng).

#### 8.8. K√™nh b√°n h√†ng
- **L·ªçc**: M·ªëi quan t√¢m, th·ªùi gian, ng∆∞·ªùi b√°n, k√™nh b√°n.
- **Hi·ªÉn th·ªã**: Bi·ªÉu ƒë·ªì top 10 s·∫£n ph·∫©m (tr·ª´ tr·∫£ h√†ng).

#### 8.9. T√†i ch√≠nh
- **L·ªçc**: Th·ªùi gian (th√°ng, nƒÉm, qu√Ω, kho·∫£ng c·ª• th·ªÉ).
- **Th√¥ng tin**: T·ªïng doanh thu, gi√° v·ªën, l·ª£i nhu·∫≠n.

---

### 9. Trang B√°n Online
Qu·∫£n l√Ω b√°n h√†ng tr·ª±c tuy·∫øn.

#### 9.1. B√°n online
- **K·∫øt n·ªëi**: V·ªõi s√†n TMƒêT (Shopee, TikTok Shop, Lazada, Tiki) v√† m·∫°ng x√£ h·ªôi (Facebook, Instagram).
- **Qu·∫£n l√Ω s√†n TMƒêT**: ƒê∆°n h√†ng, h√†ng h√≥a, h·ªôi tho·∫°i, ƒë·ªëi so√°t, marketing, thi·∫øt l·∫≠p k√™nh.
- **Qu·∫£n l√Ω m·∫°ng x√£ h·ªôi**: H·ªôi tho·∫°i, livestream, b√†i vi·∫øt, ƒë∆°n h√†ng, b√°o c√°o, catalog, thi·∫øt l·∫≠p.

#### 9.2. Website b√°n h√†ng
- **Website c·ªßa t√¥i**: L∆∞·ª£t truy c·∫≠p, qu·∫£n l√Ω giao di·ªán.
- **ƒê·ªìng b·ªô**: Ch·ªçn chi nh√°nh, b·∫£ng gi√° khuy·∫øn m√£i.
- **C√†i ƒë·∫∑t hi·ªÉn th·ªã**: T√™n c·ª≠a h√†ng, s·ªë ƒëi·ªán tho·∫°i, Zalo, Facebook, email, chi nh√°nh, s·ªë l∆∞·ª£ng ng∆∞·ªùi d√πng, tr·∫°ng th√°i.
- **Favicon**: S·ª≠a ·∫£nh.
- **H√¨nh th·ª©c b√°n h√†ng & nh·∫≠n h√†ng**: Checkbox nh·∫≠n t·∫°i c·ª≠a h√†ng.
- **T√™n mi·ªÅn**: Thay ƒë·ªïi ho·∫∑c ch·ªçn mi·ªÖn ph√≠.
- **SEO**: Google Business Profile, ti√™u ƒë·ªÅ, m√¥ t·∫£, h√¨nh ·∫£nh chia s·∫ª.
- **Popup**: T√™n, ƒë∆∞·ªùng d·∫´n, lo·∫°i, h√¨nh ·∫£nh, th·ªùi gian.
- **B·ªô C√¥ng Th∆∞∆°ng**: Ch·ª©ng nh·∫≠n, logo.
- **ƒêi·ªÅu h∆∞·ªõng**: Qu·∫£n l√Ω li√™n k·∫øt.
- **Ch·ªânh s·ª≠a giao di·ªán**: M√†u, ki·ªÉu ch·ªØ, banner, ƒë·∫ßu trang, d·ªãch v·ª•, nh√≥m h√†ng, s·∫£n ph·∫©m n·ªïi b·∫≠t, logo th∆∞∆°ng hi·ªáu, gi·ªõi thi·ªáu, ƒë√°nh gi√°, th∆∞ vi·ªán ·∫£nh, ch√¢n trang.
- **Kho giao di·ªán & h√¨nh ·∫£nh**: L∆∞u tr·ªØ v√† s·ª≠ d·ª•ng.
- **Danh s√°ch h√†ng h√≥a**: Hi·ªÉn th·ªã, ·∫©n/hi·ªán s·∫£n ph·∫©m.
- **Danh m·ª•c n·ªïi b·∫≠t**: T·∫°o v√† qu·∫£n l√Ω.
- **B√†i vi·∫øt**: T·∫°o v√† qu·∫£n l√Ω theo danh m·ª•c.

---

### 10. Trang Th√™m H√≥a ƒê∆°n/ƒê·∫∑t H√†ng
- **H√≥a ƒë∆°n**:
  - **B√°n nhanh**: M√£ s·∫£n ph·∫©m, t√™n, ƒë∆°n v·ªã, s·ªë l∆∞·ª£ng, gi√°, nh√¢n vi√™n, k√™nh b√°n, kh√°ch h√†ng, b·∫£ng gi√°, t·ªïng ti·ªÅn, ph∆∞∆°ng th·ª©c thanh to√°n, ghi ch√∫.
  - **B√°n th∆∞·ªùng**: M√£ s·∫£n ph·∫©m, t√™n, s·ªë l∆∞·ª£ng, gi√°, nh√¢n vi√™n, b·∫£ng gi√°, ti·ªÅn kh√°ch c·∫ßn tr·∫£, ƒë√£ tr·∫£, ph∆∞∆°ng th·ª©c thanh to√°n, ghi ch√∫.
  - **B√°n giao h√†ng**: M√£ s·∫£n ph·∫©m, t√™n, s·ªë l∆∞·ª£ng, gi√°, nh√¢n vi√™n, b·∫£ng gi√°, k√™nh b√°n, ƒë·ªãa ch·ªâ l·∫•y h√†ng, ng∆∞·ªùi nh·∫≠n, ƒë·ªãa ch·ªâ nh·∫≠n, tr·ªçng l∆∞·ª£ng, k√≠ch th∆∞·ªõc, ghi ch√∫, thu h·ªô COD.
- **ƒê·∫∑t h√†ng**: T∆∞∆°ng t·ª± h√≥a ƒë∆°n.

---

### 11. Qu·∫£n L√Ω Ng∆∞·ªùi D√πng
- **Ph√¢n quy·ªÅn**: Admin qu·∫£n l√Ω to√†n b·ªô (ƒë·ªëi t√°c, t√†i kho·∫£n nh√¢n vi√™n), nh√¢n vi√™n ch·ªâ truy c·∫≠p m·ª•c c·∫ßn thi·∫øt.

---

### T√≥m t·∫Øt
Website KiotViet cung c·∫•p h·ªá th·ªëng qu·∫£n l√Ω b√°n h√†ng to√†n di·ªán v·ªõi c√°c ch·ª©c nƒÉng ch√≠nh:
1. Qu·∫£n l√Ω th√¥ng tin gian h√†ng v√† g√≥i d·ªãch v·ª•.
2. Theo d√µi hi·ªáu su·∫•t b√°n h√†ng qua Dashboard.
3. Qu·∫£n l√Ω h√†ng h√≥a (danh m·ª•c, gi√°, ki·ªÉm kho).
4. Qu·∫£n l√Ω giao d·ªãch (ƒë·∫∑t h√†ng, h√≥a ƒë∆°n, v·∫≠n ƒë∆°n, tr·∫£ h√†ng, nh·∫≠p h√†ng, xu·∫•t h·ªßy).
5. Qu·∫£n l√Ω ƒë·ªëi t√°c (kh√°ch h√†ng, nh√† cung c·∫•p, giao h√†ng).
6. Qu·∫£n l√Ω nh√¢n vi√™n (th√¥ng tin, l·ªãch, ch·∫•m c√¥ng, l∆∞∆°ng, hoa h·ªìng).
7. Qu·∫£n l√Ω t√†i ch√≠nh qua s·ªï qu·ªπ.
8. B√°o c√°o chi ti·∫øt (b√°n h√†ng, h√†ng h√≥a, kh√°ch h√†ng, t√†i ch√≠nh,...).
9. B√°n h√†ng tr·ª±c tuy·∫øn (k√™nh TMƒêT, m·∫°ng x√£ h·ªôi, website).
10. T·∫°o h√≥a ƒë∆°n/ƒë·∫∑t h√†ng linh ho·∫°t.
11. Qu·∫£n l√Ω quy·ªÅn truy c·∫≠p ng∆∞·ªùi d√πng.

C√°c ch·ª©c nƒÉng n√†y h·ªó tr·ª£ ng∆∞·ªùi d√πng qu·∫£n l√Ω hi·ªáu qu·∫£ m·ªçi kh√≠a c·∫°nh c·ªßa ho·∫°t ƒë·ªông kinh doanh.

================
File: eslint.config.mjs
================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn'
    },
  },
);

================
File: nest-cli.json
================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

================
File: package.json
================
{
  "name": "backend",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.1",
    "@nestjs/config": "^4.0.1",
    "@nestjs/core": "^11.0.1",
    "@nestjs/mongoose": "^11.0.3",
    "@nestjs/platform-express": "^11.0.1",
    "bcryptjs": "^3.0.2",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.13.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@eslint/js": "^9.18.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.1",
    "@swc/cli": "^0.6.0",
    "@swc/core": "^1.10.7",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.7",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.18.0",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-prettier": "^5.2.2",
    "globals": "^16.0.0",
    "jest": "^29.7.0",
    "prettier": "^3.4.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.2",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.3",
    "typescript-eslint": "^8.20.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

================
File: README.md
================
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil My≈õliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).

================
File: src/app.controller.spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

================
File: src/app.controller.ts
================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

================
File: src/app.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { BranchModule } from './modules/branch/branch.module';
import { UserModule } from './modules/auth/user.module'
import { BrandModule } from './modules/brand/brand.module';
import { CategoriesModule } from './modules/category/categories.module';
import { AttendanceModule } from './modules/attendance/attendance.module';
import { CashBookModule } from './modules/cash-book/cash-book.module';
import { CarrierModule } from './modules/carrier/carrier.module';
import { OrderModule } from './modules/order/order.module';
import { CarrierGroupModule } from './modules/carrier-group/carrier-group.module';
import { CommissionSettingModule } from './modules/commission-setting/commission-setting.module';
import { CustomerModule } from './modules/customer/customer.module';
import { DepartmentModule } from './modules/department/department.module';
import { EmployeeModule } from './modules/employee/employee.module';
import { HolidayModule } from './modules/holiday/holiday.module';
import { InvoiceModule } from './modules/invoice/invoice.module';
import { PayrollModule } from './modules/payroll/payroll.module';
import { PositionModule } from './modules/position/position.module';
import { ProductModule } from './modules/product/product.module';
import { PurchaseOrderModule } from './modules/purchase-order/purchase-orders.module';
import { ReturnModule } from './modules/ruturn/return.module';
import { ShipmentModule } from './modules/shipment/shipment.module';
import { StoreModule } from './modules/store/store.module';
import { SupplierModule } from './modules/supplier/supplier.module';
import { SupplierGroupModule } from './modules/supplier-group/supplier-group.module';
import { ServicePackageModule } from './modules/service-package/service-package.module';
import { PurchaseHistoryModule } from './modules/purchase-history/purchase-history.module';
import { DatabaseModule } from './database/database.module';
import { ConfigModule } from '@nestjs/config';
@Module({
  imports: [
    // MongooseModule.forRoot('mongodb://localhost:27017/kiotviet'),
    ConfigModule.forRoot({
      isGlobal: true, // ƒê·∫£m b·∫£o ConfigModule ƒë∆∞·ª£c s·ª≠ d·ª•ng to√†n c·ª•c
    }),
    DatabaseModule,
    BranchModule,
    UserModule,
    BrandModule,
    CategoriesModule,
    AttendanceModule,
    CashBookModule,
    CarrierModule,
    OrderModule,
    CarrierGroupModule,
    CommissionSettingModule,
    CustomerModule,
    DepartmentModule,
    EmployeeModule,
    HolidayModule,
    InvoiceModule,
    PayrollModule,
    PositionModule,
    ProductModule,
    PurchaseOrderModule,
    ReturnModule,
    ShipmentModule,
    StoreModule,
    SupplierModule,
    SupplierGroupModule,
    ServicePackageModule,
    PurchaseHistoryModule
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule { }

================
File: src/app.service.ts
================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

================
File: src/database/database.module.ts
================
// src/database/database.module.ts
import { Module, OnModuleInit } from '@nestjs/common';
import { MongooseModule, MongooseModuleOptions } from '@nestjs/mongoose';
import { ConfigModule, ConfigService } from '@nestjs/config';
import mongoose from 'mongoose';

const CONNECTION_TIMEOUT = 10000;
const configService = new ConfigService();
console.log(configService.get<string>('DB_CONNECTION_STRING')); // Ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng

@Module({
  imports: [
    MongooseModule.forRootAsync({ 
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (
        configService: ConfigService,
      ): Promise<MongooseModuleOptions> => {
        const uri = configService.get<string>('mongodb://localhost:27017/kiotviet');
        console.log(uri);
        console.log('üåê ƒêang k·∫øt n·ªëi t·ªõi MongoDB...');

        return {
          uri,
          serverSelectionTimeoutMS: CONNECTION_TIMEOUT,
          connectionFactory: async (connection) => {
            try {
              await connection.asPromise();
              console.log('‚úÖ K·∫øt n·ªëi MongoDB th√†nh c√¥ng!');
            } catch (error) {
              console.error('‚ùå L·ªói k·∫øt n·ªëi MongoDB:', error.message);
              process.exit(1);
            }

            connection.on('disconnected', () => {
              console.warn('‚ö†Ô∏è M·∫•t k·∫øt n·ªëi v·ªõi MongoDB.');
            });

            return connection;
          },
        };
      },
    }),
  ],
})
export class DatabaseModule implements OnModuleInit {
  async onModuleInit() {
    console.log('‚è≥ ƒêang ch·ªù k·∫øt n·ªëi MongoDB ho√†n t·∫•t...');
    try {
      await mongoose.connection.asPromise();
      console.log('üöÄ MongoDB ƒë√£ s·∫µn s√†ng, ·ª©ng d·ª•ng NestJS b·∫Øt ƒë·∫ßu ho·∫°t ƒë·ªông!');
    } catch (error) {
      console.error('‚ùå K·∫øt n·ªëi MongoDB th·∫•t b·∫°i:', error.message);
      process.exit(1);
    }
  }
}

================
File: src/main.ts
================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.enableCors({
    origin: 'http://localhost:3000',
    methods: 'GET,POST,PUT,DELETE,PATCH',
    allowedHeaders: 'Content-Type, Authorization',
  });

  await app.listen(8080);
}
bootstrap();

================
File: src/modules/attendance/attendance.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Attendance, AttendanceSchema } from './schemas/attendance.schema';
import { AttendanceService } from './services/attendance.service';
import { AttendanceController } from './controllers/attendance.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Attendances', schema: AttendanceSchema }]),
  ],
  controllers: [AttendanceController],
  providers: [AttendanceService],
})
export class AttendanceModule {}

================
File: src/modules/attendance/controllers/attendance.controller.ts
================
import { Controller, Get, Post, Body, Param, Delete, Put } from '@nestjs/common';
import { AttendanceService } from '../services/attendance.service';
import { CreateAttendanceDto } from '../dtos/create-attendance.dto';
import { UpdateAttendanceDto } from '../dtos/update-attendance.dto';
import { Attendance } from '../schemas/attendance.schema';

@Controller('api/attendances')
export class AttendanceController {
  constructor(private readonly attendanceService: AttendanceService) { }

  @Post()
  async create(@Body() createAttendanceDto: CreateAttendanceDto): Promise<Attendance> {
    return this.attendanceService.create(createAttendanceDto);
  }

  @Get()
  async findAll(): Promise<Attendance[]> {
    return this.attendanceService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Attendance> {
    return this.attendanceService.findOne(id);
  }

  @Put(':id')
  async update(@Param('id') id: string, @Body() updateAttendanceDto: UpdateAttendanceDto): Promise<Attendance> {
    return this.attendanceService.update(id, updateAttendanceDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Attendance> {
    return this.attendanceService.remove(id);
  }
}

================
File: src/modules/attendance/dtos/create-attendance.dto.ts
================
export class CreateAttendanceDto {
  attendanceId: string;
  employeeId: string; // Chu·ªói v√¨ s·∫Ω ƒë∆∞·ª£c chuy·ªÉn th√†nh ObjectId trong schema
  date: Date;
  checkIn: Date;
  checkOut: Date;
  status: string;
}

================
File: src/modules/attendance/dtos/update-attendance.dto.ts
================
export class UpdateAttendanceDto {
  attendanceId?: string;
  employeeId?: string;
  date?: Date;
  checkIn?: Date;
  checkOut?: Date;
  status?: string;
}

================
File: src/modules/attendance/schemas/attendance.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Attendances' })
export class Attendance extends Document {
  @Prop({ unique: true, required: true })
  attendanceId: string  ;

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  employeeId: Types.ObjectId;

  @Prop()
  date: Date;

  @Prop()
  checkIn: Date;

  @Prop()
  checkOut: Date;

  @Prop({
    enum: ['ƒê√∫ng gi·ªù', 'ƒêi mu·ªôn', 'V·ªÅ s·ªõm', 'Ch∆∞a ch·∫•m c√¥ng', 'Ngh·ªâ l√†m'],
  })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const AttendanceSchema = SchemaFactory.createForClass(Attendance);

================
File: src/modules/attendance/services/attendance.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Attendance } from '../schemas/attendance.schema';
import { CreateAttendanceDto } from '../dtos/create-attendance.dto';
import { UpdateAttendanceDto } from '../dtos/update-attendance.dto';

@Injectable()
export class AttendanceService {
  constructor(@InjectModel('Attendances') private attendanceModel: Model<Attendance>) {}

  // Th√™m m·ªõi attendance
  async create(createAttendance: any): Promise<Attendance> {
    const lastUser = await this.attendanceModel.findOne().sort({ attendanceId: -1 }).exec();
    let newAttendanceId = 'ATT0001';
  
    if (lastUser && lastUser.attendanceId) {
      const lastNumber = parseInt(lastUser.attendanceId.replace('ATT', ''), 10);
      const nextNumber = lastNumber + 1;
      newAttendanceId = `ATT${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdAttendance = new this.attendanceModel({
      ...createAttendance,
      attendanceId: newAttendanceId
    });
  
    return createdAttendance.save();
  }

  // L·∫•y t·∫•t c·∫£ attendance
  async findAll(): Promise<Attendance[]> {
    return this.attendanceModel.find().exec();
  }

  // L·∫•y m·ªôt attendance theo ID
  async findOne(id: string): Promise<Attendance> {
    const attendance = await this.attendanceModel.findById(id).exec();
    if (!attendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return attendance;
  }

  // C·∫≠p nh·∫≠t attendance
  async update(id: string, updateAttendanceDto: UpdateAttendanceDto): Promise<Attendance> {
    const updatedAttendance = await this.attendanceModel.findByIdAndUpdate(id, updateAttendanceDto, { new: true }).exec();
    if (!updatedAttendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return updatedAttendance;
  }

  // X√≥a attendance
  async remove(id: string): Promise<Attendance> {
    const deletedAttendance = await this.attendanceModel.findByIdAndDelete(id).exec();
    if (!deletedAttendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return deletedAttendance;
  }
}

================
File: src/modules/auth/controllers/user.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UserService } from '../services/user.service';
import { User } from '../schemas/user.schema';

@Controller('api/auth')
export class UserController {
  constructor(private readonly userService: UserService) { }

  @Post()
  create(@Body() createUserDto: any) {
    return this.userService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.userService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: any) {
    return this.userService.update(id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }

  @Post('register')
  register(@Body() registerDto: any) {
    return this.userService.register(registerDto);
  }

  @Post('login')
  login(@Body() loginDto: any) {
    return this.userService.login(loginDto.email, loginDto.password);
  }
}

================
File: src/modules/auth/guard/auth.guard.ts
================
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers.authorization;

    if (!authHeader) {
      throw new UnauthorizedException('Missing token');
    }

    try {
      const token = authHeader.split(' ')[1];
      const decoded = jwt.verify(token, 'your-secret-key') as { isAdmin: boolean };

      if (!decoded.isAdmin) {
        throw new ForbiddenException('Admin access required');
      }

      return true;
    } catch (error) {
      throw new UnauthorizedException('Invalid token');
    }
  }
}

================
File: src/modules/auth/schemas/user.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { v4 as uuidv4 } from 'uuid';
@Schema({ collection: 'Users' })
export class User extends Document {
  @Prop({ required: true, unique: true })
  userId: string;

  @Prop({ required: true })
  username: string;

  @Prop({ required: true })
  password: string;

  @Prop()
  fullName: string;

  @Prop({ enum: ['admin', 'user', 'employee'], default: 'employee' })
  role: string;
  

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branch: Types.ObjectId;

  @Prop({ match: /^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$/ })
  email: string;
  

  @Prop()
  phone: string;

  @Prop({ default: false })
  isAdmin: boolean;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const UserSchema = SchemaFactory.createForClass(User);

================
File: src/modules/auth/services/user.service.ts
================
import { Injectable, ConflictException, UnauthorizedException, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as bcrypt from 'bcryptjs';
import * as jwt from 'jsonwebtoken';
import { User } from '../schemas/user.schema';

@Injectable()
export class UserService {
  constructor(
    @InjectModel('Users') private userModel: Model<User>,
  ) { }

  async create(createUserDto: any): Promise<User> {
    const existingUser = await this.userModel.findOne({ email: createUserDto.email });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }
  
    // L·∫•y userId l·ªõn nh·∫•t t·ª´ database
    const lastUser = await this.userModel.findOne().sort({ userId: -1 }).exec();
    let newUserId = 'USR0001'; // Gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥ user n√†o
  
    if (lastUser && lastUser.userId) {
      const lastNumber = parseInt(lastUser.userId.replace('USR', ''), 10);
      const nextNumber = lastNumber + 1;
      newUserId = `USR${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    const createdUser = new this.userModel({
      ...createUserDto,
      userId: newUserId,
      password: hashedPassword,
    });
  
    return createdUser.save();
  }
  

  async findAll(): Promise<User[]> {
    return this.userModel.find().exec();
  }

  async findOne(id: string): Promise<User> {
    const user = await this.userModel.findById(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async update(id: string, updateUserDto: any): Promise<User> {
    if (updateUserDto.password) {
      updateUserDto.password = await bcrypt.hash(updateUserDto.password, 10);
    }

    const user = await this.userModel
      .findByIdAndUpdate(id, updateUserDto, { new: true })
      .exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async remove(id: string): Promise<User> {
    const user = await this.userModel.findByIdAndDelete(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async login(email: string, password: string) {
    const user = await this.userModel.findOne({ email });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const token = jwt.sign(
      {
        userId: user._id,
        role: user.role
      },
      'your-secret-key',
      { expiresIn: '1h' }
    );

    return { token, user };
  }

  async register(registerDto: any) {
    const existingUser = await this.userModel.findOne({ email: registerDto.email });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // L·∫•y userId l·ªõn nh·∫•t t·ª´ database
    const lastUser = await this.userModel.findOne().sort({ userId: -1 }).exec();
    let newUserId = 'USR0001'; // Gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a c√≥ user n√†o
  
    if (lastUser && lastUser.userId) {
      const lastNumber = parseInt(lastUser.userId.replace('USR', ''), 10);
      const nextNumber = lastNumber + 1;
      newUserId = `USR${nextNumber.toString().padStart(4, '0')}`;
    }

    const hashedPassword = await bcrypt.hash(registerDto.password, 10);
    const user = new this.userModel({
      ...registerDto,
      userId: newUserId,
      password: hashedPassword,
    });
    await user.save();
    return { message: 'User registered successfully' };
  }
}

================
File: src/modules/auth/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from './schemas/user.schema';
import { Branch, BranchSchema } from '../branch/schemas/branch.schema';
import { UserService } from './services/user.service';
import { UserController } from './controllers/user.controller';

@Module({
  imports: [
    // MongooseModule.forFeature([{ name: 'Users', schema: UserSchema }]),
    MongooseModule.forFeature([{ name: 'Users', schema: UserSchema }]),
    MongooseModule.forFeature([{ name: 'Branches', schema: BranchSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService]
})
export class UserModule { }

================
File: src/modules/branch/branch.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BranchController } from './controllers/branch.controller';
import { BranchService } from './services/branch.service';
import { Branch, BranchSchema } from './schemas/branch.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Branches', schema: BranchSchema }])
  ],
  controllers: [BranchController],
  providers: [BranchService],
  exports: [BranchService]
})
export class BranchModule { }

================
File: src/modules/branch/controllers/branch.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BranchService } from '../services/branch.service';
import { Branch } from '../schemas/branch.schema';
import { CreateBranchDto } from '../dtos/create-branch.dto';

@Controller('api/branches')
export class BranchController {
  constructor(private readonly branchService: BranchService) { }

  @Post()
  async create(@Body() createBranchDto: CreateBranchDto): Promise<Branch> {
    return this.branchService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.branchService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.branchService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBranchDto: any) {
    return this.branchService.update(id, updateBranchDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.branchService.remove(id);
  }
}

================
File: src/modules/branch/dtos/create-branch.dto.ts
================
export class CreateBranchDto {
  attendanceId: string;
  employeeId: string; // Chu·ªói v√¨ s·∫Ω ƒë∆∞·ª£c chuy·ªÉn th√†nh ObjectId trong schema
  date: Date;
  checkIn: Date;
  checkOut: Date;
  status: string;
}

================
File: src/modules/branch/schemas/branch.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Branches' })
export class Branch extends Document {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  location: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop({ default: Date.now })
  updateAt: Date;
}
export const BranchSchema = SchemaFactory.createForClass(Branch);

================
File: src/modules/branch/services/branch.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Branch } from '../schemas/branch.schema';

@Injectable()
export class BranchService {
  constructor(
    @InjectModel('Branches') private branchModel: Model<Branch>,
  ) { }

  async create(createBranchDto: any): Promise<Branch> {
    const createdBranch = new this.branchModel(createBranchDto);
    return createdBranch.save();
  }

  async findAll(): Promise<Branch[]> {
    return this.branchModel.find().exec();
  }

  async findOne(id: string): Promise<Branch> {
    const branch = await this.branchModel.findById(id).exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }

  async update(id: string, updateBranchDto: any): Promise<Branch> {
    const branch = await this.branchModel
      .findByIdAndUpdate(id, updateBranchDto, { new: true })
      .exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }

  async remove(id: string): Promise<Branch> {
    const branch = await this.branchModel.findByIdAndDelete(id).exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }
}

================
File: src/modules/brand/brand.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BrandController } from './controllers/brand.controller';
import { BrandService } from './services/brand.service';
import { Brand, BrandSchema } from './schemas/brand.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Brands', schema: BrandSchema }])
  ],
  controllers: [BrandController],
  providers: [BrandService],
  exports: [BrandService]
})
export class BrandModule { }

================
File: src/modules/brand/controllers/brand.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BrandService } from '../services/brand.service';
import { Brand } from '../schemas/brand.schema';

@Controller('api/brands')
export class BrandController {
  constructor(private readonly brandService: BrandService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<Brand> {
    return this.brandService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.brandService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.brandService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.brandService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.brandService.remove(id);
  }
}

================
File: src/modules/brand/schemas/brand.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Brands', timestamps: true })
export class Brand extends Document {
  @Prop({ unique: true, required: true })
  brandId: string;

  @Prop({ required: true })
  name: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const BrandSchema = SchemaFactory.createForClass(Brand);

================
File: src/modules/brand/services/brand.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Brand } from '../schemas/brand.schema';

@Injectable()
export class BrandService {
  constructor(
    @InjectModel('Brands') private brandModel: Model<Brand>,
  ) { }

  async create(createBrandDto: any): Promise<Brand> {
    const lastBrand = await this.brandModel.findOne().sort({ brandId: -1 }).exec();
    let newBrandId = 'BR0001';
  
    if (lastBrand && lastBrand.brandId) {
      const lastNumber = parseInt(lastBrand.brandId.replace('BR', ''), 10);
      const nextNumber = lastNumber + 1;
      newBrandId = `BR${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdBrand = new this.brandModel({
      ...createBrandDto,
      brandId: newBrandId
    });
  
    return createdBrand.save();
  }

  async findAll(): Promise<Brand[]> {
    return this.brandModel.find().exec();
  }

  async findOne(id: string): Promise<Brand> {
    const brand = await this.brandModel.findById(id).exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }

  async update(id: string, updateBrandDto: any): Promise<Brand> {
    const brand = await this.brandModel
      .findByIdAndUpdate(id, updateBrandDto, { new: true })
      .exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }

  async remove(id: string): Promise<Brand> {
    const brand = await this.brandModel.findByIdAndDelete(id).exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }
}

================
File: src/modules/carrier-group/carrier-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CarrierGroup, CarrierGroupSchema } from './schemas/carrier-group.schema';
import { CarrierGroupController } from './controllers/carrier-group.controller';
import { CarrierGroupService } from './services/carrier-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CarrierGroups', schema: CarrierGroupSchema }])
  ],
  controllers: [CarrierGroupController],
  providers: [CarrierGroupService],
  exports: [CarrierGroupService]
})
export class CarrierGroupModule { }

================
File: src/modules/carrier-group/controllers/carrier-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CarrierGroupService } from '../services/carrier-group.service';
import { CarrierGroup } from '../schemas/carrier-group.schema';

@Controller('api/carriers-groups')
export class CarrierGroupController {
  constructor(private readonly carriersService: CarrierGroupService) { }

  @Post()
  async create(@Body() createCarrierGroupDto: any): Promise<CarrierGroup> {
    return this.carriersService.create(createCarrierGroupDto);
  }

  @Get()
  findAll() {
    return this.carriersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.carriersService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCarrierGroupDto: any) {
    return this.carriersService.update(id, updateCarrierGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.carriersService.remove(id);
  }
}

================
File: src/modules/carrier-group/schemas/carrier-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'CarrierGroups' })
export class CarrierGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const CarrierGroupSchema = SchemaFactory.createForClass(CarrierGroup);

================
File: src/modules/carrier-group/services/carrier-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CarrierGroup } from '../schemas/carrier-group.schema';

@Injectable()
export class CarrierGroupService {
  constructor(
    @InjectModel('CarrierGroups') private carrierGroupModel: Model<CarrierGroup>,
  ) { }

  async create(createCarrierGroupDto: any): Promise<CarrierGroup> {
    const lastCarrierGroup = await this.carrierGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newCarrierGroupId = 'CG0001';
  
    if (lastCarrierGroup && lastCarrierGroup.groupId) {
      const lastNumber = parseInt(lastCarrierGroup.groupId.replace('CG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCarrierGroupId = `CG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCarrierGroup = new this.carrierGroupModel({
      ...createCarrierGroupDto,
      carrierGroupId: newCarrierGroupId
    });
  
    return createdCarrierGroup.save();
  }

  async findAll(): Promise<CarrierGroup[]> {
    return this.carrierGroupModel.find().exec();
  }

  async findOne(id: string): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel.findById(id).exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }

  async update(id: string, updateCarrierGroupDto: any): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel
      .findByIdAndUpdate(id, updateCarrierGroupDto, { new: true })
      .exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }

  async remove(id: string): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel.findByIdAndDelete(id).exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }
}

================
File: src/modules/carrier/carrier.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Carrier, CarrierSchema } from './schemas/carrier.schema';
import { CarrierService } from './services/carrier.service';
import { CarrierController } from './controllers/carrier.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Carriers', schema: CarrierSchema }])
  ],
  controllers: [CarrierController],
  providers: [CarrierService],
  exports: [CarrierService]
})
export class CarrierModule { }

================
File: src/modules/carrier/controllers/carrier.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CarrierService } from '../services/carrier.service';

@Controller('api/carriers')
export class CarrierController {
  constructor(private readonly carrierService: CarrierService) { }
  @Post()
  create(@Body() createBrandDto: any) {
    return this.carrierService.create(createBrandDto);
  }
  @Get()
  findAll() {
    return this.carrierService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.carrierService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.carrierService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.carrierService.remove(id);
  }
}

================
File: src/modules/carrier/schemas/carrier.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Carriers' })
export class Carrier extends Document {
  @Prop({ unique: true, required: true })
  carrierId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  phone: string;

  @Prop()
  email: string;

  @Prop()
  address: string;

  @Prop({ type: Types.ObjectId, ref: 'CarrierGroups' })
  group: Types.ObjectId;

  @Prop({ default: 0 })
  totalOrders: number;

  @Prop({ default: 0 })
  totalFees: number;

  @Prop({ enum: ['ƒêang ho·∫°t ƒë·ªông', 'Ng·ª´ng ho·∫°t ƒë·ªông'], default: 'ƒêang ho·∫°t ƒë·ªông' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop({ default: Date.now })
  updateAt: Date;
}

export const CarrierSchema = SchemaFactory.createForClass(Carrier);

================
File: src/modules/carrier/services/carrier.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Carrier } from '../schemas/carrier.schema';

@Injectable()
export class CarrierService {
  constructor(@InjectModel('Carriers') private CarrierModel: Model<Carrier>) {}

  async create(createCarrierDto: any): Promise<Carrier> {
    const lastCarrier = await this.CarrierModel.findOne().sort({ carrierId: -1 }).exec();
    let newCarrierId = 'CG0001';
  
    if (lastCarrier && lastCarrier.carrierId) {
      const lastNumber = parseInt(lastCarrier.carrierId.replace('CG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCarrierId = `CG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCarrier = new this.CarrierModel({
      ...createCarrierDto,
      carrierId: newCarrierId
    });
  
    return createdCarrier.save();
  }
  async findAll(): Promise<Carrier[]> {
    return this.CarrierModel.find().exec();
  }

  async findOne(id: string): Promise<Carrier> {
    const brand = await this.CarrierModel.findById(id).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }

  async update(id: string, updateBrandDto: any): Promise<Carrier> {
    const brand = await this.CarrierModel.findByIdAndUpdate(
      id,
      updateBrandDto,
      { new: true },
    ).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }

  async remove(id: string): Promise<Carrier> {
    const brand = await this.CarrierModel.findByIdAndDelete(id).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }
}

================
File: src/modules/cash-book/cash-book.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CashBookController } from './controllers/cash-book.controller';
import { CashBookService } from './services/cash-book.service';
import { CashBook, CashBookSchema } from './schemas/cash-book.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CashBooks', schema: CashBookSchema }])
  ],
  controllers: [CashBookController],
  providers: [CashBookService],
  exports: [CashBookService]
})
export class CashBookModule { }

================
File: src/modules/cash-book/controllers/cash-book.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { CashBookService } from '../services/cash-book.service';
import { CashBook } from '../schemas/cash-book.schema';

@Controller('api/cash-books')
export class CashBookController {
  constructor(private readonly cashBookService: CashBookService) { }

  @Post()
  async create(@Body() createCashBookDto: any): Promise<CashBook> {
    return this.cashBookService.create(createCashBookDto);
  }

  @Get()
  async findAll(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('type') type?: string
  ): Promise<CashBook[]> {
    return this.cashBookService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<CashBook> {
    return this.cashBookService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateCashBookDto: any,
  ): Promise<CashBook> {
    return this.cashBookService.update(id, updateCashBookDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<CashBook> {
    return this.cashBookService.remove(id);
  }

  @Put(':id/approve')
  async approve(@Param('id') id: string): Promise<CashBook> {
    const updateDto = { status: 'approved' };
    return this.cashBookService.update(id, updateDto);
  }

  @Put(':id/reject')
  async reject(@Param('id') id: string): Promise<CashBook> {
    const updateDto = { status: 'rejected' };
    return this.cashBookService.update(id, updateDto);
  }
}

================
File: src/modules/cash-book/schemas/cash-book.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'CashBooks' })
export class CashBook extends Document {
  @Prop({ unique: true, required: true })
  cashBookId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ enum: ['Thu', 'Chi'], required: true })
  type: string;

  @Prop({
    enum: [
      'Thu t·ª´ b√°n h√†ng',
      'Thu t·ª´ kh√°c',
      'Chi mua h√†ng',
      'Chi l∆∞∆°ng',
      'Chi v·∫≠n chuy·ªÉn',
      'Chi marketing',
      'Chi kh√°c',
    ],
    required: true,
  })
  category: string;

  @Prop({ required: true })
  amount: number;

  @Prop({
    enum: ['Ti·ªÅn m·∫∑t', 'Chuy·ªÉn kho·∫£n', 'Th·∫ª t√≠n d·ª•ng', 'V√≠ ƒëi·ªán t·ª≠'],
    required: true,
  })
  paymentMethod: string;

  @Prop({
    enum: ['ƒê∆°n h√†ng', 'H√≥a ƒë∆°n', 'Phi·∫øu nh·∫≠p', 'Phi·∫øu xu·∫•t', 'Kh√°c'],
    required: true,
  })
  reference: string;

  @Prop({ type: Types.ObjectId })
  referenceId: Types.ObjectId;

  @Prop()
  description: string;

  @Prop({ required: true, default: Date.now })
  date: Date;

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId;

  @Prop([String])
  attachments: string[];

  @Prop({ enum: ['ƒê√£ x√°c nh·∫≠n', 'Ch·ªù x√°c nh·∫≠n', 'ƒê√£ h·ªßy'], default: 'Ch·ªù x√°c nh·∫≠n' })
  status: string;

  @Prop()
  notes: string;
}

export const CashBookSchema = SchemaFactory.createForClass(CashBook);

CashBookSchema.index({ storeId: 1 });
CashBookSchema.index({ type: 1 });
CashBookSchema.index({ category: 1 });
CashBookSchema.index({ date: 1 });
CashBookSchema.index({ referenceId: 1 });

================
File: src/modules/cash-book/services/cash-book.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CashBook } from '../schemas/cash-book.schema';

@Injectable()
export class CashBookService {
  constructor(
    @InjectModel('CashBooks') private cashBookModel: Model<CashBook>,
  ) { }

  async create(createCashBookDto: any): Promise<CashBook> {
    const lastCashBook = await this.cashBookModel.findOne().sort({ cashBookId: -1 }).exec();
    let newCashBookId = 'CB0001';
  
    if (lastCashBook && lastCashBook.cashBookId) {
      const lastNumber = parseInt(lastCashBook.cashBookId.replace('CB', ''), 10);
      const nextNumber = lastNumber + 1;
      newCashBookId = `CB${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCashBook = new this.cashBookModel({
      ...createCashBookDto,
      cashBookId: newCashBookId
    });
  
    return createdCashBook.save();
  }

  async findAll(): Promise<CashBook[]> {
    return this.cashBookModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
  }

  async findOne(id: string): Promise<CashBook> {
    const cashBook = await this.cashBookModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }

  async update(id: string, updateCashBookDto: any): Promise<CashBook> {
    const cashBook = await this.cashBookModel
      .findByIdAndUpdate(id, updateCashBookDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }

  async remove(id: string): Promise<CashBook> {
    const cashBook = await this.cashBookModel.findByIdAndDelete(id).exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }
}

================
File: src/modules/category/categories.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CategoriesController } from './controllers/categories.controller';
import { CategoriesService } from './services/categories.service';
import { Categories, CategoriesSchema } from './schemas/categories.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Categories', schema: CategoriesSchema }])
  ],
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService]
})
export class CategoriesModule { }

================
File: src/modules/category/controllers/categories.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CategoriesService } from '../services/categories.service';
import { Categories } from '../schemas/categories.schema';

@Controller('api/categories')
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) { }

  @Post()
  create(@Body() createCategoriesDto: any) {
    return this.categoriesService.create(createCategoriesDto);
  }

  @Get()
  findAll() {
    return this.categoriesService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.categoriesService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCategoriesDto: any) {
    return this.categoriesService.update(id, updateCategoriesDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.categoriesService.remove(id);
  }
}

================
File: src/modules/category/schemas/categories.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Categories' })
export class Categories extends Document {
  @Prop({ unique: true, required: true })
  categoryId: string;

  @Prop({ required: true })
  name: string;

  @Prop({ type: Types.ObjectId, ref: 'Categories' })
  parentCategory: Types.ObjectId;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const CategoriesSchema = SchemaFactory.createForClass(Categories);

================
File: src/modules/category/services/categories.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Categories } from '../schemas/categories.schema';

@Injectable()
export class CategoriesService {
  constructor(
    @InjectModel('Categories') private categoriesModel: Model<Categories>,
  ) { }

  async create(createCategoriesDto: any): Promise<Categories> {
    const lastCategories = await this.categoriesModel.findOne().sort({ categoryId: -1 }).exec();
    let newCategoryId = 'CT0001';
  
    if (lastCategories && lastCategories.categoryId) {
      const lastNumber = parseInt(lastCategories.categoryId.replace('CT', ''), 10);
      const nextNumber = lastNumber + 1;
      newCategoryId = `CT${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCategories = new this.categoriesModel({
      ...createCategoriesDto,
      categoryId: newCategoryId
    });
  
    return createdCategories.save();
  }

  async findAll(): Promise<Categories[]> {
    return this.categoriesModel.find().populate('parentCategory').exec();
  }

  async findOne(id: string): Promise<Categories> {
    const category = await this.categoriesModel.findById(id).populate('parentCategory').exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async update(id: string, updateCategoriesDto: any): Promise<Categories> {
    const category = await this.categoriesModel
      .findByIdAndUpdate(id, updateCategoriesDto, { new: true })
      .populate('parentCategory')
      .exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async remove(id: string): Promise<Categories> {
    const category = await this.categoriesModel.findByIdAndDelete(id).exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }
}

================
File: src/modules/commission-setting/commission-setting.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CommissionSetting, CommissionSettingSchema } from './schemas/commission-setting.schema';
import { CommissionSettingController } from './controllers/commission-setting.controller';
import { CommissionSettingService } from './services/commission-setting.service';


@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CommissionSettings', schema: CommissionSettingSchema }])
  ],
  controllers: [CommissionSettingController],
  providers: [CommissionSettingService],
  exports: [CommissionSettingService]
})
export class CommissionSettingModule { }

================
File: src/modules/commission-setting/controllers/commission-setting.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CommissionSettingService } from '../services/commission-setting.service';
import { CommissionSetting } from '../schemas/commission-setting.schema';

@Controller('api/commission-settings')
export class CommissionSettingController {
  constructor(private readonly commissionSettingService: CommissionSettingService) { }

  @Post()
  async create(@Body() createCashBookDto: any): Promise<CommissionSetting> {
    return this.commissionSettingService.create(createCashBookDto);
  }

  @Get()
  findAll() {
    return this.commissionSettingService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.commissionSettingService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.commissionSettingService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.commissionSettingService.remove(id);
  }
}

================
File: src/modules/commission-setting/schemas/commission-setting.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'CommissionDetails' })
export class CommissionDetail {
  @Prop({ type: Types.ObjectId, ref: 'Products' })
  productId: Types.ObjectId;

  @Prop()
  rate: number;
}

export const CommissionDetailSchema = SchemaFactory.createForClass(CommissionDetail);

@Schema({ collection: 'CommissionSettings' })
export class CommissionSetting extends Document {
  @Prop({ unique: true, required: true })
  commissionId: string;

  @Prop({ required: true })
  name: string;

  @Prop({ enum: ['To√†n h·ªá th·ªëng', 'Chi nh√°nh'] })
  scope: string;

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branchId: Types.ObjectId;

  @Prop({ enum: ['√Åp d·ª•ng', 'Ng·ª´ng √°p d·ª•ng'], default: '√Åp d·ª•ng' })
  status: string;

  @Prop({ type: [CommissionDetailSchema] })
  details: CommissionDetail[];

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const CommissionSettingSchema = SchemaFactory.createForClass(CommissionSetting);

================
File: src/modules/commission-setting/services/commission-setting.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { CommissionSetting } from '../schemas/commission-setting.schema';

@Injectable()
export class CommissionSettingService {
  constructor(
    @InjectModel('CommissionSettings')
    private commissionSettingModel: Model<CommissionSetting>,
  ) {}

  async create(createCommissionSettingDto: any): Promise<CommissionSetting> {
    // Convert string IDs to ObjectIds in details array
    if (createCommissionSettingDto.details) {
      createCommissionSettingDto.details =
        createCommissionSettingDto.details.map((detail) => ({
          ...detail,
          productId: new Types.ObjectId(detail.productId),
        }));
    }

    const lastCommissionSetting = await this.commissionSettingModel
      .findOne()
      .sort({ commissionId: -1 })
      .exec();
    let newCommissionSettingId = 'CMS0001';

    if (lastCommissionSetting && lastCommissionSetting.commissionId) {
      const lastNumber = parseInt(
        lastCommissionSetting.commissionId.replace('CMS', ''),
        10,
      );
      const nextNumber = lastNumber + 1;
      newCommissionSettingId = `CS${nextNumber.toString().padStart(4, '0')}`;
    }

    const createdCommissionSetting = new this.commissionSettingModel({
      ...createCommissionSettingDto,
      commissionId: newCommissionSettingId,
    });

    return createdCommissionSetting.save();
  }

  async findAll(): Promise<CommissionSetting[]> {
    return this.commissionSettingModel.find().exec();
  }

  async findOne(id: string): Promise<CommissionSetting> {
    const commissionSetting = await this.commissionSettingModel
      .findById(id)
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }

  async update(
    id: string,
    updateCommissionSettingDto: any,
  ): Promise<CommissionSetting> {
    // Convert string IDs to ObjectIds in details array if present
    if (updateCommissionSettingDto.details) {
      updateCommissionSettingDto.details =
        updateCommissionSettingDto.details.map((detail) => ({
          ...detail,
          productId: new Types.ObjectId(detail.productId),
        }));
    }

    const commissionSetting = await this.commissionSettingModel
      .findByIdAndUpdate(id, updateCommissionSettingDto, { new: true })
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }

  async remove(id: string): Promise<CommissionSetting> {
    const commissionSetting = await this.commissionSettingModel
      .findByIdAndDelete(id)
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }
}

================
File: src/modules/customer/controllers/customer.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerService } from '../services/customer.service';
import { Customer } from '../schemas/customer.schema';

@Controller('api/customers')
export class CustomerController {
  constructor(private readonly customerService: CustomerService) { }

  @Post()
  create(@Body() createCustomerDto: any) {
    return this.customerService.create(createCustomerDto);
  }

  @Get()
  findAll() {
    return this.customerService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerDto: any) {
    return this.customerService.update(id, updateCustomerDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerService.remove(id);
  }
}

================
File: src/modules/customer/customer.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerController } from './controllers/customer.controller';
import { CustomerService } from './services/customer.service';
import { Customer, CustomerSchema } from './schemas/customer.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Customers', schema: CustomerSchema }])
  ],
  controllers: [CustomerController],
  providers: [CustomerService],
  exports: [CustomerService]
})
export class CustomerModule { }

================
File: src/modules/customer/schemas/customer.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Customers' })
export class Customer extends Document {
  @Prop({ unique: true, required: true })
  customerId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  phone: string;

  @Prop()
  email: string;

  @Prop()
  address: string;

  @Prop({ enum: ['C√° nh√¢n', 'C√¥ng ty'] })
  customerType: string;

  @Prop()
  taxCode: string;

  @Prop()
  idCard: string;

  @Prop({ type: Types.ObjectId })
  group: Types.ObjectId;

  @Prop({ default: 0 })
  debt: number;

  @Prop({ default: 0 })
  totalSales: number;

  @Prop({ enum: ['ƒêang ho·∫°t ƒë·ªông', 'Ng·ª´ng ho·∫°t ƒë·ªông'], default: 'ƒêang ho·∫°t ƒë·ªông' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const CustomerSchema = SchemaFactory.createForClass(Customer);

================
File: src/modules/customer/services/customer.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Customer } from '../schemas/customer.schema';

@Injectable()
export class CustomerService {
  constructor(
    @InjectModel('Customers') private customerModel: Model<Customer>,
  ) { }

  async create(createCustomerDto: any): Promise<Customer> {
    const lastCustomer = await this.customerModel.findOne().sort({ customerId: -1 }).exec();
    let newCustomerId = 'KH0001';
  
    if (lastCustomer && lastCustomer.customerId) {
      const lastNumber = parseInt(lastCustomer.customerId.replace('KH', ''), 10);
      const nextNumber = lastNumber + 1;
      newCustomerId = `KH${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCustomer = new this.customerModel({
      ...createCustomerDto,
      customerId: newCustomerId
    });
  
    return createdCustomer.save();
  }

  async findAll(): Promise<Customer[]> {
    return this.customerModel.find().populate('group').exec();
  }

  async findOne(id: string): Promise<Customer> {
    const customer = await this.customerModel.findById(id).populate('group').exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }

  async update(id: string, updateCustomerDto: any): Promise<Customer> {
    const customer = await this.customerModel
      .findByIdAndUpdate(id, updateCustomerDto, { new: true })
      .populate('group')
      .exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }

  async remove(id: string): Promise<Customer> {
    const customer = await this.customerModel.findByIdAndDelete(id).exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }
}

================
File: src/modules/department/controllers/department.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { DepartmentService } from '../services/department.service';
import { Department } from '../schemas/department.schema';

@Controller('api/departments')
export class DepartmentController {
  constructor(private readonly departmentService: DepartmentService) { }

  @Post()
  async create(@Body() createDepartmentDto: any): Promise<Department> {
    return this.departmentService.create(createDepartmentDto);
  }

  @Get()
  findAll() {
    return this.departmentService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.departmentService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.departmentService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.departmentService.remove(id);
  }
}

================
File: src/modules/department/department.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Department, DepartmentSchema } from './schemas/department.schema';
import { DepartmentController } from './controllers/department.controller';
import { DepartmentService } from './services/department.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Departments', schema: DepartmentSchema }])
  ],
  controllers: [DepartmentController],
  providers: [DepartmentService],
  exports: [DepartmentService]
})
export class DepartmentModule { }

================
File: src/modules/department/schemas/department.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Departments' })
export class Department extends Document {
  @Prop({ unique: true, required: true })
  departmentId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ enum: ['Ho·∫°t ƒë·ªông', 'Ng·ª´ng ho·∫°t ƒë·ªông'], default: 'Ho·∫°t ƒë·ªông' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const DepartmentSchema = SchemaFactory.createForClass(Department);

================
File: src/modules/department/services/department.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Department } from '../schemas/department.schema';

@Injectable()
export class DepartmentService {
  constructor(
    @InjectModel('Departments') private departmentModel: Model<Department>,
  ) { }

  async create(createDepartmentDto: any): Promise<Department> {
    const lastDepartment = await this.departmentModel.findOne().sort({ departmentId: -1 }).exec();
    let newDepartmentId = 'DV0001';
  
    if (lastDepartment && lastDepartment.departmentId) {
      const lastNumber = parseInt(lastDepartment.departmentId.replace('DV', ''), 10);
      const nextNumber = lastNumber + 1;
      newDepartmentId = `DV${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdDepartment = new this.departmentModel({
      ...createDepartmentDto,
      departmentId: newDepartmentId
    });
  
    return createdDepartment.save();
  }

  async findAll(): Promise<Department[]> {
    return this.departmentModel.find().exec();
  }

  async findOne(id: string): Promise<Department> {
    const department = await this.departmentModel.findById(id).exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }

  async update(id: string, updateDepartmentDto: any): Promise<Department> {
    const department = await this.departmentModel
      .findByIdAndUpdate(id, updateDepartmentDto, { new: true })
      .exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }

  async remove(id: string): Promise<Department> {
    const department = await this.departmentModel.findByIdAndDelete(id).exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }
}

================
File: src/modules/employee/controllers/employee.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { EmployeeService } from '../services/employee.service';
import { Employee } from '../schemas/employee.schema';

@Controller('api/employees')
export class EmployeeController {
  constructor(private readonly employeeService: EmployeeService) { }

  @Post()
  create(@Body() createEmployeeDto: any) {
    return this.employeeService.create(createEmployeeDto);
  }

  @Get()
  findAll() {
    return this.employeeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.employeeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateEmployeeDto: any) {
    return this.employeeService.update(id, updateEmployeeDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.employeeService.remove(id);
  }
}

================
File: src/modules/employee/employee.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { EmployeeController } from './controllers/employee.controller';
import { EmployeeService } from './services/employee.service';
import { Employee, EmployeeSchema } from './schemas/employee.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Employees', schema: EmployeeSchema }
    ]),
  ],
  controllers: [EmployeeController],
  providers: [EmployeeService],
  exports: [EmployeeService],
})
export class EmployeeModule { }

================
File: src/modules/employee/schemas/employee.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Bonuses' })
export class Bonus {
  @Prop({ enum: ['Doanh thu c√° nh√¢n', 'L·ª£i nhu·∫≠n chi nh√°nh', 'L·ª£i nhu·∫≠n g·ªôp'] })
  type: string;

  @Prop({ enum: ['T·ªïng doanh thu', 'B·∫≠c thang doanh thu', 'V∆∞·ª£t doanh thu'] })
  form: string;

  @Prop()
  value: number;
}

export const BonusSchema = SchemaFactory.createForClass(Bonus);

@Schema({ collection: 'Allowances' })
export class Allowance {
  @Prop()
  name: string;

  @Prop({ enum: ['Theo ng√†y', 'H√†ng th√°ng c·ªë ƒë·ªãnh', 'H√†ng th√°ng t√≠nh tr√™n ng√†y c√¥ng'] })
  type: string;

  @Prop()
  value: number;

  @Prop({ enum: ['VND', '%'] })
  valueType: string;
}

export const AllowanceSchema = SchemaFactory.createForClass(Allowance);

@Schema({ collection: 'Deductions' })
export class Deduction {
  @Prop()
  name: string;

  @Prop({ enum: ['ƒêi mu·ªôn', 'V·ªÅ s·ªõm', 'C·ªë ƒë·ªãnh'] })
  type: string;

  @Prop({ enum: ['Theo s·ªë l·∫ßn', 'Theo ph√∫t'] })
  condition: string;

  @Prop()
  value: number;
}

export const DeductionSchema = SchemaFactory.createForClass(Deduction);

@Schema({ timestamps: true, collection: 'Employees' })
export class Employee extends Document {
  @Prop({ unique: true, required: true })
  employeeId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  phone: string;

  @Prop()
  email: string;

  @Prop()
  address: string;

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branchSalary: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branchWork: Types.ObjectId;

  @Prop()
  startDate: Date;

  @Prop({ type: Types.ObjectId, ref: 'Positions' })
  position: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Departments' })
  department: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Users' })
  userAccount: Types.ObjectId;

  @Prop()
  idCard: string;

  @Prop()
  dob: Date;

  @Prop({ enum: ['Nam', 'N·ªØ', 'Kh√°c'] })
  gender: string;

  @Prop({ enum: ['Theo ca', 'Theo gi·ªù', 'Theo ng√†y c√¥ng', 'C·ªë ƒë·ªãnh'] })
  salaryType: string;

  @Prop({
    type: {
      shiftRate: Number,
      hourlyRate: Number,
      dailyRate: Number,
      fixedRate: Number,
    },
  })
  salaryDetails: {
    shiftRate: number;
    hourlyRate: number;
    dailyRate: number;
    fixedRate: number;
  };

  @Prop({ type: [BonusSchema] })
  bonus: Bonus[];

  @Prop()
  commission: number;

  @Prop({ type: Types.ObjectId, ref: 'CommissionSettings' })
  commissionTable: Types.ObjectId;

  @Prop({ type: [AllowanceSchema] })
  allowance: Allowance[];

  @Prop({ type: [DeductionSchema] })
  deduction: Deduction[];

  @Prop({ enum: ['ƒêang l√†m vi·ªác', 'ƒê√£ ngh·ªâ'], default: 'ƒêang l√†m vi·ªác' })
  status: string;
}

export const EmployeeSchema = SchemaFactory.createForClass(Employee);

================
File: src/modules/employee/services/employee.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Employee } from '../schemas/employee.schema';

@Injectable()
export class EmployeeService {
  constructor(
    @InjectModel('Employees') private employeeModel: Model<Employee>,
  ) { }

  async create(createEmployeeDto: any): Promise<Employee> {
    const lastEmployee = await this.employeeModel.findOne().sort({ employeeId: -1 }).exec();
    let newEmployeeId = 'NV0001';
  
    if (lastEmployee && lastEmployee.employeeId) {
      const lastNumber = parseInt(lastEmployee.employeeId.replace('NV', ''), 10);
      const nextNumber = lastNumber + 1;
      newEmployeeId = `NV${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdEmployee = new this.employeeModel({
      ...createEmployeeDto,
      employeeId: newEmployeeId
    });
  
    return createdEmployee.save();
  }

  async findAll(): Promise<Employee[]> {
    return this.employeeModel
      .find()
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
  }

  async findOne(id: string): Promise<Employee> {
    const employee = await this.employeeModel
      .findById(id)
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }

  async update(id: string, updateEmployeeDto: any): Promise<Employee> {
    const employee = await this.employeeModel
      .findByIdAndUpdate(id, updateEmployeeDto, { new: true })
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }

  async remove(id: string): Promise<Employee> {
    const employee = await this.employeeModel.findByIdAndDelete(id).exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }
}

================
File: src/modules/holiday/controllers/holiday.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { HolidayService } from '../services/holiday.service';
import { Holiday } from '../schemas/holiday.schema';

@Controller('api/holidays')
export class HolidayController {
  constructor(private readonly holidayService: HolidayService) { }

  @Post()
  async create(@Body() createHolidayDto: any): Promise<Holiday> {
    return this.holidayService.create(createHolidayDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<Holiday[]> {
    return this.holidayService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Holiday> {
    return this.holidayService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateHolidayDto: any,
  ): Promise<Holiday> {
    return this.holidayService.update(id, updateHolidayDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Holiday> {
    return this.holidayService.remove(id);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<Holiday[]> {
    return this.holidayService.findByStore(storeId);
  }

  @Get('date/:date')
  async findByDate(@Param('date') date: string): Promise<Holiday[]> {
    return this.holidayService.findByDate(date);
  }

  @Get('month/:year/:month')
  async findByMonth(
    @Param('year') year: number,
    @Param('month') month: number,
  ): Promise<Holiday[]> {
    return this.holidayService.findByMonth(year, month);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<Holiday> {
    return this.holidayService.updateStatus(id, status);
  }
}

================
File: src/modules/holiday/holiday.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Holiday, HolidaySchema } from './schemas/holiday.schema';
import { HolidayController } from './controllers/holiday.controller';
import { HolidayService } from './services/holiday.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Holidays', schema: HolidaySchema }])
  ],
  controllers: [HolidayController],
  providers: [HolidayService],
  exports: [HolidayService]
})
export class HolidayModule { }

================
File: src/modules/holiday/schemas/holiday.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'Holidays' })
export class Holiday extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ enum: ['Ng√†y l·ªÖ', 'Ng√†y ƒë·∫∑c bi·ªát', 'S·ª± ki·ªán c·ªßa c√¥ng ty'], required: true })
  type: string;

  @Prop({ required: true })
  startDate: Date;

  @Prop({ required: true })
  endDate: Date;

  @Prop()
  duration: number;

  @Prop()
  description: string;

  @Prop({ default: false })
  isRecurring: boolean;

  @Prop({
    type: {
      frequency: { type: String, enum: ['H√†ng nƒÉm', 'H√†ng th√°ng', 'H√†ng tu·∫ßn'] },
      interval: Number,
      endAfter: Date,
    },
  })
  recurringPattern: {
    frequency: string;
    interval: number;
    endAfter: Date;
  };

  @Prop({ enum: ['ƒêang ho·∫°t ƒë·ªông', 'Ng·ª´ng ho·∫°t ƒë·ªông'], default: 'ƒêang ho·∫°t ƒë·ªông' })
  status: string;
}

export const HolidaySchema = SchemaFactory.createForClass(Holiday);

HolidaySchema.index({ storeId: 1 });
HolidaySchema.index({ startDate: 1 });
HolidaySchema.index({ endDate: 1 });
HolidaySchema.index({ type: 1 });
HolidaySchema.index({ status: 1 });

================
File: src/modules/holiday/services/holiday.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Holiday } from '../schemas/holiday.schema';

@Injectable()
export class HolidayService {
  constructor(
    @InjectModel('Holidays')
    private holidayModel: Model<Holiday>,
  ) { }

  async create(createHolidayDto: any): Promise<Holiday> {
    const created = new this.holidayModel(createHolidayDto);
    return created.save();
  }

  async findAll(query: any = {}): Promise<Holiday[]> {
    return this.holidayModel.find(query).exec();
  }

  async findOne(id: string): Promise<Holiday> {
    const holiday = await this.holidayModel.findById(id).exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async update(id: string, updateHolidayDto: any): Promise<Holiday> {
    const holiday = await this.holidayModel
      .findByIdAndUpdate(id, updateHolidayDto, { new: true })
      .exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async remove(id: string): Promise<Holiday> {
    const holiday = await this.holidayModel.findByIdAndDelete(id).exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async findByStore(storeId: string): Promise<Holiday[]> {
    return this.holidayModel.find({ storeId }).exec();
  }

  async findByDate(date: string): Promise<Holiday[]> {
    const startDate = new Date(date);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(date);
    endDate.setHours(23, 59, 59, 999);

    return this.holidayModel.find({
      date: {
        $gte: startDate,
        $lte: endDate,
      },
    }).exec();
  }

  async findByMonth(year: number, month: number): Promise<Holiday[]> {
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0);

    return this.holidayModel.find({
      date: {
        $gte: startDate,
        $lte: endDate,
      },
    }).exec();
  }

  async updateStatus(id: string, status: string): Promise<Holiday> {
    const holiday = await this.holidayModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }
}

================
File: src/modules/invoice/controllers/invoice.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { InvoiceService } from '../services/invoice.service';
import { Invoice } from '../schemas/invoice.schema';

@Controller('api/invoices')
export class InvoiceController {
  constructor(private readonly invoiceService: InvoiceService) { }

  @Post()
  create(@Body() createInvoiceDto: any) {
    return this.invoiceService.create(createInvoiceDto);
  }

  @Get()
  findAll() {
    return this.invoiceService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.invoiceService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateInvoiceDto: any) {
    return this.invoiceService.update(id, updateInvoiceDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.invoiceService.remove(id);
  }
}

================
File: src/modules/invoice/invoice.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { InvoiceController } from './controllers/invoice.controller';
import { InvoiceService } from './services/invoice.service';
import { Invoice, InvoiceSchema } from './schemas/invoice.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Invoices', schema: InvoiceSchema }])
  ],
  controllers: [InvoiceController],
  providers: [InvoiceService],
  exports: [InvoiceService]
})
export class InvoiceModule { }

================
File: src/modules/invoice/schemas/invoice.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'InvoiceItems' })
export class InvoiceItem {
  @Prop({ type: Types.ObjectId, ref: 'Products', required: true })
  productId: Types.ObjectId;

  @Prop({ required: true })
  quantity: number;

  @Prop({ required: true })
  unitPrice: number;

  @Prop({ default: 0 })
  discount: number;

  @Prop({ required: true })
  total: number;
}

export const InvoiceItemSchema = SchemaFactory.createForClass(InvoiceItem);

@Schema({ timestamps: true, collection: 'Invoices' })
export class Invoice extends Document {
  @Prop({ unique: true, required: true })
  invoiceId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId;

  @Prop({ required: true })
  invoiceNumber: string;

  @Prop({ required: true, default: Date.now })
  invoiceDate: Date;

  @Prop()
  dueDate: Date;

  @Prop({ type: [InvoiceItemSchema] })
  items: InvoiceItem[];

  @Prop({ required: true })
  subtotal: number;

  @Prop({ default: 0 })
  tax: number;

  @Prop({ default: 0 })
  shipping: number;

  @Prop({ required: true })
  total: number;

  @Prop({
    enum: ['Ti·ªÅn m·∫∑t', 'Chuy·ªÉn kho·∫£n', 'Th·∫ª t√≠n d·ª•ng', 'V√≠ ƒëi·ªán t·ª≠'],
    required: true,
  })
  paymentMethod: string;

  @Prop({
    enum: [
      'Ch∆∞a thanh to√°n',
      'ƒê√£ thanh to√°n m·ªôt ph·∫ßn',
      'ƒê√£ thanh to√°n',
      'ƒê√£ h·ªßy',
    ],
    default: 'Ch∆∞a thanh to√°n',
  })
  paymentStatus: string;

  @Prop()
  notes: string;

  @Prop({ enum: ['Draft', 'Issued', 'Cancelled', 'Void'], default: 'Draft' })
  status: string;
}

export const InvoiceSchema = SchemaFactory.createForClass(Invoice);

InvoiceSchema.index({ storeId: 1 });
InvoiceSchema.index({ orderId: 1 });
InvoiceSchema.index({ customerId: 1 });
InvoiceSchema.index({ invoiceNumber: 1 });

================
File: src/modules/invoice/services/invoice.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Invoice } from '../schemas/invoice.schema';

@Injectable()
export class InvoiceService {
  constructor(
    @InjectModel('Invoices') private invoiceModel: Model<Invoice>,
  ) { }

  async create(createInvoiceDto: any): Promise<Invoice> {
    const lastInvoice = await this.invoiceModel.findOne().sort({ invoiceId: -1 }).exec();
    let newInvoiceId = 'HD0001';
  
    if (lastInvoice && lastInvoice.invoiceId) {
      const lastNumber = parseInt(lastInvoice.invoiceId.replace('HD', ''), 10);
      const nextNumber = lastNumber + 1;
      newInvoiceId = `HD${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdInvoice = new this.invoiceModel({
      ...createInvoiceDto,
      invoiceId: newInvoiceId
    });
  
    return createdInvoice.save();
  }

  async findAll(): Promise<Invoice[]> {
    return this.invoiceModel
      .find()
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
  }

  async findOne(id: string): Promise<Invoice> {
    const invoice = await this.invoiceModel
      .findById(id)
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }

  async update(id: string, updateInvoiceDto: any): Promise<Invoice> {
    const invoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateInvoiceDto, { new: true })
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }

  async remove(id: string): Promise<Invoice> {
    const invoice = await this.invoiceModel.findByIdAndDelete(id).exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }
}

================
File: src/modules/order/controllers/order.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { OrderService } from '../services/order.service';
import { Order } from '../schemas/order.schema';

@Controller('api/orders')
export class OrderController {
  constructor(private readonly orderService: OrderService) { }

  @Post()
  create(@Body() createOrderDto: any) {
    return this.orderService.create(createOrderDto);
  }

  @Get()
  findAll() {
    return this.orderService.findAll();
  }

  @Get('doanhthu')
  doanhThu() {
    return this.orderService.doanhThu();
  }
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.orderService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateOrderDto: any) {
    return this.orderService.update(id, updateOrderDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.orderService.remove(id);
  }
}

================
File: src/modules/order/order.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { OrderController } from './controllers/order.controller';
import { OrderService } from './services/order.service';
import { Order, OrderSchema } from './schemas/order.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Orders', schema: OrderSchema }])
  ],
  controllers: [OrderController],
  providers: [OrderService],
  exports: [OrderService]
})
export class OrderModule { }

================
File: src/modules/order/schemas/order.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'OrderProducts' })
export class OrderProduct {
  @Prop({ type: Types.ObjectId, ref: 'Products' })
  productId: Types.ObjectId;

  @Prop()
  quantity: number;

  @Prop()
  price: number;

  @Prop({ default: 0 })
  discount: number;
}

export const OrderProductSchema = SchemaFactory.createForClass(OrderProduct);

@Schema({ timestamps: true, collection: 'Orders' })
export class Order extends Document {
  @Prop({ unique: true, required: true })
  orderId: string;

  @Prop({ unique: true })
  orderCode: string;

  @Prop({ type: Types.ObjectId, ref: 'Customers' })
  customerId: Types.ObjectId;

  @Prop({ type: [OrderProductSchema] })
  products: OrderProduct[];

  @Prop()
  totalAmount: number;

  @Prop({ default: 0 })
  discount: number;

  @Prop({ enum: ['Ti·ªÅn m·∫∑t', 'Chuy·ªÉn kho·∫£n', 'Th·∫ª', 'V√≠'] })
  paymentMethod: string;

  @Prop({
    enum: [
      'Phi·∫øu t·∫°m th·ªùi',
      'ƒê√£ x√°c nh·∫≠n',
      'ƒêang giao h√†ng',
      'Ho√†n th√†nh',
      'ƒê√£ h·ªßy',
    ],
    default: 'Phi·∫øu t·∫°m th·ªùi',
  })
  status: string;

  @Prop({ type: Types.ObjectId })
  channel: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Carriers' })
  carrierId: Types.ObjectId;

  @Prop()
  deliveryDate: Date;
}

export const OrderSchema = SchemaFactory.createForClass(Order);

================
File: src/modules/order/services/order.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Order } from '../schemas/order.schema';

@Injectable()
export class OrderService {
  constructor(
    @InjectModel('Orders') private orderModel: Model<Order>,
  ) { }

  async create(createOrderDto: any): Promise<Order> {
    const lastOrder = await this.orderModel.findOne().sort({ orderId: -1 }).exec();
    let newOrderId = 'HD0001';
  
    if (lastOrder && lastOrder.orderId) {
      const lastNumber = parseInt(lastOrder.orderId.replace('HD', ''), 10);
      const nextNumber = lastNumber + 1;
      newOrderId = `HD${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdOrder = new this.orderModel({
      ...createOrderDto,
      orderId: newOrderId
    });
  
    return createdOrder.save();
  }

  async findAll(): Promise<Order[]> {
    return this.orderModel
      .find()
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
  }
  async doanhThu(): Promise<Order[]> {
    return this.orderModel
      .find()
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .populate('products.productId.priceList')
      .exec();
  }
  async findOne(id: string): Promise<Order> {
    const order = await this.orderModel
      .findById(id)
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  async update(id: string, updateOrderDto: any): Promise<Order> {
    const order = await this.orderModel
      .findByIdAndUpdate(id, updateOrderDto, { new: true })
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  async remove(id: string): Promise<Order> {
    const order = await this.orderModel.findByIdAndDelete(id).exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

}

================
File: src/modules/payroll/controllers/payroll.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Payroll } from '../schemas/payroll.schema';
import { PayrollService } from '../services/payroll.service';

@Controller('api/payrolls')
export class PayrollController {
  constructor(private readonly payrollService: PayrollService) { }

  @Post()
  async create(@Body() createPayrollDto: any): Promise<Payroll> {
    return this.payrollService.create(createPayrollDto);
  }

  @Get()
  findAll() {
    return this.payrollService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.payrollService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatepayrollDto: any) {
    return this.payrollService.update(id, updatepayrollDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.payrollService.remove(id);
  }
}

================
File: src/modules/payroll/payroll.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Payroll, PayrollSchema } from './schemas/payroll.schema';
import { PayrollController } from './controllers/payroll.controller';
import { PayrollService } from  './services/payroll.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Payrolls', schema: PayrollSchema }])
  ],
  controllers: [PayrollController],
  providers: [PayrollService],
  exports: [PayrollService]
})
export class PayrollModule { }

================
File: src/modules/payroll/schemas/payroll.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'Payrolls' })
export class Payroll extends Document {
  @Prop({ unique: true, required: true })
  payrollId: string;

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  employeeId: Types.ObjectId;

  @Prop()
  month: number;

  @Prop()
  year: number;

  @Prop()
  basicSalary: number;

  @Prop({ default: 0 })
  bonus: number;

  @Prop({ default: 0 })
  commission: number;

  @Prop({ default: 0 })
  allowance: number;

  @Prop({ default: 0 })
  deduction: number;

  @Prop()
  total: number;

  @Prop({ default: 0 })
  paid: number;

  @Prop({ enum: ['ƒêang t·∫°o', 'T·∫°m t√≠nh', 'ƒê√£ ch·ªët l∆∞∆°ng', 'ƒê√£ h·ªßy'], default: 'ƒêang t·∫°o' })
  status: string;

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branch: Types.ObjectId;
}

export const PayrollSchema = SchemaFactory.createForClass(Payroll);

================
File: src/modules/payroll/services/payroll.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Payroll } from '../schemas/payroll.schema';

@Injectable()
export class PayrollService {
  constructor(
    @InjectModel('Payrolls') private payrollModel: Model<Payroll>,
  ) { }

  async create(createPayrollDto: any): Promise<Payroll> {
    const lastPayroll = await this.payrollModel.findOne().sort({ payrollId: -1 }).exec();
    let newPayrollId = 'PR0001';
  
    if (lastPayroll && lastPayroll.payrollId) {
      const lastNumber = parseInt(lastPayroll.payrollId.replace('PR', ''), 10);
      const nextNumber = lastNumber + 1;
      newPayrollId = `PR${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPayroll = new this.payrollModel({
      ...createPayrollDto,
      payrollId: newPayrollId
    });
  
    return createdPayroll.save();
  }

  async findAll(): Promise<Payroll[]> {
    return this.payrollModel.find().exec();
  }

  async findOne(id: string): Promise<Payroll> {
    const payroll = await this.payrollModel.findById(id).exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }

  async update(id: string, updatePayrollDto: any): Promise<Payroll> {
    const payroll = await this.payrollModel
      .findByIdAndUpdate(id, updatePayrollDto, { new: true })
      .exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }

  async remove(id: string): Promise<Payroll> {
    const payroll = await this.payrollModel.findByIdAndDelete(id).exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }
}

================
File: src/modules/position/controllers/position.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Position } from '../schemas/position.schema';
import { PositionService } from '../services/position.service';

@Controller('api/positions')
export class PositionController {
  constructor(private readonly positionService: PositionService) { }

  @Post()
  async create(@Body() createPositionDto: any): Promise<Position> {
    return this.positionService.create(createPositionDto);
  }

  @Get()
  findAll() {
    return this.positionService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.positionService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePositionDto: any) {
    return this.positionService.update(id, updatePositionDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.positionService.remove(id);
  }
}

================
File: src/modules/position/position.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Position, PositionSchema } from './schemas/position.schema';
import { PositionService } from './services/position.service';
import { PositionController } from  './controllers/position.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Positions', schema: PositionSchema }])
  ],
  controllers: [PositionController],
  providers: [PositionService],
  exports: [PositionService]
})
export class PositionModule { }

================
File: src/modules/position/schemas/position.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Positions' })
export class Position extends Document {
  @Prop({ unique: true, required: true })
  positionId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ enum: ['Ho·∫°t ƒë·ªông', 'Ng·ª´ng ho·∫°t ƒë·ªông'], default: 'Ho·∫°t ƒë·ªông' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const PositionSchema = SchemaFactory.createForClass(Position);

================
File: src/modules/position/services/position.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Position } from '../schemas/position.schema';

@Injectable()
export class PositionService {
  constructor(
    @InjectModel('Positions') private PositionModel: Model<Position>,
  ) { }

  async create(createPositionDto: any): Promise<Position> {
    const lastPosition = await this.PositionModel.findOne().sort({ positionId: -1 }).exec();
    let newPositionId = 'CV0001';
  
    if (lastPosition && lastPosition.positionId) {
      const lastNumber = parseInt(lastPosition.positionId.replace('CV', ''), 10);
      const nextNumber = lastNumber + 1;
      newPositionId = `CV${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPosition = new this.PositionModel({
      ...createPositionDto,
      positionId: newPositionId
    });
  
    return createdPosition.save();
  }

  async findAll(): Promise<Position[]> {
    return this.PositionModel.find().exec();
  }

  async findOne(id: string): Promise<Position> {
    const position = await this.PositionModel.findById(id).exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }

  async update(id: string, updatePositionDto: any): Promise<Position> {
    const position = await this.PositionModel
      .findByIdAndUpdate(id, updatePositionDto, { new: true })
      .exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }

  async remove(id: string): Promise<Position> {
    const position = await this.PositionModel.findByIdAndDelete(id).exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }
}

================
File: src/modules/product/controllers/product.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ProductService } from '../services/product.service';
import { Product } from '../schemas/product.schema';

@Controller('api/products')
export class ProductController {
  constructor(private readonly productService: ProductService) { }

  @Post()
  create(@Body() createProductDto: any) {
    return this.productService.create(createProductDto);
  }

  @Get()
  findAll() {
    return this.productService.findAll();
  }

  @Get(':id')
  async getProduct(@Param('id') id: string) {
    return this.productService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateProductDto: any) {
    return this.productService.update(id, updateProductDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.productService.remove(id);
  }
}

================
File: src/modules/product/product.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ProductController } from './controllers/product.controller';
import { ProductService } from './services/product.service';
import { ProductSchema } from './schemas/product.schema';
import { BrandModule } from '../brand/brand.module';
import { CategoriesModule } from '../category/categories.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Products', schema: ProductSchema }]),
    BrandModule,
    CategoriesModule
  ],
  controllers: [ProductController],
  providers: [ProductService],
  exports: [ProductService]
})
export class ProductModule { }

================
File: src/modules/product/schemas/product.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { Categories } from '../../category/schemas/categories.schema';
import { Brand } from '../../brand/schemas/brand.schema';

@Schema({ timestamps: true, collection: 'Products' })
export class Product extends Document {
  @Prop({ unique: true, required: true })
  productId: string;

  @Prop()
  barcode: string;

  @Prop({ required: true })
  name: string;

  @Prop({ type: Types.ObjectId, ref: 'Categories' })
  category: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Brands' })
  brand: Types.ObjectId;

  @Prop({ required: true })
  price: number;

  @Prop()
  cost: number;

  @Prop({ default: 0 })
  stock: number;

  @Prop()
  location: string;

  @Prop()
  minStock: number;

  @Prop()
  maxStock: number;

  @Prop({ enum: ['Cho ph√©p kinh doanh', 'Ng·ª´ng kinh doanh'], default: 'Cho ph√©p kinh doanh' })
  status: string;

  @Prop()
  image: string;

  @Prop()
  weight: number;

  @Prop()
  unit: string;

  @Prop()
  description: string;
}

export const ProductSchema = SchemaFactory.createForClass(Product);

================
File: src/modules/product/services/product.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Product } from '../schemas/product.schema';

@Injectable()
export class ProductService {
  constructor(
    @InjectModel('Products') private productModel: Model<Product>,
  ) { }

  async create(createProductDto: any): Promise<Product> {
    const lastUser = await this.productModel.findOne().sort({ productId: -1 }).exec();
    let newProductId = 'SP0001';
  
    if (lastUser && lastUser.productId) {
      const lastNumber = parseInt(lastUser.productId.replace('SP', ''), 10);
      const nextNumber = lastNumber + 1;
      newProductId = `SP${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdProduct = new this.productModel({
      ...createProductDto,
      productId: newProductId
    });
  
    return createdProduct.save();
  }

  async findAll(): Promise<Product[]> {
    try {
      const products = await this.productModel.find().exec();
      
      // Populate category and brand only if they exist
      const populatedProducts = await Promise.all(
        products.map(async (product) => {
          if (product.category) {
            await product.populate('category');
          }
          if (product.brand) {
            await product.populate('brand');
          }
          return product;
        })
      );
      
      return populatedProducts;
    } catch (error) {
      console.error('Error in findAll:', error);
      throw error;
    }
  }

  async findOne(id: string): Promise<Product | null> {
    try {
      const product = await this.productModel.findById(id).exec();
      if (!product) {
        return null;
      }
      
      if (product.category) {
        await product.populate('category');
      }
      if (product.brand) {
        await product.populate('brand');
      }
      
      return product;
    } catch (error) {
      console.error('Error in findOne:', error);
      throw error;
    }
  }

  async update(id: string, updateProductDto: any): Promise<Product | null> {
    try {
      const product = await this.productModel
        .findByIdAndUpdate(id, updateProductDto, { new: true })
        .exec();
        
      if (!product) {
        return null;
      }
      
      if (product.category) {
        await product.populate('category');
      }
      if (product.brand) {
        await product.populate('brand');
      }
      
      return product;
    } catch (error) {
      console.error('Error in update:', error);
      throw error;
    }
  }

  async remove(id: string): Promise<Product | null> {
    return this.productModel.findByIdAndDelete(id).exec();
  }
}

================
File: src/modules/purchase-history/controllers/purchase-history.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PurchaseHistoryService } from '../services/purchase-history.service';
import { PurchaseHistory } from '../schemas/purchase-history.schema';

@Controller('api/purchase-historys')
export class PurchaseHistoryController {
  constructor(private readonly PurchaseHistoryService: PurchaseHistoryService) { }

  @Post()
  async create(@Body() createPurchaseHistoryDto: any): Promise<PurchaseHistory> {
    return this.PurchaseHistoryService.create(createPurchaseHistoryDto);
  }

  @Get()
  findAll() {
    return this.PurchaseHistoryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.PurchaseHistoryService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePurchaseHistoryDto: any) {
    return this.PurchaseHistoryService.update(id, updatePurchaseHistoryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.PurchaseHistoryService.remove(id);
  }
}

================
File: src/modules/purchase-history/purchase-history.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PurchaseHistory, PurchaseHistorySchema } from './schemas/purchase-history.schema';
import { PurchaseHistoryService } from './services/purchase-history.service';
import { PurchaseHistoryController } from './controllers/purchase-history.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PurchaseHistories', schema: PurchaseHistorySchema }])
  ],
  controllers: [PurchaseHistoryController],
  providers: [PurchaseHistoryService],
  exports: [PurchaseHistoryService]
})
export class PurchaseHistoryModule { }

================
File: src/modules/purchase-history/schemas/purchase-history.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'PurchaseHistories' })
export class PurchaseHistory extends Document {
  @Prop({ unique: true, required: true })
  purchaseHistoryId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores' })
  storeId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'ServicePackages' })
  packageId: Types.ObjectId;

  @Prop({ default: Date.now })
  purchaseDate: Date;

  @Prop()
  duration: number;

  @Prop()
  totalAmount: number;

  @Prop({
    enum: ['Ho√†n th√†nh', 'ƒêang x·ª≠ l√Ω', 'H·ªßy'],
    default: 'Ho√†n th√†nh',
  })
  status: string;
}

export const PurchaseHistorySchema = SchemaFactory.createForClass(PurchaseHistory);

================
File: src/modules/purchase-history/services/purchase-history.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PurchaseHistory } from '../schemas/purchase-history.schema';

@Injectable()
export class PurchaseHistoryService {
  constructor(
    @InjectModel('PurchaseHistories') private PurchaseHistoryModel: Model<PurchaseHistory>,
  ) { }

  async create(createPurchaseHistoryDto: any): Promise<PurchaseHistory> {
    const lastPurchaseHistory = await this.PurchaseHistoryModel.findOne().sort({ purchaseHistoryId: -1 }).exec();
    let newPurchaseHistoryId = 'PH0001';
  
    if (lastPurchaseHistory && lastPurchaseHistory.purchaseHistoryId) {
      const lastNumber = parseInt(lastPurchaseHistory.purchaseHistoryId.replace('PH', ''), 10);
      const nextNumber = lastNumber + 1;
      newPurchaseHistoryId = `PH${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPurchaseHistory = new this.PurchaseHistoryModel({
      ...createPurchaseHistoryDto,
      purchaseHistoryId: newPurchaseHistoryId
    });
  
    return createdPurchaseHistory.save();
  }

  async findAll(): Promise<PurchaseHistory[]> {
    return this.PurchaseHistoryModel.find().exec();
  }

  async findOne(id: string): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel.findById(id).exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }

  async update(id: string, updatePurchaseHistoryDto: any): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel
      .findByIdAndUpdate(id, updatePurchaseHistoryDto, { new: true })
      .exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }

  async remove(id: string): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel.findByIdAndDelete(id).exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }
}

================
File: src/modules/purchase-order/controllers/purchase-orders.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PurchaseOrderService } from '../services/purchase-orders.service';
import { PurchaseOrder } from '../schemas/purchase-orders.schema';

@Controller('api/purchase-orders')
export class PurchaseOrderController {
  constructor(private readonly purchaseOrderService: PurchaseOrderService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<PurchaseOrder> {
    return this.purchaseOrderService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.purchaseOrderService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.purchaseOrderService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatepurchaseOrderDto: any) {
    return this.purchaseOrderService.update(id, updatepurchaseOrderDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.purchaseOrderService.remove(id);
  }
}

================
File: src/modules/purchase-order/purchase-orders.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PurchaseOrder, PurchaseOrderSchema } from './schemas/purchase-orders.schema';
import { PurchaseOrderController } from './controllers/purchase-orders.controller';
import { PurchaseOrderService } from './services/purchase-orders.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PurchaseOrders', schema: PurchaseOrderSchema }])
  ],
  controllers: [PurchaseOrderController],
  providers: [PurchaseOrderService],
  exports: [PurchaseOrderService]
})
export class PurchaseOrderModule { }

================
File: src/modules/purchase-order/schemas/purchase-orders.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PurchaseOrderProducts' })
export class PurchaseOrderProduct {
  @Prop({ type: Types.ObjectId, ref: 'Products' })
  productId: Types.ObjectId;

  @Prop()
  quantity: number;

  @Prop()
  price: number;
}

export const PurchaseOrderProductSchema = SchemaFactory.createForClass(PurchaseOrderProduct);

@Schema({ timestamps: true, collection: 'PurchaseOrders' })
export class PurchaseOrder extends Document {
  @Prop({ unique: true, required: true })
  purchaseOrderId: string;

  @Prop()
  purchaseOrderCode: string;

  @Prop({ type: Types.ObjectId, ref: 'Suppliers' })
  supplierId: Types.ObjectId;

  @Prop({ type: [PurchaseOrderProductSchema] })
  products: PurchaseOrderProduct[];

  @Prop()
  totalAmount: number;

  @Prop({ enum: ['Phi·∫øu t·∫°m th·ªùi', 'ƒê√£ nh·∫≠p h√†ng', 'ƒê√£ h·ªßy'], default: 'Phi·∫øu t·∫°m th·ªùi' })
  status: string;
}

export const PurchaseOrderSchema = SchemaFactory.createForClass(PurchaseOrder);

================
File: src/modules/purchase-order/services/purchase-orders.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PurchaseOrder } from '../schemas/purchase-orders.schema';

@Injectable()
export class PurchaseOrderService {
  constructor(
    @InjectModel('PurchaseOrders') private PurchaseOrderModel: Model<PurchaseOrder>,
  ) { }

  async create(createPurchaseOrderDto: any): Promise<PurchaseOrder> {
    const lastPurchaseOrder = await this.PurchaseOrderModel.findOne().sort({ purchaseOrderId: -1 }).exec();
    let newPurchaseOrderId = 'PO0001';
  
    if (lastPurchaseOrder && lastPurchaseOrder.purchaseOrderId) {
      const lastNumber = parseInt(lastPurchaseOrder.purchaseOrderId.replace('PO', ''), 10);
      const nextNumber = lastNumber + 1;
      newPurchaseOrderId = `PO${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPurchaseOrder = new this.PurchaseOrderModel({
      ...createPurchaseOrderDto,
      purchaseOrderId: newPurchaseOrderId
    });
  
    return createdPurchaseOrder.save();
  }

  async findAll(): Promise<PurchaseOrder[]> {
    return this.PurchaseOrderModel.find().exec();
  }

  async findOne(id: string): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel.findById(id).exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }

  async update(id: string, updatePurchaseOrderDto: any): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel
      .findByIdAndUpdate(id, updatePurchaseOrderDto, { new: true })
      .exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }

  async remove(id: string): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel.findByIdAndDelete(id).exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }
}

================
File: src/modules/ruturn/controllers/return.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ReturnService } from '../services/return.service';
import { Return } from '../schemas/return.schema';

@Controller('api/returns')
export class ReturnController {
  constructor(private readonly returnService: ReturnService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<Return> {
    return this.returnService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.returnService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.returnService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateReturnDto: any) {
    return this.returnService.update(id, updateReturnDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.returnService.remove(id);
  }
}

================
File: src/modules/ruturn/return.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Return, ReturnSchema } from './schemas/return.schema';
import { ReturnController } from './controllers/return.controller';
import { ReturnService } from './services/return.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Returns', schema: ReturnSchema }])
  ],
  controllers: [ReturnController],
  providers: [ReturnService],
  exports: [ReturnService]
})
export class ReturnModule { }

================
File: src/modules/ruturn/schemas/return.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'ReturnProducts' })
export class ReturnProduct {
  @Prop({ type: Types.ObjectId, ref: 'Products' })
  productId: Types.ObjectId;

  @Prop()
  quantity: number;
}

export const ReturnProductSchema = SchemaFactory.createForClass(ReturnProduct);

@Schema({ timestamps: true, collection: 'Returns' })
export class Return extends Document {
  @Prop({ unique: true, required: true })
  returnId: string;

  @Prop()
  returnCode: string;

  @Prop({ type: Types.ObjectId, ref: 'Orders' })
  orderId: Types.ObjectId;

  @Prop({ type: [ReturnProductSchema] })
  products: ReturnProduct[];

  @Prop()
  reason: string;

  @Prop()
  totalRefund: number;

  @Prop({ enum: ['ƒê√£ tr·∫£', 'ƒê√£ h·ªßy'], default: 'ƒê√£ tr·∫£' })
  status: string;
}

export const ReturnSchema = SchemaFactory.createForClass(Return);

================
File: src/modules/ruturn/services/return.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Return } from '../schemas/return.schema';

@Injectable()
export class ReturnService {
  constructor(
    @InjectModel('Returns') private ReturnModel: Model<Return>,
  ) { }

  async create(createReturnDto: any): Promise<Return> {
    const lastReturn = await this.ReturnModel.findOne().sort({ returnId: -1 }).exec();
    let newReturnId = 'RT0001';
  
    if (lastReturn && lastReturn.returnId) {
      const lastNumber = parseInt(lastReturn.returnId.replace('RT', ''), 10);
      const nextNumber = lastNumber + 1;
      newReturnId = `RT${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdReturn = new this.ReturnModel({
      ...createReturnDto,
      returnId: newReturnId
    });
  
    return createdReturn.save();
  }

  async findAll(): Promise<Return[]> {
    return this.ReturnModel.find().exec();
  }

  async findOne(id: string): Promise<Return> {
    const Return = await this.ReturnModel.findById(id).exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }

  async update(id: string, updateReturnDto: any): Promise<Return> {
    const Return = await this.ReturnModel
      .findByIdAndUpdate(id, updateReturnDto, { new: true })
      .exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }

  async remove(id: string): Promise<Return> {
    const Return = await this.ReturnModel.findByIdAndDelete(id).exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }
}

================
File: src/modules/service-package/controllers/service-package.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ServicePackageService } from '../services/service-package.service';
import { ServicePackage } from '../schemas/service-package.schems';

@Controller('api/service-packages')
export class ServicePackageController {
  constructor(private readonly ServicePackageService: ServicePackageService) { }

  @Post()
  async create(@Body() createServicePackageDto: any): Promise<ServicePackage> {
    return this.ServicePackageService.create(createServicePackageDto);
  }

  @Get()
  findAll() {
    return this.ServicePackageService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.ServicePackageService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateServicePackageDto: any) {
    return this.ServicePackageService.update(id, updateServicePackageDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.ServicePackageService.remove(id);
  }
}

================
File: src/modules/service-package/schemas/service-package.schems.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ timestamps: true, collection: 'ServicePackages' })
export class ServicePackage extends Document {
  @Prop({ unique: true, required: true })
  packageId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop([String])
  features: string[];

  @Prop({ required: true })
  price: number;

  @Prop([Number])
  durationOptions: number[];
}

export const ServicePackageSchema = SchemaFactory.createForClass(ServicePackage);

================
File: src/modules/service-package/service-package.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ServicePackage, ServicePackageSchema } from './schemas/service-package.schems';
import { ServicePackageService } from './services/service-package.service';
import { ServicePackageController } from './controllers/service-package.controller';


@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'ServicePackages', schema: ServicePackageSchema }])
  ],
  controllers: [ServicePackageController],
  providers: [ServicePackageService],
  exports: [ServicePackageService]
})
export class ServicePackageModule { }

================
File: src/modules/service-package/services/service-package.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ServicePackage } from '../schemas/service-package.schems';

@Injectable()
export class ServicePackageService {
  constructor(
    @InjectModel('ServicePackages') private ServicePackageModel: Model<ServicePackage>,
  ) { }

  async create(createServicePackageDto: any): Promise<ServicePackage> {
    const lastServicePackage = await this.ServicePackageModel.findOne().sort({ packageId: -1 }).exec();
    let newServicePackageId = 'SVP0001';
  
    if (lastServicePackage && lastServicePackage.packageId) {
      const lastNumber = parseInt(lastServicePackage.packageId.replace('SVP', ''), 10);
      const nextNumber = lastNumber + 1;
      newServicePackageId = `SVP${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdServicePackage = new this.ServicePackageModel({
      ...createServicePackageDto,
      servicePackageId: newServicePackageId
    });
  
    return createdServicePackage.save();
  }

  async findAll(): Promise<ServicePackage[]> {
    return this.ServicePackageModel.find().exec();
  }

  async findOne(id: string): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel.findById(id).exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }

  async update(id: string, updateServicePackageDto: any): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel
      .findByIdAndUpdate(id, updateServicePackageDto, { new: true })
      .exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }

  async remove(id: string): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel.findByIdAndDelete(id).exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }
}

================
File: src/modules/shipment/controllers/shipment.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { ShipmentService } from '../services/shipment.service';
import { Shipment } from '../schemas/shipment.schema';

@Controller('api/shipments')
export class ShipmentController {
  constructor(private readonly shipmentService: ShipmentService) { }

  @Post()
  async create(@Body() createShipmentDto: any): Promise<Shipment> {
    return this.shipmentService.create(createShipmentDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<Shipment[]> {
    return this.shipmentService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Shipment> {
    return this.shipmentService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateShipmentDto: any,
  ): Promise<Shipment> {
    return this.shipmentService.update(id, updateShipmentDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Shipment> {
    return this.shipmentService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<Shipment> {
    return this.shipmentService.updateStatus(id, status);
  }

  @Put(':id/tracking')
  async updateTracking(
    @Param('id') id: string,
    @Body() tracking: any,
  ): Promise<Shipment> {
    return this.shipmentService.updateTracking(id, tracking);
  }

  @Put(':id/carrier')
  async updateCarrier(
    @Param('id') id: string,
    @Body('carrierId') carrierId: string,
  ): Promise<Shipment> {
    return this.shipmentService.updateCarrier(id, carrierId);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<Shipment[]> {
    return this.shipmentService.findByStore(storeId);
  }

  @Get('order/:orderId')
  async findByOrder(@Param('orderId') orderId: string): Promise<Shipment[]> {
    return this.shipmentService.findByOrder(orderId);
  }
}

================
File: src/modules/shipment/schemas/shipment.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'TrackingHistories' })
export class TrackingHistory {
  @Prop({ required: true })
  status: string;

  @Prop()
  location: string;

  @Prop({ default: Date.now })
  timestamp: Date;

  @Prop()
  note: string;
}

export const TrackingHistorySchema = SchemaFactory.createForClass(TrackingHistory);

@Schema({ timestamps: true, collection: 'Shipments' })
export class Shipment extends Document {
  @Prop({ unique: true, required: true })
  shipmentId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId;

  @Prop({
    enum: [
      'Giao h√†ng nhanh',
      'Giao h√†ng ti·∫øt ki·ªám',
      'Viettel Post',
      'Grab Express',
      'T·ª± giao',
    ],
    required: true,
  })
  shippingMethod: string;

  @Prop()
  trackingNumber: string;

  @Prop({ required: true })
  shippingFee: number;

  @Prop()
  estimatedDeliveryDate: Date;

  @Prop()
  actualDeliveryDate: Date;

  @Prop({
    type: {
      fullName: { type: String, required: true },
      phone: { type: String, required: true },
      address: { type: String, required: true },
      ward: String,
      district: String,
      city: String,
      province: String,
      country: { type: String, default: 'Vi·ªát Nam' },
    },
  })
  shippingAddress: {
    fullName: string;
    phone: string;
    address: string;
    ward: string;
    district: string;
    city: string;
    province: string;
    country: string;
  };

  @Prop({
    enum: [
      'Ch·ªù x·ª≠ l√Ω',
      'ƒê√£ nh·∫≠n ƒë∆°n',
      'ƒêang v·∫≠n chuy·ªÉn',
      'ƒê√£ giao h√†ng',
      'Giao h√†ng th·∫•t b·∫°i',
      'ƒê√£ h·ªßy',
    ],
    default: 'Ch·ªù x·ª≠ l√Ω',
  })
  status: string;

  @Prop({ type: [TrackingHistorySchema] })
  trackingHistory: TrackingHistory[];

  @Prop()
  notes: string;
}

export const ShipmentSchema = SchemaFactory.createForClass(Shipment);

ShipmentSchema.index({ storeId: 1 });
ShipmentSchema.index({ orderId: 1 });
ShipmentSchema.index({ customerId: 1 });
ShipmentSchema.index({ trackingNumber: 1 });

================
File: src/modules/shipment/services/shipment.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Shipment } from '../schemas/shipment.schema';

@Injectable()
export class ShipmentService {
  constructor(
    @InjectModel('Shipments')
    private shipmentModel: Model<Shipment>,
  ) { }

  async create(createShipmentDto: any): Promise<Shipment> {
    const lastShipment = await this.shipmentModel.findOne().sort({ shipmentId: -1 }).exec();
    let newShipmentId = 'SM0001';
  
    if (lastShipment && lastShipment.shipmentId) {
      const lastNumber = parseInt(lastShipment.shipmentId.replace('SM', ''), 10);
      const nextNumber = lastNumber + 1;
      newShipmentId = `SM${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdShipment = new this.shipmentModel({
      ...createShipmentDto,
      shipmentId: newShipmentId
    });
  
    return createdShipment.save();
  }

  async findAll(query: any = {}): Promise<Shipment[]> {
    return this.shipmentModel.find(query).exec();
  }

  async findOne(id: string): Promise<Shipment> {
    const shipment = await this.shipmentModel.findById(id).exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async update(id: string, updateShipmentDto: any): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, updateShipmentDto, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async remove(id: string): Promise<Shipment> {
    const shipment = await this.shipmentModel.findByIdAndDelete(id).exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateStatus(id: string, status: string): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateTracking(id: string, tracking: any): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { tracking }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateCarrier(id: string, carrierId: string): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { carrier: carrierId }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async findByStore(storeId: string): Promise<Shipment[]> {
    return this.shipmentModel.find({ storeId }).exec();
  }

  async findByOrder(orderId: string): Promise<Shipment[]> {
    return this.shipmentModel.find({ order: orderId }).exec();
  }
}

================
File: src/modules/shipment/shipment.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Shipment, ShipmentSchema } from './schemas/shipment.schema';
import { ShipmentController } from './controllers/shipment.controller';
import { ShipmentService } from './services/shipment.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Shipments', schema: ShipmentSchema }])
  ],
  controllers: [ShipmentController],
  providers: [ShipmentService],
  exports: [ShipmentService]
})
export class ShipmentModule { }

================
File: src/modules/store/controllers/store.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { StoreService } from '../services/store.service';
import { Store } from '../schemas/store.schema';

@Controller('api/stores')
export class StoreController {
  constructor(private readonly storeService: StoreService) { }

  @Post()
  create(@Body() createStoreDto: any) {
    return this.storeService.create(createStoreDto);
  }

  @Get()
  findAll() {
    return this.storeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.storeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateStoreDto: any) {
    return this.storeService.update(id, updateStoreDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.storeService.remove(id);
  }
}

================
File: src/modules/store/schemas/store.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'Stores' })
export class Store extends Document {
  @Prop({ unique: true, required: true })
  storeId: string;

  @Prop({ enum: ['C√° nh√¢n', 'Doanh nghi·ªáp'] })
  accountType: string;

  @Prop({ required: true })
  representative: string;

  @Prop({ required: true })
  phone: string;

  @Prop()
  email: string;

  @Prop({ enum: ['Nam', 'N·ªØ', 'Kh√°c'] })
  gender: string;

  @Prop()
  dob: Date;

  @Prop()
  idCard: string;

  @Prop()
  issueDate: Date;

  @Prop()
  issuePlace: string;

  @Prop()
  address: string;

  @Prop({ required: true })
  storeName: string;

  @Prop()
  industry: string;

  @Prop({ default: 0 })
  branchCount: number;

  @Prop({ default: 0 })
  employeeCount: number;

  @Prop({ enum: ['ƒêang s·ª≠ d·ª•ng', 'Ng·ª´ng s·ª≠ d·ª•ng'], default: 'ƒêang s·ª≠ d·ª•ng' })
  status: string;

  @Prop()
  expirationDate: Date;

  @Prop({ type: Types.ObjectId, ref: 'ServicePackages' })
  servicePackage: Types.ObjectId;

  @Prop({ default: 0 })
  warehouseCount: number;
}

export const StoreSchema = SchemaFactory.createForClass(Store);

================
File: src/modules/store/services/store.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Store } from '../schemas/store.schema';

@Injectable()
export class StoreService {
  constructor(
    @InjectModel('Stores') private storeModel: Model<Store>,
  ) {}

  async create(createStoreDto: any): Promise<Store> {
    const lastStore = await this.storeModel.findOne().sort({ storeId: -1 }).exec();
    let newStoreId = 'ST0001';
  
    if (lastStore && lastStore.storeId) {
      const lastNumber = parseInt(lastStore.storeId.replace('ST', ''), 10);
      const nextNumber = lastNumber + 1;
      newStoreId = `ST${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdStore = new this.storeModel({
      ...createStoreDto,
      storeId: newStoreId
    });
  
    return createdStore.save();
  }

  async findAll(): Promise<Store[]> {
    return this.storeModel.find().populate('servicePackage').exec();
  }

  async findOne(id: string): Promise<Store> {
    const store = await this.storeModel.findById(id).populate('servicePackage').exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }

  async update(id: string, updateStoreDto: any): Promise<Store> {
    const store = await this.storeModel
      .findByIdAndUpdate(id, updateStoreDto, { new: true })
      .populate('servicePackage')
      .exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }

  async remove(id: string): Promise<Store> {
    const store = await this.storeModel.findByIdAndDelete(id).exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }
}

================
File: src/modules/store/store.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { StoreController } from './controllers/store.controller';
import { StoreService } from './services/store.service';
import { Store, StoreSchema } from './schemas/store.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Stores', schema: StoreSchema },
    ]),
  ],
  controllers: [StoreController],
  providers: [StoreService],
  exports: [StoreService],
})
export class StoreModule { }

================
File: src/modules/supplier-group/controllers/supplier-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SupplierGroupService } from '../services/supplier-group.service';
import { SupplierGroup } from '../schemas/supplier-group.schema';

@Controller('api/supplier-groups')
export class SupplierGroupController {
  constructor(private readonly supplierGroupService: SupplierGroupService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<SupplierGroup> {
    return this.supplierGroupService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.supplierGroupService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.supplierGroupService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSupplierGroupDto: any) {
    return this.supplierGroupService.update(id, updateSupplierGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.supplierGroupService.remove(id);
  }
}

================
File: src/modules/supplier-group/schemas/supplier-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'SupplierGroups' })
export class SupplierGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const SupplierGroupSchema = SchemaFactory.createForClass(SupplierGroup);

================
File: src/modules/supplier-group/services/supplier-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SupplierGroup } from '../schemas/supplier-group.schema';

@Injectable()
export class SupplierGroupService {
  constructor(
    @InjectModel('SupplierGroups') private SupplierGroupModel: Model<SupplierGroup>,
  ) { }

  async create(createSupplierGroupDto: any): Promise<SupplierGroup> {
    const lastSupplierGroup = await this.SupplierGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newSupplierGroupId = 'SSG0001';
  
    if (lastSupplierGroup && lastSupplierGroup.groupId) {
      const lastNumber = parseInt(lastSupplierGroup.groupId.replace('SSG', ''), 10);
      const nextNumber = lastNumber + 1;
      newSupplierGroupId = `SSG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdSupplierGroup = new this.SupplierGroupModel({
      ...createSupplierGroupDto,
      supplierGroupId: newSupplierGroupId
    });
  
    return createdSupplierGroup.save();
  }

  async findAll(): Promise<SupplierGroup[]> {
    return this.SupplierGroupModel.find().exec();
  }

  async findOne(id: string): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel.findById(id).exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }

  async update(id: string, updateSupplierGroupDto: any): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel
      .findByIdAndUpdate(id, updateSupplierGroupDto, { new: true })
      .exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }

  async remove(id: string): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel.findByIdAndDelete(id).exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }
}

================
File: src/modules/supplier-group/supplier-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SupplierGroup, SupplierGroupSchema } from './schemas/supplier-group.schema';
import { SupplierGroupController } from './controllers/supplier-group.controller';
import { SupplierGroupService } from './services/supplier-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'SupplierGroups', schema: SupplierGroupSchema }])
  ],
  controllers: [SupplierGroupController],
  providers: [SupplierGroupService],
  exports: [SupplierGroupService]
})
export class SupplierGroupModule { }

================
File: src/modules/supplier/controllers/supplier.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SupplierService } from '../services/supplier.service';
import { Supplier } from '../schemas/supplier.schema';

@Controller('api/suppliers')
export class SupplierController {
  constructor(private readonly supplierService: SupplierService) { }

  @Post()
  create(@Body() createSupplierDto: any) {
    return this.supplierService.create(createSupplierDto);
  }

  @Get()
  findAll() {
    return this.supplierService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.supplierService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSupplierDto: any) {
    return this.supplierService.update(id, updateSupplierDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.supplierService.remove(id);
  }
}

================
File: src/modules/supplier/schemas/supplier.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Suppliers' })
export class Supplier extends Document {
  @Prop({ unique: true, required: true })
  supplierId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  phone: string;

  @Prop()
  email: string;

  @Prop()
  address: string;

  @Prop({ type: Types.ObjectId, ref: 'SupplierGroups' })
  group: Types.ObjectId;

  @Prop({ default: 0 })
  debt: number;

  @Prop({ default: 0 })
  totalPurchases: number;

  @Prop({ enum: ['ƒêang ho·∫°t ƒë·ªông', 'Ng·ª´ng ho·∫°t ƒë·ªông'], default: 'ƒêang ho·∫°t ƒë·ªông' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;
}

export const SupplierSchema = SchemaFactory.createForClass(Supplier);

================
File: src/modules/supplier/services/supplier.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Supplier } from '../schemas/supplier.schema';
import { Product } from '../../product/schemas/product.schema';

@Injectable()
export class SupplierService {
  constructor(
    @InjectModel('Suppliers') private supplierModel: Model<Supplier>,
  ) { }

  async create(createSupplierDto: any): Promise<Supplier> {
    const lastSupplier = await this.supplierModel.findOne().sort({ supplierId: -1 }).exec();
    let newSupplierId = 'SSE0001';
  
    if (lastSupplier && lastSupplier.supplierId) {
      const lastNumber = parseInt(lastSupplier.supplierId.replace('SSE', ''), 10);
      const nextNumber = lastNumber + 1;
      newSupplierId = `SSE${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdSupplier = new this.supplierModel({
      ...createSupplierDto,
      supplierId: newSupplierId
    });
  
    return createdSupplier.save();
  }
  async findAll(): Promise<Supplier[]> {
    return this.supplierModel.find().populate('group').exec();
  }

  async findOne(id: string): Promise<Supplier> {
    const supplier = await this.supplierModel.findById(id).populate('group').exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }

  async update(id: string, updateSupplierDto: any): Promise<Supplier> {
    const supplier = await this.supplierModel
      .findByIdAndUpdate(id, updateSupplierDto, { new: true })
      .populate('group')
      .exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }

  async remove(id: string): Promise<Supplier> {
    const supplier = await this.supplierModel.findByIdAndDelete(id).exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }
}

================
File: src/modules/supplier/supplier.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SupplierController } from './controllers/supplier.controller';
import { SupplierService } from './services/supplier.service';
import { Supplier, SupplierSchema } from './schemas/supplier.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Suppliers', schema: SupplierSchema }
    ]),
  ],
  controllers: [SupplierController],
  providers: [SupplierService],
  exports: [SupplierService],
})
export class SupplierModule { }

================
File: test/app.e2e-spec.ts
================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication<App>;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

================
File: test/jest-e2e.json
================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

================
File: tsconfig.build.json
================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2023",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "noFallthroughCasesInSwitch": false
  }
}



================================================================
End of Codebase
================================================================
