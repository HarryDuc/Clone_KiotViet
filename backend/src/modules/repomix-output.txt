This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
attendance/attendance.module.ts
attendance/controllers/attendance.controller.ts
attendance/dtos/attendance.dto.ts
attendance/schemas/attendance.schema.ts
attendance/services/attendance.service.ts
auth/controllers/user.controller.ts
auth/dtos/user.dto.ts
auth/guard/auth.guard.ts
auth/schemas/user.schema.ts
auth/services/user.service.ts
auth/user.module.ts
blog-categories/blog-categories.module.ts
blog-categories/controllers/blog-categories.controller.ts
blog-categories/dtos/blog-categories.dto.ts
blog-categories/schemas/blog-categories.schema.ts
blog-categories/services/blog-categories.service.ts
blog-post/blog-post.module.ts
blog-post/controllers/blog-post.controller.ts
blog-post/dtos/blog-category.dto.ts
blog-post/schemas/blog-post.schema.ts
blog-post/services/blog-post.service.ts
branch/branch.module.ts
branch/controllers/branch.controller.ts
branch/dtos/branch.dto.ts
branch/schemas/branch.schema.ts
branch/services/branch.service.ts
brand/brand.module.ts
brand/controllers/brand.controller.ts
brand/dtos/brand.dto.ts
brand/schemas/brand.schema.ts
brand/services/brand.service.ts
carrier-group/carrier-group.module.ts
carrier-group/controllers/carrier-group.controller.ts
carrier-group/dtos/carrier-group.dto.ts
carrier-group/schemas/carrier-group.schema.ts
carrier-group/services/carrier-group.service.ts
carrier/carrier.module.ts
carrier/controllers/carrier.controller.ts
carrier/dtos/carrier.dto.ts
carrier/schemas/carrier.schema.ts
carrier/services/carrier.service.ts
cash-book/cash-book.module.ts
cash-book/controllers/cash-book.controller.ts
cash-book/dtos/cash-book.dto.ts
cash-book/schemas/cash-book.schema.ts
cash-book/services/cash-book.service.ts
categories/categories.module.ts
categories/controllers/categories.controller.ts
categories/dtos/categories.dto.ts
categories/schemas/categories.schema.ts
categories/services/categories.service.ts
commission-setting/commission-setting.module.ts
commission-setting/controllers/commission-setting.controller.ts
commission-setting/dtos/commisson-setting.dto.ts
commission-setting/schemas/commission-setting.schema.ts
commission-setting/services/commission-setting.service.ts
customer-group/controllers/customer-group.controller.ts
customer-group/customer-group.module.ts
customer-group/dtos/customer-group.dto.ts
customer-group/schemas/customer-group.schema.ts
customer-group/services/customer-group.service.ts
customer-loyalty-point/controllers/customer-loyalty-points.controller.ts
customer-loyalty-point/customer-loyalty.module.ts
customer-loyalty-point/dtos/customer-loyalty-point.dto.ts
customer-loyalty-point/schemas/customer-loyalty-points.schema.ts
customer-loyalty-point/services/customer-loyalty-points.service.ts
customer/controllers/customer.controller.ts
customer/customer.module.ts
customer/dtos/customer.dto.ts
customer/schemas/customer.schema.ts
customer/services/customer.service.ts
department/controllers/department.controller.ts
department/department.module.ts
department/dtos/department.dto.ts
department/schemas/department.schema.ts
department/services/department.service.ts
destruction/controllers/destruction.controller.ts
destruction/dtos/destruction.dto.ts
destruction/schemas/destructions.schema.ts
destruction/services/destruction.service.ts
employee/controllers/employee.controller.ts
employee/dtos/employee.dto.ts
employee/employee.module.ts
employee/schemas/employee.schema.ts
employee/services/employee.service.ts
holiday/controllers/holiday.controller.ts
holiday/dtos/holiday.dto.ts
holiday/holiday.module.ts
holiday/schemas/holiday.schema.ts
holiday/services/holiday.service.ts
inventory-check/controllers/inventory-check.controller.ts
inventory-check/dtos/inventory-check.dto.ts
inventory-check/inventory-check.module.ts
inventory-check/schemas/inventory-check.schema.ts
inventory-check/services/inventory-check.service.ts
invoice/controllers/invoice.controller.ts
invoice/dtos/invoice.dto.ts
invoice/invoice.module.ts
invoice/schemas/invoice.schema.ts
invoice/services/invoice.service.ts
livestream/controllers/livestream.controller.ts
livestream/dtos/livestream.dto.ts
livestream/livestream.module.ts
livestream/schemas/livestream.schema.ts
livestream/services/livestream.service.ts
loyalty-program/controllers/loyalty-program.controller.ts
loyalty-program/dtos/loyalty-program.dto.ts
loyalty-program/loyalty-program.module.ts
loyalty-program/schemas/loyalty-program.schema.ts
loyalty-program/services/loyalty-program.service.ts
marketing-campaign/controllers/marketing-campaign.controller.ts
marketing-campaign/dtos/marketing-campaign.dto.ts
marketing-campaign/marketing-campaign.module.ts
marketing-campaign/schemas/marketing-campaign.schema.ts
marketing-campaign/services/marketing-campaign.service.ts
marketplace-listing/controllers/marketplace-listing.controller.ts
marketplace-listing/dtos/marketplace-listing.dto.ts
marketplace-listing/marketplace-listing.module.ts
marketplace-listing/schemas/marketplace-listing.schema.ts
marketplace-listing/services/marketplace-listing.service.ts
order/controllers/order.controller.ts
order/dtos/order.dto.ts
order/order.module.ts
order/schemas/order.schema.ts
order/services/order.service.ts
payroll/controllers/payroll.controller.ts
payroll/dtos/payroll.dto.ts
payroll/payroll.module.ts
payroll/schemas/payroll.schema.ts
payroll/services/payroll.service.ts
position/controllers/position.controller.ts
position/dtos/position.dto.ts
position/position.module.ts
position/schemas/position.schema.ts
position/services/position.service.ts
price-list/controllers/price-list.controller.ts
price-list/dtos/price-list.dto.ts
price-list/price-list.module.ts
price-list/schemas/price-list.schema.ts
price-list/services/price-list.service.ts
product/controllers/product.controller.ts
product/dtos/product.schema.ts
product/product.module.ts
product/schemas/product.schema.ts
product/services/product.service.ts
purchase-history/controllers/purchase-history.controller.ts
purchase-history/dtos/purchase-history.dto.ts
purchase-history/purchase-history.module.ts
purchase-history/schemas/purchase-history.schema.ts
purchase-history/services/purchase-history.service.ts
purchase-order/controllers/purchase-orders.controller.ts
purchase-order/dtos/purchase-order.dto.ts
purchase-order/purchase-orders.module.ts
purchase-order/schemas/purchase-orders.schema.ts
purchase-order/services/purchase-orders.service.ts
return-purchase/controllers/return-purchase.controller.ts
return-purchase/dtos/return-purchase.dto.ts
return-purchase/return-purchase.module.ts
return-purchase/schemas/return-purchase.schema.ts
return-purchase/services/return-purchase.service.ts
ruturn/controllers/return.controller.ts
ruturn/dtos/return.dto.ts
ruturn/return.module.ts
ruturn/schemas/return.schema.ts
ruturn/services/return.service.ts
sale-channel/controllers/sale-channel.controller.ts
sale-channel/dtos/sale-channel.dto.ts
sale-channel/sale-channel.module.ts
sale-channel/schemas/sale-channel.schema.ts
sale-channel/services/sale-channel.service.ts
service-package/controllers/service-package.controller.ts
service-package/dtos/service-package.dto.ts
service-package/schemas/service-package.schems.ts
service-package/service-package.module.ts
service-package/services/service-package.service.ts
shipment/controllers/shipment.controller.ts
shipment/dtos/shipment.dto.ts
shipment/schemas/shipment.schema.ts
shipment/services/shipment.service.ts
shipment/shipment.module.ts
social-media-conversation/controllers/social-media-conversation.controller.ts
social-media-conversation/dtos/social-media-conversation.dto.ts
social-media-conversation/schemas/social-media-conversation.schema.ts
social-media-conversation/services/social-media-conversation.service.ts
social-media-conversation/social-media-conversation.module.ts
social-media-post/controllers/social-media-post.controller.ts
social-media-post/dtos/social-media-post.dto.ts
social-media-post/schemas/social-media-post.schema.ts
social-media-post/services/social-media-post.service.ts
social-media-post/social-media-post.module.ts
store/controllers/store.controller.ts
store/dtos/store.dto.ts
store/schemas/store.schema.ts
store/services/store.service.ts
store/store.module.ts
supplier-group/controllers/supplier-group.controller.ts
supplier-group/dtos/supplier-group.dto.ts
supplier-group/schemas/supplier-group.schema.ts
supplier-group/services/supplier-group.service.ts
supplier-group/supplier-group.module.ts
supplier/controllers/supplier.controller.ts
supplier/dto/supplier.dto.ts
supplier/schemas/supplier.schema.ts
supplier/services/supplier.service.ts
supplier/supplier.module.ts
transaction/controllers/transaction.controller.ts
transaction/dtos/transaction.dto.ts
transaction/schemas/transaction.schema.ts
transaction/services/transaction.service.ts
transaction/transaction.module.ts
website-setting/controllers/website-settings.controller.ts
website-setting/dtos/website-setting.dto.ts
website-setting/schemas/website-settings.schema.ts
website-setting/services/website-settings.service.ts
work-schedule/controllers/work-schedule.controller.ts
work-schedule/dtos/work-schedule.dto.ts
work-schedule/schemas/work-schedule.schema.ts
work-schedule/services/work-schedule.service.ts
work-schedule/work-schedule.module.ts

================================================================
Files
================================================================

================
File: attendance/attendance.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Attendance, AttendanceSchema } from './schemas/attendance.schema';
import { AttendanceService } from './services/attendance.service';
import { AttendanceController } from './controllers/attendance.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Attendances', schema: AttendanceSchema }]),
  ],
  controllers: [AttendanceController],
  providers: [AttendanceService],
})
export class AttendanceModule {}

================
File: attendance/controllers/attendance.controller.ts
================
import { Controller, Get, Post, Body, Param, Delete, Put } from '@nestjs/common';
import { AttendanceService } from '../services/attendance.service';
import { Attendance } from '../schemas/attendance.schema';
import { CreateAttendanceDTO, UpdateAttendanceDTO } from '../dtos/attendance.dto';

@Controller('api/attendances')
export class AttendanceController {
  constructor(private readonly attendanceService: AttendanceService) { }

  @Post()
  async create(@Body() createAttendanceDto: CreateAttendanceDTO): Promise<Attendance> {
    return this.attendanceService.create(createAttendanceDto);
  }

  @Get()
  async findAll(): Promise<Attendance[]> {
    return this.attendanceService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Attendance> {
    return this.attendanceService.findOne(id);
  }

  @Put(':id')
  async update(@Param('id') id: string, @Body() updateAttendanceDto: UpdateAttendanceDTO): Promise<Attendance> {
    return this.attendanceService.update(id, updateAttendanceDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Attendance> {
    return this.attendanceService.remove(id);
  }
}

================
File: attendance/dtos/attendance.dto.ts
================
export class AttendanceDTO {
  attendanceId: string;
  employeeId: string;
  date: Date;
  checkIn: Date;
  checkOut: Date;
  status: string;
  createdAt: Date;
  absenceReason?: string;
  overtimeHours: number; // Thêm
  lateMinutes: number; // Thêm
}

export class CreateAttendanceDTO {
  employeeId: string;
  date: Date;
  checkIn: Date;
  checkOut: Date;
  status: string;
  absenceReason?: string;
  overtimeHours?: number; // Tùy chọn
  lateMinutes?: number; // Tùy chọn
}

export class UpdateAttendanceDTO {
  date?: Date;
  checkIn?: Date;
  checkOut?: Date;
  status?: string;
  absenceReason?: string;
  overtimeHours?: number; // Tùy chọn
  lateMinutes?: number; // Tùy chọn
}

================
File: attendance/schemas/attendance.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Attendances' })
export class Attendance extends Document {
  @Prop({ unique: true, required: true })
  attendanceId: string;

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId;

  @Prop({ required: true })
  date: Date;

  @Prop()
  checkIn: Date;

  @Prop()
  checkOut: Date;

  @Prop({ enum: ['Đúng giờ', 'Đi muộn', 'Về sớm', 'Chưa chấm công', 'Nghỉ làm'], default: 'Chưa chấm công' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop()
  absenceReason?: string;

  // Trường mới
  @Prop({ default: 0 })
  overtimeHours: number; // Số giờ làm thêm

  @Prop({ default: 0 })
  lateMinutes: number; // Số phút đi muộn
}

export const AttendanceSchema = SchemaFactory.createForClass(Attendance);

================
File: attendance/services/attendance.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Attendance } from '../schemas/attendance.schema';
import { CreateAttendanceDTO, UpdateAttendanceDTO } from '../dtos/attendance.dto';

@Injectable()
export class AttendanceService {
  constructor(@InjectModel('Attendances') private attendanceModel: Model<Attendance>) {}

  // Thêm mới attendance
  async create(createAttendance: CreateAttendanceDTO): Promise<Attendance> {
    const lastUser = await this.attendanceModel.findOne().sort({ attendanceId: -1 }).exec();
    let newAttendanceId = 'ATT00001';

    if (lastUser && lastUser.attendanceId) {
      const lastNumber = parseInt(lastUser.attendanceId.replace('ATT', ''), 10);
      const nextNumber = lastNumber + 1;
      newAttendanceId = `ATT${nextNumber.toString().padStart(5, '0')}`;
    }

    const createdAttendance = new this.attendanceModel({
      ...createAttendance,
      attendanceId: newAttendanceId
    });

    return createdAttendance.save();
  }

  async findAll(): Promise<Attendance[]> {
    return this.attendanceModel.find().exec();
  }

  // Lấy một attendance theo ID
  async findOne(id: string): Promise<Attendance> {
    const attendance = await this.attendanceModel.findById(id).exec();
    if (!attendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return attendance;
  }

  // Cập nhật attendance
  async update(id: string, updateAttendanceDto: UpdateAttendanceDTO): Promise<Attendance> {
    const updatedAttendance = await this.attendanceModel.findByIdAndUpdate(id, updateAttendanceDto, { new: true }).exec();
    if (!updatedAttendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return updatedAttendance;
  }

  // Xóa attendance
  async remove(id: string): Promise<Attendance> {
    const deletedAttendance = await this.attendanceModel.findByIdAndDelete(id).exec();
    if (!deletedAttendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return deletedAttendance;
  }
}

================
File: auth/controllers/user.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UserService } from '../services/user.service';
import { User } from '../schemas/user.schema';

@Controller('api/auth')
export class UserController {
  constructor(private readonly userService: UserService) { }

  @Post()
  create(@Body() createUserDto: any) {
    return this.userService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.userService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: any) {
    return this.userService.update(id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }

  @Post('register')
  register(@Body() registerDto: any) {
    return this.userService.register(registerDto);
  }

  @Post('login')
  login(@Body() loginDto: any) {
    return this.userService.login(loginDto.email, loginDto.password);
  }
}

================
File: auth/dtos/user.dto.ts
================
import { CreateStoreDTO } from "src/modules/store/dtos/store.dto";

export class UserDTO {
  userId: string;
  username: string;
  password: string;
  fullName: string; // Họ tên
  phone: string; // Số điện thoại
  role: string; // Vai trò
  storeId: string; // ID cửa hàng
  isAdmin: boolean;
  createdAt: Date;
  email?: string;
  permissions?: string[];
  language?: string;
  authProvider?: string;
}

// DTO cho tài khoản chính (Store Owner)
export class CreateStoreOwnerDTO {
  fullName: string; // Bắt buộc - Họ tên
  phone: string; // Bắt buộc - Số điện thoại
  username: string; // Bắt buộc
  password: string; // Bắt buộc - Mật khẩu
  store: CreateStoreDTO; // Bắt buộc - Thông tin cửa hàng (nested)
  role?: string; // Mặc định 'admin'
  isAdmin?: boolean; // Mặc định true
  email?: string; // Tùy chọn
  permissions?: string[]; // Tùy chọn
  language?: string; // Tùy chọn
  authProvider?: string; // Tùy chọn
}

// DTO cho tài khoản nhân viên (Employee)
export class CreateEmployeeDTO {
  username: string; // Bắt buộc
  password: string; // Bắt buộc
  fullName: string; // Bắt buộc
  phone: string; // Bắt buộc
  storeId: string; // Bắt buộc - ID cửa hàng
  role?: string; // Mặc định 'employee'
  isAdmin?: boolean; // Mặc định false
  email?: string; // Tùy chọn
  permissions?: string[]; // Tùy chọn
  language?: string; // Tùy chọn
  authProvider?: string; // Tùy chọn
}

export class UpdateUserDTO {
  username?: string;
  password?: string;
  fullName?: string;
  phone?: string;
  role?: string;
  storeId?: string;
  isAdmin?: boolean;
  email?: string;
  permissions?: string[];
  language?: string;
  authProvider?: string;
}

================
File: auth/guard/auth.guard.ts
================
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers.authorization;

    if (!authHeader) {
      throw new UnauthorizedException('Missing token');
    }

    try {
      const token = authHeader.split(' ')[1];
      const decoded = jwt.verify(token, 'your-secret-key') as { isAdmin: boolean };

      if (!decoded.isAdmin) {
        throw new ForbiddenException('Admin access required');
      }

      return true;
    } catch (error) {
      throw new UnauthorizedException('Invalid token');
    }
  }
}

================
File: auth/schemas/user.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Users' })
export class User extends Document {
  @Prop({ required: true, unique: true })
  userId: string;

  @Prop({ required: true, unique: true })
  username: string;

  @Prop({ required: true })
  password: string;

  @Prop({ required: true })
  fullName: string; // Họ tên

  @Prop({ required: true })
  phone: string; // Số điện thoại

  @Prop({ enum: ['admin', 'employee'], default: 'employee' })
  role: string; // Vai trò: admin (chủ cửa hàng) hoặc employee (nhân viên)

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Liên kết với cửa hàng

  @Prop({ default: false })
  isAdmin: boolean; // Chỉ tài khoản chính mới là true

  @Prop({ default: Date.now })
  createdAt: Date;

  // Các trường tùy chọn khác (từ gợi ý trước)
  @Prop({ match: /^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$/ })
  email?: string;

  @Prop({ type: [String], default: [] })
  permissions?: string[];

  @Prop({ default: 'vi' })
  language?: string;

  @Prop({ enum: ['local', 'google', 'facebook'], default: 'local' })
  authProvider?: string;
}

export const UserSchema = SchemaFactory.createForClass(User);

================
File: auth/services/user.service.ts
================
import { Injectable, ConflictException, UnauthorizedException, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as bcrypt from 'bcryptjs';
import * as jwt from 'jsonwebtoken';
import { User } from '../schemas/user.schema';

@Injectable()
export class UserService {
  constructor(
    @InjectModel('Users') private userModel: Model<User>,
  ) { }

  async create(createUserDto: any): Promise<User> {
    const existingUser = await this.userModel.findOne({ email: createUserDto.email });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }
  
    // Lấy userId lớn nhất từ database
    const lastUser = await this.userModel.findOne().sort({ userId: -1 }).exec();
    let newUserId = 'USR00001'; // Giá trị mặc định nếu chưa có user nào
  
    if (lastUser && lastUser.userId) {
      const lastNumber = parseInt(lastUser.userId.replace('USR', ''), 10);
      const nextNumber = lastNumber + 1;
      newUserId = `USR${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    const createdUser = new this.userModel({
      ...createUserDto,
      userId: newUserId,
      password: hashedPassword,
    });
  
    return createdUser.save();
  }
  

  async findAll(): Promise<User[]> {
    return this.userModel.find().exec();
  }

  async findOne(id: string): Promise<User> {
    const user = await this.userModel.findById(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async update(id: string, updateUserDto: any): Promise<User> {
    if (updateUserDto.password) {
      updateUserDto.password = await bcrypt.hash(updateUserDto.password, 10);
    }

    const user = await this.userModel
      .findByIdAndUpdate(id, updateUserDto, { new: true })
      .exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async remove(id: string): Promise<User> {
    const user = await this.userModel.findByIdAndDelete(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async login(email: string, password: string) {
    const user = await this.userModel.findOne({ email });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const token = jwt.sign(
      {
        userId: user._id,
        role: user.role
      },
      'your-secret-key',
      { expiresIn: '1h' }
    );

    return { token, user };
  }

  async register(registerDto: any) {
    const existingUser = await this.userModel.findOne({ email: registerDto.email });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // Lấy userId lớn nhất từ database
    const lastUser = await this.userModel.findOne().sort({ userId: -1 }).exec();
    let newUserId = 'USR0001'; // Giá trị mặc định nếu chưa có user nào
  
    if (lastUser && lastUser.userId) {
      const lastNumber = parseInt(lastUser.userId.replace('USR', ''), 10);
      const nextNumber = lastNumber + 1;
      newUserId = `USR${nextNumber.toString().padStart(4, '0')}`;
    }

    const hashedPassword = await bcrypt.hash(registerDto.password, 10);
    const user = new this.userModel({
      ...registerDto,
      userId: newUserId,
      password: hashedPassword,
    });
    await user.save();
    return { message: 'User registered successfully' };
  }
}

================
File: auth/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from './schemas/user.schema';
import { Branch, BranchSchema } from '../branch/schemas/branch.schema';
import { UserService } from './services/user.service';
import { UserController } from './controllers/user.controller';

@Module({
  imports: [
    // MongooseModule.forFeature([{ name: 'Users', schema: UserSchema }]),
    MongooseModule.forFeature([{ name: 'Users', schema: UserSchema }]),
    MongooseModule.forFeature([{ name: 'Branches', schema: BranchSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService]
})
export class UserModule { }

================
File: blog-categories/blog-categories.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BlogCategoriesSchema } from './schemas/blog-categories.schema';
import { BlogCategoriesController } from './controllers/blog-categories.controller';
import { BlogCategoriesService } from './services/blog-categories.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'BlogCategories', schema: BlogCategoriesSchema }]),
  ],
  controllers: [BlogCategoriesController],
  providers: [BlogCategoriesService],
  exports: [BlogCategoriesService]
})
export class BlogCategoriesModule { }

================
File: blog-categories/controllers/blog-categories.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { BlogCategoriesService } from '../services/blog-categories.service';
import { BlogCategories } from '../schemas/blog-categories.schema';

@Controller('api/blog-categories')
export class BlogCategoriesController {
  constructor(private readonly blogCategoriesService: BlogCategoriesService) { }

  @Post()
  async create(@Body() createBlogCategoriesDto: any): Promise<BlogCategories> {
    return this.blogCategoriesService.create(createBlogCategoriesDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<BlogCategories[]> {
    return this.blogCategoriesService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<BlogCategories> {
    return this.blogCategoriesService.findOne(id);
  }

  @Get(':slug')
  async findBySlug(@Param('slug') slug: string): Promise<BlogCategories> {
    return this.blogCategoriesService.findBySlug(slug);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateBlogCategoriesDto: any,
  ): Promise<BlogCategories> {
    return this.blogCategoriesService.update(id, updateBlogCategoriesDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<BlogCategories> {
    return this.blogCategoriesService.remove(id);
  }
}

================
File: blog-categories/dtos/blog-categories.dto.ts
================
export class BlogCategoriesDTO {
  storeId: string;
  name: string;
  slug: string;
  description: string;
  parentCategories: string;
  order: number;
  status: string;
  seo: { metaTitle: string; metaDescription: string };
  name_en: string; // Thêm
  description_en: string; // Thêm
}

export class CreateBlogCategoriesDTO {
  storeId: string;
  name: string;
  slug: string;
  description: string;
  parentCategories: string;
  order: number;
  status: string;
  seo: { metaTitle: string; metaDescription: string };
  name_en?: string; // Tùy chọn
  description_en?: string; // Tùy chọn
}

export class UpdateBlogCategoriesDTO {
  name?: string;
  slug?: string;
  description?: string;
  parentCategories?: string;
  order?: number;
  status?: string;
  seo?: { metaTitle?: string; metaDescription?: string };
  name_en?: string; // Tùy chọn
  description_en?: string; // Tùy chọn
}

================
File: blog-categories/schemas/blog-categories.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'BlogCategories' })
export class BlogCategories extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true, unique: true })
  slug: string;

  @Prop()
  description: string;

  @Prop({ type: Types.ObjectId, ref: 'BlogCategories' })
  parentCategory: Types.ObjectId;

  @Prop({ default: 0 })
  order: number;

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string;

  @Prop({ type: { metaTitle: String, metaDescription: String } })
  seo: { metaTitle: string; metaDescription: string };

  // Trường mới
  @Prop()
  name_en: string; // Tên tiếng Anh

  @Prop()
  description_en: string; // Mô tả tiếng Anh
}

export const BlogCategoriesSchema = SchemaFactory.createForClass(BlogCategories);

================
File: blog-categories/services/blog-categories.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BlogCategories } from '../schemas/blog-categories.schema';
import { CreateBlogCategoriesDTO, UpdateBlogCategoriesDTO } from '../dtos/blog-categories.dto';

@Injectable()
export class BlogCategoriesService {
  constructor(
    @InjectModel('BlogCategories')
    private blogCategoriesModel: Model<BlogCategories>,
  ) { }

  async create(createBlogCategoriesDto: CreateBlogCategoriesDTO): Promise<BlogCategories> {
    const created = new this.blogCategoriesModel(createBlogCategoriesDto);
    return created.save();
  }

  async findAll(query: any = {}): Promise<BlogCategories[]> {
    return this.blogCategoriesModel.find(query).exec();
  }

  async findOne(id: string): Promise<BlogCategories> {
    const categories = await this.blogCategoriesModel.findById(id).exec();
    if (!categories) {
      throw new NotFoundException(`Blog categories with ID ${id} not found`);
    }
    return categories;
  }

  async findBySlug(slug: string): Promise<BlogCategories> {
    const categories = await this.blogCategoriesModel.findOne({ slug }).exec();
    if (!categories) {
      throw new NotFoundException(`Blog categories with slug ${slug} not found`);
    }
    return categories;
  }

  async update(id: string, updateBlogCategoriesDto: UpdateBlogCategoriesDTO): Promise<BlogCategories> {
    const categories = await this.blogCategoriesModel
      .findByIdAndUpdate(id, updateBlogCategoriesDto, { new: true })
      .exec();
    if (!categories) {
      throw new NotFoundException(`Blog categories with ID ${id} not found`);
    }
    return categories;
  }

  async remove(id: string): Promise<BlogCategories> {
    const categories = await this.blogCategoriesModel.findByIdAndDelete(id).exec();
    if (!categories) {
      throw new NotFoundException(`Blog categories with ID ${id} not found`);
    }
    return categories;
  }
}

================
File: blog-post/blog-post.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BlogPostSchema } from './schemas/blog-post.schema';
import { BlogCategoriesController } from '../blog-categories/controllers/blog-categories.controller';
import { BlogPostService } from './services/blog-post.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'BlogPost', schema: BlogPostSchema }]),
  ],
  controllers: [BlogCategoriesController],
  providers: [BlogPostService],
  exports: [BlogPostService]
})
export class BlogPostModule { }

================
File: blog-post/controllers/blog-post.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { BlogPostService } from '../services/blog-post.service';
import { BlogPost } from '../schemas/blog-post.schema';
import { CreateBlogPostDTO, UpdateBlogPostDTO } from '../dtos/blog-category.dto';

@Controller('api/blog-posts')
export class BlogPostController {
  constructor(private readonly blogPostService: BlogPostService) { }

  @Post()
  async create(@Body() createBlogPostDto: CreateBlogPostDTO): Promise<BlogPost> {
    return this.blogPostService.create(createBlogPostDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<BlogPost[]> {
    return this.blogPostService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.findOne(id);
  }

  @Get(':slug')
  async findBySlug(@Param('slug') slug: string): Promise<BlogPost> {
    return this.blogPostService.findBySlug(slug);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateBlogPostDto: UpdateBlogPostDTO,
  ): Promise<BlogPost> {
    return this.blogPostService.update(id, updateBlogPostDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<BlogPost> {
    return this.blogPostService.update(id, { status });
  }

  @Post(':id/publish')
  async publish(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, {
      status: 'published',
      'settings.publishDate': new Date(),
    });
  }

  @Post(':id/archive')
  async archive(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { status: 'archived' });
  }

  @Post(':id/feature')
  async feature(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isFeatured': true });
  }

  @Post(':id/unfeature')
  async unfeature(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isFeatured': false });
  }

  @Post(':id/sticky')
  async makeSticky(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isSticky': true });
  }

  @Post(':id/unsticky')
  async removeSticky(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isSticky': false });
  }
}

================
File: blog-post/dtos/blog-category.dto.ts
================
export class BlogPostDTO {
  storeId: string;
  title: string;
  slug: string;
  category: string;
  thumbnail: string;
  content: string;
  excerpt: string;
  author: string;
  tags: string[];
  status: string;
  publishedAt: Date;
  views: number; // Thêm
  likes: number; // Thêm
  comments: { user: string; content: string; createdAt: Date }[]; // Thêm
  seo: { metaTitle: string; metaDescription: string; ogImage: string };
  title_en?: string;
}

export class CreateBlogPostDTO {
  storeId: string;
  title: string;
  slug: string;
  category: string;
  thumbnail: string;
  content: string;
  excerpt: string;
  author: string;
  tags: string[];
  status: string;
  publishedAt: Date;
  seo: { metaTitle: string; metaDescription: string; ogImage: string };
  title_en?: string;
}

export class UpdateBlogPostDTO {
  title?: string;
  slug?: string;
  category?: string;
  thumbnail?: string;
  content?: string;
  excerpt?: string;
  author?: string;
  tags?: string[];
  status?: string;
  publishedAt?: Date;
  seo?: { metaTitle?: string; metaDescription?: string; ogImage?: string };
  title_en?: string;
}

================
File: blog-post/schemas/blog-post.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'BlogPosts' })
export class BlogPost extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  title: string; // Tiêu đề

  @Prop({ required: true, unique: true })
  slug: string; // Đường dẫn tĩnh

  @Prop({ type: Types.ObjectId, ref: 'BlogCategories', required: true })
  category: Types.ObjectId; // Mã danh mục

  @Prop()
  thumbnail: string; // Ảnh đại diện

  @Prop({ required: true })
  content: string; // Nội dung

  @Prop()
  excerpt: string; // Đoạn trích

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  author: Types.ObjectId; // Mã tác giả

  @Prop({ type: [String], default: [] })
  tags: string[]; // Thẻ tag

  @Prop({ enum: ['draft', 'published', 'archived'], default: 'draft' })
  status: string; // Trạng thái

  @Prop()
  publishedAt: Date; // Thời gian xuất bản

  @Prop({ default: 0 })
  views: number; // Lượt xem

  @Prop({ default: 0 })
  likes: number; // Lượt thích

  @Prop({ type: [{ user: { type: Types.ObjectId, ref: 'Users' }, content: String, createdAt: Date }], default: [] })
  comments: { user: Types.ObjectId; content: string; createdAt: Date }[]; // Bình luận

  @Prop({ type: { metaTitle: String, metaDescription: String, ogImage: String } })
  seo: {
    metaTitle: string; // Tiêu đề SEO
    metaDescription: string; // Mô tả SEO
    ogImage: string; // Ảnh Open Graph
  };

  @Prop()
  title_en?: string; // Tiêu đề tiếng Anh
}

export const BlogPostSchema = SchemaFactory.createForClass(BlogPost);

================
File: blog-post/services/blog-post.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BlogPost } from '../schemas/blog-post.schema';

@Injectable()
export class BlogPostService {
  constructor(
    @InjectModel('BlogPost') private blogPostModel: Model<BlogPost>,
  ) { }

  async create(createBlogPostDto: any): Promise<BlogPost> {
    const createdPost = new this.blogPostModel(createBlogPostDto);
    return createdPost.save();
  }

  async findAll(query: any = {}): Promise<BlogPost[]> {
    return this.blogPostModel.find(query).exec();
  }

  async findOne(id: string): Promise<BlogPost> {
    const post = await this.blogPostModel.findById(id).exec();
    if (!post) {
      throw new NotFoundException(`Blog post with ID ${id} not found`);
    }
    return post;
  }

  async findBySlug(slug: string): Promise<BlogPost> {
    const post = await this.blogPostModel.findOne({ slug }).exec();
    if (!post) {
      throw new NotFoundException(`Blog post with slug ${slug} not found`);
    }
    return post;
  }

  async update(id: string, updateBlogPostDto: any): Promise<BlogPost> {
    const post = await this.blogPostModel
      .findByIdAndUpdate(id, updateBlogPostDto, { new: true })
      .exec();
    if (!post) {
      throw new NotFoundException(`Blog post with ID ${id} not found`);
    }
    return post;
  }

  async remove(id: string): Promise<BlogPost> {
    const post = await this.blogPostModel.findByIdAndDelete(id).exec();
    if (!post) {
      throw new NotFoundException(`Blog post with ID ${id} not found`);
    }
    return post;
  }

}

================
File: branch/branch.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BranchController } from './controllers/branch.controller';
import { BranchService } from './services/branch.service';
import { Branch, BranchSchema } from './schemas/branch.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Branches', schema: BranchSchema }])
  ],
  controllers: [BranchController],
  providers: [BranchService],
  exports: [BranchService]
})
export class BranchModule { }

================
File: branch/controllers/branch.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BranchService } from '../services/branch.service';
import { Branch } from '../schemas/branch.schema';
import { CreateBranchDTO, UpdateBranchDTO } from '../dtos/branch.dto';

@Controller('api/branches')
export class BranchController {
  constructor(private readonly branchService: BranchService) { }

  @Post()
  async create(@Body() createBranchDto: CreateBranchDTO): Promise<Branch> {
    return this.branchService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.branchService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.branchService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBranchDto: UpdateBranchDTO) {
    return this.branchService.update(id, updateBranchDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.branchService.remove(id);
  }
}

================
File: branch/dtos/branch.dto.ts
================
export class BranchDTO {
  name: string;
  location: string;
  createdAt: Date;
  updatedAt: Date;
  managerId: string; // Thêm
  warehouseId: string; // Thêm
}

export class CreateBranchDTO {
  name: string;
  location: string;
  managerId?: string; // Tùy chọn
  warehouseId?: string; // Tùy chọn
}

export class UpdateBranchDTO {
  name?: string;
  location?: string;
  managerId?: string; // Tùy chọn
  warehouseId?: string; // Tùy chọn
}

================
File: branch/schemas/branch.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Branches' })
export class Branch extends Document {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  location: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop({ default: Date.now })
  updatedAt: Date;

  // Trường mới
  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  managerId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Warehouses' })
  warehouseId: Types.ObjectId;
}

export const BranchSchema = SchemaFactory.createForClass(Branch);

================
File: branch/services/branch.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Branch } from '../schemas/branch.schema';
import { CreateBranchDTO, UpdateBranchDTO } from '../dtos/branch.dto';

@Injectable()
export class BranchService {
  constructor(
    @InjectModel('Branches') private branchModel: Model<Branch>,
  ) { }

  async create(createBranchDto: CreateBranchDTO): Promise<Branch> {
    const createdBranch = new this.branchModel(createBranchDto);
    return createdBranch.save();
  }

  async findAll(): Promise<Branch[]> {
    return this.branchModel.find().exec();
  }

  async findOne(id: string): Promise<Branch> {
    const branch = await this.branchModel.findById(id).exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }

  async update(id: string, updateBranchDto: UpdateBranchDTO): Promise<Branch> {
    const branch = await this.branchModel
      .findByIdAndUpdate(id, updateBranchDto, { new: true })
      .exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }

  async remove(id: string): Promise<Branch> {
    const branch = await this.branchModel.findByIdAndDelete(id).exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }
}

================
File: brand/brand.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BrandController } from './controllers/brand.controller';
import { BrandService } from './services/brand.service';
import { BrandSchema } from './schemas/brand.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Brands', schema: BrandSchema }])
  ],
  controllers: [BrandController],
  providers: [BrandService],
  exports: [BrandService]
})
export class BrandModule { }

================
File: brand/controllers/brand.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BrandService } from '../services/brand.service';
import { Brand } from '../schemas/brand.schema';
import { CreateBrandDTO, UpdateBrandDTO } from '../dtos/brand.dto';

@Controller('api/brands')
export class BrandController {
  constructor(private readonly brandService: BrandService) { }

  @Post()
  async create(@Body() createBranchDto: CreateBrandDTO): Promise<Brand> {
    return this.brandService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.brandService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.brandService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: UpdateBrandDTO) {
    return this.brandService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.brandService.remove(id);
  }
}

================
File: brand/dtos/brand.dto.ts
================
export class BrandDTO {
  brandId: string;
  name: string;
  createdAt: Date;
  logo: string; // Thêm
  description: string; // Thêm
}

export class CreateBrandDTO {
  name: string;
  logo?: string; // Tùy chọn
  description?: string; // Tùy chọn
}

export class UpdateBrandDTO {
  name?: string;
  logo?: string; // Tùy chọn
  description?: string; // Tùy chọn
}

================
File: brand/schemas/brand.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Brands' })
export class Brand extends Document {
  @Prop({ unique: true, required: true })
  brandId: string;

  @Prop({ required: true })
  name: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  // Trường mới
  @Prop()
  logo: string;

  @Prop()
  description: string;
}

export const BrandSchema = SchemaFactory.createForClass(Brand);

================
File: brand/services/brand.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Brand } from '../schemas/brand.schema';
import { CreateBrandDTO, UpdateBrandDTO } from '../dtos/brand.dto';

@Injectable()
export class BrandService {
  constructor(
    @InjectModel('Brands') private brandModel: Model<Brand>,
  ) { }

  async create(createBrandDto: CreateBrandDTO): Promise<Brand> {
    const lastBrand = await this.brandModel.findOne().sort({ brandId: -1 }).exec();
    let newBrandId = 'BR00001';

    if (lastBrand && lastBrand.brandId) {
      const lastNumber = parseInt(lastBrand.brandId.replace('BR', ''), 10);
      const nextNumber = lastNumber + 1;
      newBrandId = `BR${nextNumber.toString().padStart(5, '0')}`;
    }

    const createdBrand = new this.brandModel({
      ...createBrandDto,
      brandId: newBrandId
    });

    return createdBrand.save();
  }

  async findAll(): Promise<Brand[]> {
    return this.brandModel.find().exec();
  }

  async findOne(id: string): Promise<Brand> {
    const brand = await this.brandModel.findById(id).exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }

  async update(id: string, updateBrandDto: UpdateBrandDTO): Promise<Brand> {
    const brand = await this.brandModel
      .findByIdAndUpdate(id, updateBrandDto, { new: true })
      .exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }

  async remove(id: string): Promise<Brand> {
    const brand = await this.brandModel.findByIdAndDelete(id).exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }
}

================
File: carrier-group/carrier-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CarrierGroup, CarrierGroupSchema } from './schemas/carrier-group.schema';
import { CarrierGroupController } from './controllers/carrier-group.controller';
import { CarrierGroupService } from './services/carrier-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CarrierGroups', schema: CarrierGroupSchema }])
  ],
  controllers: [CarrierGroupController],
  providers: [CarrierGroupService],
  exports: [CarrierGroupService]
})
export class CarrierGroupModule { }

================
File: carrier-group/controllers/carrier-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CarrierGroupService } from '../services/carrier-group.service';
import { CarrierGroup } from '../schemas/carrier-group.schema';
import { CreateCarrierGroupDTO, UpdateCarrierGroupDTO } from '../dtos/carrier-group.dto';

@Controller('api/carriers-groups')
export class CarrierGroupController {
  constructor(private readonly carriersService: CarrierGroupService) { }

  @Post()
  async create(@Body() createCarrierGroupDto: CreateCarrierGroupDTO): Promise<CarrierGroup> {
    return this.carriersService.create(createCarrierGroupDto);
  }

  @Get()
  findAll() {
    return this.carriersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.carriersService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCarrierGroupDto: UpdateCarrierGroupDTO) {
    return this.carriersService.update(id, updateCarrierGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.carriersService.remove(id);
  }
}

================
File: carrier-group/dtos/carrier-group.dto.ts
================
// CarrierGroupDTO: Đại diện toàn bộ schema
export class CarrierGroupDTO {
    groupId: string; // Mã nhóm
    name: string; // Tên nhóm
    description: string; // Mô tả
    createdAt: Date; // Thời gian tạo
  }
  
  // CreateCarrierGroupDTO: Dùng để tạo mới
  export class CreateCarrierGroupDTO {
    name: string; // Tên nhóm
    description: string; // Mô tả
  }
  
  // UpdateCarrierGroupDTO: Dùng để cập nhật
  export class UpdateCarrierGroupDTO {
    name?: string; // Tên nhóm
    description?: string; // Mô tả
  }

================
File: carrier-group/schemas/carrier-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'CarrierGroups' })
export class CarrierGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string; // Mã nhóm đơn vị vận chuyển

  @Prop({ required: true })
  name: string; // Tên nhóm

  @Prop()
  description: string; // Mô tả

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CarrierGroupSchema = SchemaFactory.createForClass(CarrierGroup);

================
File: carrier-group/services/carrier-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CarrierGroup } from '../schemas/carrier-group.schema';
import { CreateCarrierGroupDTO, UpdateCarrierGroupDTO } from '../dtos/carrier-group.dto';

@Injectable()
export class CarrierGroupService {
  constructor(
    @InjectModel('CarrierGroups') private carrierGroupModel: Model<CarrierGroup>,
  ) { }

  async create(createCarrierGroupDto: CreateCarrierGroupDTO): Promise<CarrierGroup> {
    const lastCarrierGroup = await this.carrierGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newCarrierGroupId = 'CG00001';
  
    if (lastCarrierGroup && lastCarrierGroup.groupId) {
      const lastNumber = parseInt(lastCarrierGroup.groupId.replace('CG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCarrierGroupId = `CG${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdCarrierGroup = new this.carrierGroupModel({
      ...createCarrierGroupDto,
      carrierGroupId: newCarrierGroupId
    });
  
    return createdCarrierGroup.save();
  }

  async findAll(): Promise<CarrierGroup[]> {
    return this.carrierGroupModel.find().exec();
  }

  async findOne(id: string): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel.findById(id).exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }

  async update(id: string, updateCarrierGroupDto: UpdateCarrierGroupDTO): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel
      .findByIdAndUpdate(id, updateCarrierGroupDto, { new: true })
      .exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }

  async remove(id: string): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel.findByIdAndDelete(id).exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }
}

================
File: carrier/carrier.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Carrier, CarrierSchema } from './schemas/carrier.schema';
import { CarrierService } from './services/carrier.service';
import { CarrierController } from './controllers/carrier.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Carriers', schema: CarrierSchema }])
  ],
  controllers: [CarrierController],
  providers: [CarrierService],
  exports: [CarrierService]
})
export class CarrierModule { }

================
File: carrier/controllers/carrier.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CarrierService } from '../services/carrier.service';
import { CreateCarrierDTO, UpdateCarrierDTO } from '../dtos/carrier.dto';

@Controller('api/carriers')
export class CarrierController {
  constructor(private readonly carrierService: CarrierService) { }
  @Post()
  create(@Body() createCarrierDto: CreateCarrierDTO) {
    return this.carrierService.create(createCarrierDto);
  }
  @Get()
  findAll() {
    return this.carrierService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.carrierService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCarrierDto: UpdateCarrierDTO) {
    return this.carrierService.update(id, updateCarrierDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.carrierService.remove(id);
  }
}

================
File: carrier/dtos/carrier.dto.ts
================
// CarrierDTO: Đại diện toàn bộ schema
export class CarrierDTO {
    carrierId: string; // Mã đơn vị vận chuyển
    name: string; // Tên
    phone: string; // Số điện thoại
    email: string; // Email
    address: string; // Địa chỉ
    group: string; // Mã nhóm
    totalOrders: number; // Tổng đơn hàng
    totalFees: number; // Tổng phí
    status: string; // Trạng thái
    createdAt: Date; // Thời gian tạo
    updatedAt: Date; // Thời gian cập nhật
  }
  
  // CreateCarrierDTO: Dùng để tạo mới
  export class CreateCarrierDTO {
    name: string; // Tên
    phone: string; // Số điện thoại
    email: string; // Email
    address: string; // Địa chỉ
    group: string; // Mã nhóm
    status: string; // Trạng thái
  }
  
  // UpdateCarrierDTO: Dùng để cập nhật
  export class UpdateCarrierDTO {
    name?: string; // Tên
    phone?: string; // Số điện thoại
    email?: string; // Email
    address?: string; // Địa chỉ
    group?: string; // Mã nhóm
    status?: string; // Trạng thái
  }

================
File: carrier/schemas/carrier.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Carriers' })
export class Carrier extends Document {
  @Prop({ unique: true, required: true })
  carrierId: string; // Mã đơn vị vận chuyển

  @Prop({ required: true })
  name: string; // Tên đơn vị vận chuyển

  @Prop()
  phone: string; // Số điện thoại

  @Prop()
  email: string; // Email

  @Prop()
  address: string; // Địa chỉ

  @Prop({ type: Types.ObjectId, ref: 'CarrierGroups' })
  group: Types.ObjectId; // Mã nhóm đơn vị vận chuyển

  @Prop({ default: 0 })
  totalOrders: number; // Tổng số đơn hàng

  @Prop({ default: 0 })
  totalFees: number; // Tổng phí vận chuyển

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo

  @Prop({ default: Date.now })
  updatedAt: Date; // Thời gian cập nhật
}

export const CarrierSchema = SchemaFactory.createForClass(Carrier);

================
File: carrier/services/carrier.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Carrier } from '../schemas/carrier.schema';
import { CreateCarrierDTO, UpdateCarrierDTO } from '../dtos/carrier.dto';

@Injectable()
export class CarrierService {
  constructor(@InjectModel('Carriers') private CarrierModel: Model<Carrier>) { }

  async create(createCarrierDto: CreateCarrierDTO): Promise<Carrier> {
    const lastCarrier = await this.CarrierModel.findOne().sort({ carrierId: -1 }).exec();
    let newCarrierId = 'CG00001';

    if (lastCarrier && lastCarrier.carrierId) {
      const lastNumber = parseInt(lastCarrier.carrierId.replace('CG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCarrierId = `CG${nextNumber.toString().padStart(5, '0')}`;
    }

    const createdCarrier = new this.CarrierModel({
      ...createCarrierDto,
      carrierId: newCarrierId
    });

    return createdCarrier.save();
  }
  async findAll(): Promise<Carrier[]> {
    return this.CarrierModel.find().exec();
  }

  async findOne(id: string): Promise<Carrier> {
    const brand = await this.CarrierModel.findById(id).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }

  async update(id: string, updateBrandDto: UpdateCarrierDTO): Promise<Carrier> {
    const brand = await this.CarrierModel.findByIdAndUpdate(
      id,
      updateBrandDto,
      { new: true },
    ).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }

  async remove(id: string): Promise<Carrier> {
    const brand = await this.CarrierModel.findByIdAndDelete(id).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }
}

================
File: cash-book/cash-book.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CashBookController } from './controllers/cash-book.controller';
import { CashBookService } from './services/cash-book.service';
import { CashBookSchema } from './schemas/cash-book.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CashBooks', schema: CashBookSchema }])
  ],
  controllers: [CashBookController],
  providers: [CashBookService],
  exports: [CashBookService]
})
export class CashBookModule { }

================
File: cash-book/controllers/cash-book.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { CashBookService } from '../services/cash-book.service';
import { CashBook } from '../schemas/cash-book.schema';
import { CreateCashBookDTO, UpdateCashBookDTO } from '../dtos/cash-book.dto';

@Controller('api/cash-books')
export class CashBookController {
  constructor(private readonly cashBookService: CashBookService) { }

  @Post()
  async create(@Body() createCashBookDto: CreateCashBookDTO): Promise<CashBook> {
    return this.cashBookService.create(createCashBookDto);
  }

  @Get()
  async findAll(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('type') type?: string
  ): Promise<CashBook[]> {
    return this.cashBookService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<CashBook> {
    return this.cashBookService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateCashBookDto: UpdateCashBookDTO,
  ): Promise<CashBook> {
    return this.cashBookService.update(id, updateCashBookDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<CashBook> {
    return this.cashBookService.remove(id);
  }

  @Put(':id/approve')
  async approve(@Param('id') id: string): Promise<CashBook> {
    const updateDto = { status: 'approved' };
    return this.cashBookService.update(id, updateDto);
  }

  @Put(':id/reject')
  async reject(@Param('id') id: string): Promise<CashBook> {
    const updateDto = { status: 'rejected' };
    return this.cashBookService.update(id, updateDto);
  }
}

================
File: cash-book/dtos/cash-book.dto.ts
================
// CashBookDTO: Đại diện toàn bộ schema
export class CashBookDTO {
    cashBookId: string; // Mã sổ quỹ
    storeId: string; // Mã cửa hàng
    type: string; // Loại giao dịch
    category: string; // Danh mục
    amount: number; // Số tiền
    paymentMethod: string; // Phương thức thanh toán
    reference: string; // Tham chiếu
    referenceId: string; // Mã tham chiếu
    description: string; // Mô tả
    date: Date; // Ngày giao dịch
    employeeId: string; // Mã nhân viên
    attachments: string[]; // Tệp đính kèm
    status: string; // Trạng thái
    notes: string; // Ghi chú
  }
  
  // CreateCashBookDTO: Dùng để tạo mới
  export class CreateCashBookDTO {
    storeId: string; // Mã cửa hàng
    type: string; // Loại giao dịch
    category: string; // Danh mục
    amount: number; // Số tiền
    paymentMethod: string; // Phương thức thanh toán
    reference: string; // Tham chiếu
    referenceId: string; // Mã tham chiếu
    description: string; // Mô tả
    date: Date; // Ngày giao dịch
    employeeId: string; // Mã nhân viên
    attachments: string[]; // Tệp đính kèm
    status: string; // Trạng thái
    notes: string; // Ghi chú
  }
  
  // UpdateCashBookDTO: Dùng để cập nhật
  export class UpdateCashBookDTO {
    type?: string; // Loại giao dịch
    category?: string; // Danh mục
    amount?: number; // Số tiền
    paymentMethod?: string; // Phương thức thanh toán
    reference?: string; // Tham chiếu
    referenceId?: string; // Mã tham chiếu
    description?: string; // Mô tả
    date?: Date; // Ngày giao dịch
    employeeId?: string; // Mã nhân viên
    attachments?: string[]; // Tệp đính kèm
    status?: string; // Trạng thái
    notes?: string; // Ghi chú
  }

================
File: cash-book/schemas/cash-book.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'CashBooks' })
export class CashBook extends Document {
  @Prop({ unique: true, required: true })
  cashBookId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ enum: ['Thu', 'Chi'], required: true })
  type: string;

  @Prop({
    enum: [
      'Thu từ bán hàng',
      'Thu từ khác',
      'Chi mua hàng',
      'Chi lương',
      'Chi vận chuyển',
      'Chi marketing',
      'Chi khác',
    ],
    required: true,
  })
  category: string;

  @Prop({ required: true })
  amount: number;

  @Prop({
    enum: ['Tiền mặt', 'Chuyển khoản', 'Thẻ tín dụng', 'Ví điện tử'],
    required: true,
  })
  paymentMethod: string;

  @Prop({
    enum: ['Đơn hàng', 'Hóa đơn', 'Phiếu nhập', 'Phiếu xuất', 'Khác'],
    required: true,
  })
  reference: string;

  @Prop({ type: Types.ObjectId, ref: 'Orders' })
  referenceId: Types.ObjectId;

  @Prop()
  description: string;

  @Prop({ required: true, default: Date.now })
  date: Date;

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId;

  @Prop([String])
  attachments: string[];

  @Prop({ enum: ['Đã xác nhận', 'Chờ xác nhận', 'Đã hủy'], default: 'Chờ xác nhận' })
  status: string;

  @Prop()
  notes: string;
}

export const CashBookSchema = SchemaFactory.createForClass(CashBook);

================
File: cash-book/services/cash-book.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CashBook } from '../schemas/cash-book.schema';
import { CreateCashBookDTO, UpdateCashBookDTO } from '../dtos/cash-book.dto';

@Injectable()
export class CashBookService {
  constructor(
    @InjectModel('CashBooks') private cashBookModel: Model<CashBook>,
  ) { }

  async create(createCashBookDto: CreateCashBookDTO): Promise<CashBook> {
    const lastCashBook = await this.cashBookModel.findOne().sort({ cashBookId: -1 }).exec();
    let newCashBookId = 'CB00001';
  
    if (lastCashBook && lastCashBook.cashBookId) {
      const lastNumber = parseInt(lastCashBook.cashBookId.replace('CB', ''), 10);
      const nextNumber = lastNumber + 1;
      newCashBookId = `CB${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdCashBook = new this.cashBookModel({
      ...createCashBookDto,
      cashBookId: newCashBookId
    });
  
    return createdCashBook.save();
  }

  async findAll(): Promise<CashBook[]> {
    return this.cashBookModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
  }

  async findOne(id: string): Promise<CashBook> {
    const cashBook = await this.cashBookModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }

  async update(id: string, updateCashBookDto: UpdateCashBookDTO): Promise<CashBook> {
    const cashBook = await this.cashBookModel
      .findByIdAndUpdate(id, updateCashBookDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }

  async remove(id: string): Promise<CashBook> {
    const cashBook = await this.cashBookModel.findByIdAndDelete(id).exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }
}

================
File: categories/categories.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CategoriesController } from './controllers/categories.controller';
import { CategoriesService } from './services/categories.service';
import { Categories, CategoriesSchema } from './schemas/categories.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Categories', schema: CategoriesSchema }])
  ],
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService]
})
export class CategoriesModule { }

================
File: categories/controllers/categories.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CategoriesService } from '../services/categories.service';
import { CreateCategoriesDTO, UpdateCategoriesDTO } from '../dtos/categories.dto';

@Controller('api/categories')
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) { }

  @Post()
  create(@Body() createCategoriesDto: CreateCategoriesDTO) {
    return this.categoriesService.create(createCategoriesDto);
  }

  @Get()
  findAll() {
    return this.categoriesService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.categoriesService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCategoriesDto: UpdateCategoriesDTO) {
    return this.categoriesService.update(id, updateCategoriesDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.categoriesService.remove(id);
  }
}

================
File: categories/dtos/categories.dto.ts
================
// CategoriesDTO: Đại diện toàn bộ schema
export class CategoriesDTO {
  categoryId: string; // Mã danh mục
  name: string; // Tên danh mục
  parentCategory: string; // Mã danh mục cha
  createdAt: Date; // Thời gian tạo
}

// CreateCategoriesDTO: Dùng để tạo mới
export class CreateCategoriesDTO {
  name: string; // Tên danh mục
  parentCategory: string; // Mã danh mục cha
}

// UpdateCategoriesDTO: Dùng để cập nhật
export class UpdateCategoriesDTO {
  name?: string; // Tên danh mục
  parentCategory?: string; // Mã danh mục cha
}

================
File: categories/schemas/categories.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Categories' })
export class Categories extends Document {
  @Prop({ unique: true, required: true })
  categoryId: string; // Mã danh mục

  @Prop({ required: true })
  name: string; // Tên danh mục

  @Prop({ type: Types.ObjectId, ref: 'Categories' })
  parentCategory: Types.ObjectId; // Mã danh mục cha

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CategoriesSchema = SchemaFactory.createForClass(Categories);

================
File: categories/services/categories.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Categories } from '../schemas/categories.schema';
import { CreateCategoriesDTO, UpdateCategoriesDTO } from '../dtos/categories.dto';

@Injectable()
export class CategoriesService {
  constructor(
    @InjectModel('Categories') private categoriesModel: Model<Categories>,
  ) { }

  async create(createCategoriesDto: CreateCategoriesDTO): Promise<Categories> {
    const lastCategories = await this.categoriesModel.findOne().sort({ categoryId: -1 }).exec();
    let newCategoryId = 'CT00001';
  
    if (lastCategories && lastCategories.categoryId) {
      const lastNumber = parseInt(lastCategories.categoryId.replace('CT', ''), 10);
      const nextNumber = lastNumber + 1;
      newCategoryId = `CT${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdCategories = new this.categoriesModel({
      ...createCategoriesDto,
      categoryId: newCategoryId
    });
  
    return createdCategories.save();
  }

  async findAll(): Promise<Categories[]> {
    return this.categoriesModel.find().populate('parentCategory').exec();
  }

  async findOne(id: string): Promise<Categories> {
    const category = await this.categoriesModel.findById(id).populate('parentCategory').exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async update(id: string, updateCategoriesDto: UpdateCategoriesDTO): Promise<Categories> {
    const category = await this.categoriesModel
      .findByIdAndUpdate(id, updateCategoriesDto, { new: true })
      .populate('parentCategory')
      .exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async remove(id: string): Promise<Categories> {
    const category = await this.categoriesModel.findByIdAndDelete(id).exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }
}

================
File: commission-setting/commission-setting.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CommissionSetting, CommissionSettingSchema } from './schemas/commission-setting.schema';
import { CommissionSettingController } from './controllers/commission-setting.controller';
import { CommissionSettingService } from './services/commission-setting.service';


@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CommissionSettings', schema: CommissionSettingSchema }])
  ],
  controllers: [CommissionSettingController],
  providers: [CommissionSettingService],
  exports: [CommissionSettingService]
})
export class CommissionSettingModule { }

================
File: commission-setting/controllers/commission-setting.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CommissionSettingService } from '../services/commission-setting.service';
import { CommissionSetting } from '../schemas/commission-setting.schema';
import { CreateCommissionSettingDTO } from '../dtos/commisson-setting.dto';

@Controller('api/commission-settings')
export class CommissionSettingController {
  constructor(private readonly commissionSettingService: CommissionSettingService) { }

  @Post()
  async create(@Body() createCommissionSettingDto: CreateCommissionSettingDTO): Promise<CommissionSetting> {
    return this.commissionSettingService.create(createCommissionSettingDto);
  }

  @Get()
  findAll() {
    return this.commissionSettingService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.commissionSettingService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() createCommissionSettingDto: CreateCommissionSettingDTO) {
    return this.commissionSettingService.update(id, createCommissionSettingDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.commissionSettingService.remove(id);
  }
}

================
File: commission-setting/dtos/commisson-setting.dto.ts
================
// CommissionSettingDTO: Đại diện toàn bộ schema
export class CommissionSettingDTO {
  commissionId: string; // Mã thiết lập
  name: string; // Tên thiết lập
  scope: string; // Phạm vi
  branchId: string; // Mã chi nhánh
  status: string; // Trạng thái
  details: { productId: string; rate: number }[]; // Chi tiết hoa hồng
  createdAt: Date; // Thời gian tạo
}

// CreateCommissionSettingDTO: Dùng để tạo mới
export class CreateCommissionSettingDTO {
  name: string; // Tên thiết lập
  scope: string; // Phạm vi
  branchId: string; // Mã chi nhánh
  status: string; // Trạng thái
  details: { productId: string; rate: number }[]; // Chi tiết hoa hồng
}

// UpdateCommissionSettingDTO: Dùng để cập nhật
export class UpdateCommissionSettingDTO {
  name?: string; // Tên thiết lập
  scope?: string; // Phạm vi
  branchId?: string; // Mã chi nhánh
  status?: string; // Trạng thái
  details?: { productId: string; rate: number }[]; // Chi tiết hoa hồng
}

================
File: commission-setting/schemas/commission-setting.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'CommissionSettings' })
export class CommissionSetting extends Document {
  @Prop({ unique: true, required: true })
  commissionId: string; // Mã thiết lập hoa hồng

  @Prop({ required: true })
  name: string; // Tên thiết lập

  @Prop({ enum: ['global', 'branch'], required: true })
  scope: string; // Phạm vi áp dụng

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branchId: Types.ObjectId; // Mã chi nhánh

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ type: [{ productId: Types.ObjectId, rate: Number }] })
  details: { productId: Types.ObjectId; rate: number }[]; // Chi tiết hoa hồng

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CommissionSettingSchema = SchemaFactory.createForClass(CommissionSetting);

================
File: commission-setting/services/commission-setting.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { CommissionSetting } from '../schemas/commission-setting.schema';
import { CreateCommissionSettingDTO } from '../dtos/commisson-setting.dto';

@Injectable()
export class CommissionSettingService {
  constructor(
    @InjectModel('CommissionSettings')
    private commissionSettingModel: Model<CommissionSetting>,
  ) {}

  async create(createCommissionSettingDto: CreateCommissionSettingDTO): Promise<CommissionSetting> {
    // Convert string IDs to ObjectIds in details array
    if (createCommissionSettingDto.details) {
      createCommissionSettingDto.details = createCommissionSettingDto.details.map((detail) => ({
        ...detail,
        productId: detail.productId.toString()
      }));
    }

    const lastCommissionSetting = await this.commissionSettingModel
      .findOne()
      .sort({ commissionId: -1 })
      .exec();
    let newCommissionSettingId = 'CMS00001';

    if (lastCommissionSetting && lastCommissionSetting.commissionId) {
      const lastNumber = parseInt(
        lastCommissionSetting.commissionId.replace('CMS', ''),
        10,
      );
      const nextNumber = lastNumber + 1;
      newCommissionSettingId = `CMS${nextNumber.toString().padStart(5, '0')}`;
    }

    const createdCommissionSetting = new this.commissionSettingModel({
      ...createCommissionSettingDto,
      commissionId: newCommissionSettingId,
    });

    return createdCommissionSetting.save();
  }

  async findAll(): Promise<CommissionSetting[]> {
    return this.commissionSettingModel.find().exec();
  }

  async findOne(id: string): Promise<CommissionSetting> {
    const commissionSetting = await this.commissionSettingModel
      .findById(id)
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }

  async update(
    id: string,
    updateCommissionSettingDto: CreateCommissionSettingDTO,
  ): Promise<CommissionSetting> {
    // Convert string IDs to ObjectIds in details array if present
    if (updateCommissionSettingDto.details) {
      updateCommissionSettingDto.details =
        updateCommissionSettingDto.details.map((detail) => ({
          ...detail,
          productId: detail.productId.toString()
        }));
    }

    const commissionSetting = await this.commissionSettingModel
      .findByIdAndUpdate(id, updateCommissionSettingDto, { new: true })
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }

  async remove(id: string): Promise<CommissionSetting> {
    const commissionSetting = await this.commissionSettingModel
      .findByIdAndDelete(id)
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }
}

================
File: customer-group/controllers/customer-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerGroupService } from '../services/customer-group.service';
import { CreateCustomerGroupDTO, UpdateCustomerGroupDTO } from '../dtos/customer-group.dto';

@Controller('api/customer-groups')
export class CustomerGroupController {
  constructor(private readonly customerGroupService: CustomerGroupService) { }

  @Post()
  create(@Body() createCustomerGroupDto: CreateCustomerGroupDTO) {
    return this.customerGroupService.create(createCustomerGroupDto);
  }

  @Get()
  findAll() {
    return this.customerGroupService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerGroupService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerGroupDto: UpdateCustomerGroupDTO) {
    return this.customerGroupService.update(id, updateCustomerGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerGroupService.remove(id);
  }
}

================
File: customer-group/customer-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerGroupSchema } from './schemas/customer-group.schema';
import { CustomerGroupController } from './controllers/customer-group.controller';
import { CustomerGroupService } from './services/customer-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CustomerGroups', schema: CustomerGroupSchema }])
  ],
  controllers: [CustomerGroupController],
  providers: [CustomerGroupService],
  exports: [CustomerGroupService]
})
export class CustomerModule { }

================
File: customer-group/dtos/customer-group.dto.ts
================
// CustomerGroupDTO: Đại diện toàn bộ schema
export class CustomerGroupDTO {
  groupId: string; // Mã nhóm
  name: string; // Tên nhóm
  discountType: string; // Loại chiết khấu
  discountValue: number; // Giá trị chiết khấu
  description: string; // Mô tả
  createdAt: Date; // Thời gian tạo
}

// CreateCustomerGroupDTO: Dùng để tạo mới
export class CreateCustomerGroupDTO {
  name: string; // Tên nhóm
  discountType: string; // Loại chiết khấu
  discountValue: number; // Giá trị chiết khấu
  description: string; // Mô tả
}

// UpdateCustomerGroupDTO: Dùng để cập nhật
export class UpdateCustomerGroupDTO {
  name?: string; // Tên nhóm
  discountType?: string; // Loại chiết khấu
  discountValue?: number; // Giá trị chiết khấu
  description?: string; // Mô tả
}

================
File: customer-group/schemas/customer-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'CustomerGroups' })
export class CustomerGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string; // Mã nhóm khách hàng

  @Prop({ required: true })
  name: string; // Tên nhóm

  @Prop({ enum: ['VND', '%'], required: true })
  discountType: string; // Loại chiết khấu

  @Prop({ required: true })
  discountValue: number; // Giá trị chiết khấu

  @Prop()
  description: string; // Mô tả

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CustomerGroupSchema = SchemaFactory.createForClass(CustomerGroup);

================
File: customer-group/services/customer-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CustomerGroup } from '../schemas/customer-group.schema';
import { CreateCustomerGroupDTO, UpdateCustomerGroupDTO } from '../dtos/customer-group.dto';
@Injectable()
export class CustomerGroupService {
  constructor(
    @InjectModel('CustomerGroups') private customerGroupModel: Model<CustomerGroup>,
  ) { }

  async create(createCustomerGroupDto: CreateCustomerGroupDTO): Promise<CustomerGroup> {
    const lastCustomerGroup = await this.customerGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newCustomerGroupId = 'KHG00001';
  
    if (lastCustomerGroup && lastCustomerGroup.groupId) {
      const lastNumber = parseInt(lastCustomerGroup.groupId.replace('KHG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCustomerGroupId = `KHG${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdCustomerGroup = new this.customerGroupModel({
      ...createCustomerGroupDto,
      groupId: newCustomerGroupId
    });
  
    return createdCustomerGroup.save();
  }

  async findAll(): Promise<CustomerGroup[]> {
    return this.customerGroupModel.find().exec();
  }

  async findOne(id: string): Promise<CustomerGroup> {
    const customerGroup = await this.customerGroupModel.findById(id).exec();
    if (!customerGroup) {
      throw new NotFoundException(`CustomerGroup with ID ${id} not found`);
    }
    return customerGroup;
  }

  async update(id: string, updateCustomerGroupDto: UpdateCustomerGroupDTO): Promise<CustomerGroup> {
    const customerGroup = await this.customerGroupModel
      .findByIdAndUpdate(id, updateCustomerGroupDto, { new: true })
      .exec();
    if (!customerGroup) {
      throw new NotFoundException(`CustomerGroup with ID ${id} not found`);
    }
    return customerGroup;
  }

  async remove(id: string): Promise<CustomerGroup> {
    const customerGroup = await this.customerGroupModel.findByIdAndDelete(id).exec();
    if (!customerGroup) {
      throw new NotFoundException(`CustomerGroup with ID ${id} not found`);
    }
    return customerGroup;
  }
}

================
File: customer-loyalty-point/controllers/customer-loyalty-points.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerLoyaltyPointsService } from '../services/customer-loyalty-points.service';
import { CreateCustomerLoyaltyPointsDTO, UpdateCustomerLoyaltyPointsDTO } from '../dtos/customer-loyalty-point.dto';

@Controller('api/customer-loyalty-points')
export class CustomerLoyaltyPointsController {
  constructor(private readonly customerLoyaltyPointsService: CustomerLoyaltyPointsService) { }

  @Post()
  create(@Body() customerLoyaltyPointsService: CreateCustomerLoyaltyPointsDTO) {
    return this.customerLoyaltyPointsService.create(customerLoyaltyPointsService);
  }

  @Get()
  findAll() {
    return this.customerLoyaltyPointsService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerLoyaltyPointsService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerLoyaltyPointsDto: UpdateCustomerLoyaltyPointsDTO) {
    return this.customerLoyaltyPointsService.update(id, updateCustomerLoyaltyPointsDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerLoyaltyPointsService.remove(id);
  }
}

================
File: customer-loyalty-point/customer-loyalty.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerLoyaltyPointsSchema } from './schemas/customer-loyalty-points.schema';
import { CustomerLoyaltyPointsService } from './services/customer-loyalty-points.service';
import { CustomerLoyaltyPointsController } from './controllers/customer-loyalty-points.controller';
@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CustomerLoyalty', schema: CustomerLoyaltyPointsSchema }])
  ],
  controllers: [CustomerLoyaltyPointsController],
  providers: [CustomerLoyaltyPointsService],
  exports: [CustomerLoyaltyPointsService]
})
export class CustomerLoyaltyPointsModule { }

================
File: customer-loyalty-point/dtos/customer-loyalty-point.dto.ts
================
// CustomerLoyaltyPointsDTO: Đại diện toàn bộ schema
export class CustomerLoyaltyPointsDTO {
  storeId: string; // Mã cửa hàng
  customerId: string; // Mã khách hàng
  programId: string; // Mã chương trình
  currentPoints: number; // Điểm hiện tại
  totalPointsEarned: number; // Tổng điểm kiếm được
  totalPointsRedeemed: number; // Tổng điểm đã đổi
  tier: string; // Cấp bậc
  pointsHistory: { type: string; points: number; orderId: string; rewardId: string; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

// CreateCustomerLoyaltyPointsDTO: Dùng để tạo mới
export class CreateCustomerLoyaltyPointsDTO {
  storeId: string; // Mã cửa hàng
  customerId: string; // Mã khách hàng
  programId: string; // Mã chương trình
  currentPoints: number; // Điểm hiện tại
  totalPointsEarned: number; // Tổng điểm kiếm được
  totalPointsRedeemed: number; // Tổng điểm đã đổi
  tier: string; // Cấp bậc
  pointsHistory: { type: string; points: number; orderId: string; rewardId: string; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

// UpdateCustomerLoyaltyPointsDTO: Dùng để cập nhật
export class UpdateCustomerLoyaltyPointsDTO {
  currentPoints?: number; // Điểm hiện tại
  totalPointsEarned?: number; // Tổng điểm kiếm được
  totalPointsRedeemed?: number; // Tổng điểm đã đổi
  tier?: string; // Cấp bậc
  pointsHistory?: { type: string; points: number; orderId: string; rewardId: string; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

================
File: customer-loyalty-point/schemas/customer-loyalty-points.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'CustomerLoyaltyPoints' })
export class CustomerLoyaltyPoints extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng

  @Prop({ type: Types.ObjectId, ref: 'LoyaltyPrograms', required: true })
  programId: Types.ObjectId; // Mã chương trình

  @Prop({ default: 0 })
  currentPoints: number; // Điểm hiện tại

  @Prop({ default: 0 })
  totalPointsEarned: number; // Tổng điểm kiếm được

  @Prop({ default: 0 })
  totalPointsRedeemed: number; // Tổng điểm đã đổi

  @Prop()
  tier: string; // Cấp bậc

  @Prop({ type: [{ type: String, points: Number, orderId: Types.ObjectId, rewardId: Types.ObjectId, description: String, expiryDate: Date, createdAt: Date }] })
  pointsHistory: { type: string; points: number; orderId: Types.ObjectId; rewardId: Types.ObjectId; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

export const CustomerLoyaltyPointsSchema = SchemaFactory.createForClass(CustomerLoyaltyPoints);

================
File: customer-loyalty-point/services/customer-loyalty-points.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateCustomerLoyaltyPointsDTO, UpdateCustomerLoyaltyPointsDTO } from '../dtos/customer-loyalty-point.dto';
import { CustomerLoyaltyPoints } from '../schemas/customer-loyalty-points.schema';

@Injectable()
export class CustomerLoyaltyPointsService {
  constructor(
    @InjectModel(CustomerLoyaltyPoints.name) private customerLoyaltyPointsModel: Model<CustomerLoyaltyPoints>,
  ) { }

  async create(createCustomerLoyaltyPointsDto: CreateCustomerLoyaltyPointsDTO): Promise<CustomerLoyaltyPoints> {
    const createdPoints = new this.customerLoyaltyPointsModel(createCustomerLoyaltyPointsDto);
    return createdPoints.save();
  }

  async findAll(): Promise<CustomerLoyaltyPoints[]> {
    return this.customerLoyaltyPointsModel
      .find()
      .populate('customer')
      .populate('program')
      .populate('transaction')
      .exec();
  }

  async findOne(id: string): Promise<CustomerLoyaltyPoints> {
    const points = await this.customerLoyaltyPointsModel
      .findById(id)
      .populate('customer')
      .populate('program')
      .populate('transaction')
      .exec();
    if (!points) {
      throw new NotFoundException(`Customer loyalty points with ID ${id} not found`);
    }
    return points;
  }

  async update(id: string, updateCustomerLoyaltyPointsDto: UpdateCustomerLoyaltyPointsDTO): Promise<CustomerLoyaltyPoints> {
    const points = await this.customerLoyaltyPointsModel
      .findByIdAndUpdate(id, updateCustomerLoyaltyPointsDto, { new: true })
      .populate('customer')
      .populate('program')
      .populate('transaction')
      .exec();
    if (!points) {
      throw new NotFoundException(`Customer loyalty points with ID ${id} not found`);
    }
    return points;
  }

  async remove(id: string): Promise<CustomerLoyaltyPoints> {
    const points = await this.customerLoyaltyPointsModel.findByIdAndDelete(id).exec();
    if (!points) {
      throw new NotFoundException(`Customer loyalty points with ID ${id} not found`);
    }
    return points;
  }
}

================
File: customer/controllers/customer.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerService } from '../services/customer.service';
import { CreateCustomerDTO, UpdateCustomerDTO } from '../dtos/customer.dto';

@Controller('api/customers')
export class CustomerController {
  constructor(private readonly customerService: CustomerService) { }

  @Post()
  create(@Body() createCustomerDto: CreateCustomerDTO) {
    return this.customerService.create(createCustomerDto);
  }

  @Get()
  findAll() {
    return this.customerService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerDto: UpdateCustomerDTO) {
    return this.customerService.update(id, updateCustomerDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerService.remove(id);
  }
}

================
File: customer/customer.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerController } from './controllers/customer.controller';
import { CustomerService } from './services/customer.service';
import { Customer, CustomerSchema } from './schemas/customer.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Customers', schema: CustomerSchema }])
  ],
  controllers: [CustomerController],
  providers: [CustomerService],
  exports: [CustomerService]
})
export class CustomerModule { }

================
File: customer/dtos/customer.dto.ts
================
// CustomerDTO: Đại diện toàn bộ schema
export class CustomerDTO {
  customerId: string; // Mã khách hàng
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  customerType: string; // Loại khách hàng
  taxCode: string; // Mã số thuế
  idCard: string; // CMND/CCCD
  group: string; // Mã nhóm
  debt: number; // Nợ
  totalSales: number; // Tổng doanh số
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateCustomerDTO: Dùng để tạo mới
export class CreateCustomerDTO {
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  customerType: string; // Loại khách hàng
  taxCode: string; // Mã số thuế
  idCard: string; // CMND/CCCD
  group: string; // Mã nhóm
  status: string; // Trạng thái
}

// UpdateCustomerDTO: Dùng để cập nhật
export class UpdateCustomerDTO {
  name?: string; // Tên
  phone?: string; // Số điện thoại
  email?: string; // Email
  address?: string; // Địa chỉ
  customerType?: string; // Loại khách hàng
  taxCode?: string; // Mã số thuế
  idCard?: string; // CMND/CCCD
  group?: string; // Mã nhóm
  status?: string; // Trạng thái
}

================
File: customer/schemas/customer.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Customers' })
export class Customer extends Document {
  @Prop({ unique: true, required: true })
  customerId: string; // Mã khách hàng

  @Prop({ required: true })
  name: string; // Tên khách hàng

  @Prop()
  phone: string; // Số điện thoại

  @Prop()
  email: string; // Email

  @Prop()
  address: string; // Địa chỉ

  @Prop({ enum: ['individual', 'company'], required: true })
  customerType: string; // Loại khách hàng

  @Prop()
  taxCode: string; // Mã số thuế

  @Prop()
  idCard: string; // CMND/CCCD

  @Prop({ type: Types.ObjectId, ref: 'CustomerGroups' })
  group: Types.ObjectId; // Mã nhóm khách hàng

  @Prop({ default: 0 })
  debt: number; // Nợ hiện tại

  @Prop({ default: 0 })
  totalSales: number; // Tổng doanh số

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CustomerSchema = SchemaFactory.createForClass(Customer);

================
File: customer/services/customer.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Customer } from '../schemas/customer.schema';
import { CreateCustomerDTO, UpdateCustomerDTO } from '../dtos/customer.dto';
@Injectable()
export class CustomerService {
  constructor(
    @InjectModel('Customers') private customerModel: Model<Customer>,
  ) { }

  async create(createCustomerDto: CreateCustomerDTO): Promise<Customer> {
    const lastCustomer = await this.customerModel.findOne().sort({ customerId: -1 }).exec();
    let newCustomerId = 'KH00001';
  
    if (lastCustomer && lastCustomer.customerId) {
      const lastNumber = parseInt(lastCustomer.customerId.replace('KH', ''), 10);
      const nextNumber = lastNumber + 1;
      newCustomerId = `KH${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdCustomer = new this.customerModel({
      ...createCustomerDto,
      customerId: newCustomerId
    });
  
    return createdCustomer.save();
  }

  async findAll(): Promise<Customer[]> {
    return this.customerModel.find().populate('group').exec();
  }

  async findOne(id: string): Promise<Customer> {
    const customer = await this.customerModel.findById(id).populate('group').exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }

  async update(id: string, updateCustomerDto: UpdateCustomerDTO): Promise<Customer> {
    const customer = await this.customerModel
      .findByIdAndUpdate(id, updateCustomerDto, { new: true })
      .populate('group')
      .exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }

  async remove(id: string): Promise<Customer> {
    const customer = await this.customerModel.findByIdAndDelete(id).exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }
}

================
File: department/controllers/department.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { DepartmentService } from '../services/department.service';
import { CreateDepartmentDTO, UpdateDepartmentDTO } from '../dtos/department.dto';
import { Department } from '../schemas/department.schema';

@Controller('api/departments')
export class DepartmentController {
  constructor(private readonly departmentService: DepartmentService) { }

  @Post()
  async create(@Body() createDepartmentDto: CreateDepartmentDTO): Promise<Department> {
    return this.departmentService.create(createDepartmentDto);
  }

  @Get()
  findAll() {
    return this.departmentService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.departmentService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateDepartmentDto: UpdateDepartmentDTO) {
    return this.departmentService.update(id, updateDepartmentDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.departmentService.remove(id);
  }
}

================
File: department/department.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Department, DepartmentSchema } from './schemas/department.schema';
import { DepartmentController } from './controllers/department.controller';
import { DepartmentService } from './services/department.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Departments', schema: DepartmentSchema }])
  ],
  controllers: [DepartmentController],
  providers: [DepartmentService],
  exports: [DepartmentService]
})
export class DepartmentModule { }

================
File: department/dtos/department.dto.ts
================
// DepartmentDTO: Đại diện toàn bộ schema
export class DepartmentDTO {
  departmentId: string; // Mã phòng ban
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateDepartmentDTO: Dùng để tạo mới
export class CreateDepartmentDTO {
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
}

// UpdateDepartmentDTO: Dùng để cập nhật
export class UpdateDepartmentDTO {
  name?: string; // Tên
  description?: string; // Mô tả
  status?: string; // Trạng thái
}

================
File: department/schemas/department.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Departments' })
export class Department extends Document {
  @Prop({ unique: true, required: true })
  departmentId: string; // Mã phòng ban

  @Prop({ required: true })
  name: string; // Tên phòng ban

  @Prop()
  description: string; // Mô tả

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const DepartmentSchema = SchemaFactory.createForClass(Department);

================
File: department/services/department.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Department } from '../schemas/department.schema';
import { CreateDepartmentDTO, UpdateDepartmentDTO } from '../dtos/department.dto';
@Injectable()
export class DepartmentService {
  constructor(
    @InjectModel('Departments') private departmentModel: Model<Department>,
  ) { }

  async create(createDepartmentDto: CreateDepartmentDTO): Promise<Department> {
    const lastDepartment = await this.departmentModel.findOne().sort({ departmentId: -1 }).exec();
    let newDepartmentId = 'DV00001';
  
    if (lastDepartment && lastDepartment.departmentId) {
      const lastNumber = parseInt(lastDepartment.departmentId.replace('DV', ''), 10);
      const nextNumber = lastNumber + 1;
      newDepartmentId = `DV${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdDepartment = new this.departmentModel({
      ...createDepartmentDto,
      departmentId: newDepartmentId
    });
  
    return createdDepartment.save();
  }

  async findAll(): Promise<Department[]> {
    return this.departmentModel.find().exec();
  }

  async findOne(id: string): Promise<Department> {
    const department = await this.departmentModel.findById(id).exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }

  async update(id: string, updateDepartmentDto: UpdateDepartmentDTO): Promise<Department> {
    const department = await this.departmentModel
      .findByIdAndUpdate(id, updateDepartmentDto, { new: true })
      .exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }

  async remove(id: string): Promise<Department> {
    const department = await this.departmentModel.findByIdAndDelete(id).exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }
}

================
File: destruction/controllers/destruction.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Destruction } from 'src/modules/destruction/schemas/destructions.schema';
import { CreateDestructionDTO, UpdateDestructionDTO } from 'src/modules/destruction/dtos/destruction.dto';
import { DestructionService } from '../services/destruction.service';

@Controller('api/destructions')
export class DestructionController {
  constructor(private readonly destructionService: DestructionService) { }

  @Post()
  async create(@Body() createDestructionDto: CreateDestructionDTO): Promise<Destruction> {
    return this.destructionService.create(createDestructionDto);
  }

  @Get()
  findAll() {
    return this.destructionService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.destructionService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateDestructionDto: UpdateDestructionDTO) {
    return this.destructionService.update(id, updateDestructionDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.destructionService.remove(id);
  }
}

================
File: destruction/dtos/destruction.dto.ts
================
// DestructionDTO: Đại diện toàn bộ schema
export class DestructionDTO {
  destructionId: string; // Mã hủy hàng
  destructionCode: string; // Mã hiển thị
  products: { productId: string; quantity: number }[]; // Sản phẩm hủy
  totalValue: number; // Tổng giá trị
  status: string; // Trạng thái
}

// CreateDestructionDTO: Dùng để tạo mới
export class CreateDestructionDTO {
  destructionCode: string; // Mã hiển thị
  products: { productId: string; quantity: number }[]; // Sản phẩm hủy
  totalValue: number; // Tổng giá trị
  status: string; // Trạng thái
}

// UpdateDestructionDTO: Dùng để cập nhật
export class UpdateDestructionDTO {
  destructionCode?: string; // Mã hiển thị
  products?: { productId: string; quantity: number }[]; // Sản phẩm hủy
  totalValue?: number; // Tổng giá trị
  status?: string; // Trạng thái
}

================
File: destruction/schemas/destructions.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Destructions' })
export class Destruction extends Document {
  @Prop({ unique: true, required: true })
  destructionId: string; // Mã hủy hàng

  @Prop()
  destructionCode: string; // Mã hủy hàng hiển thị

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  products: { productId: Types.ObjectId; quantity: number }[]; // Danh sách sản phẩm hủy

  @Prop()
  totalValue: number; // Tổng giá trị

  @Prop({ enum: ['draft', 'completed', 'cancelled'], default: 'draft' })
  status: string; // Trạng thái
}

export const DestructionSchema = SchemaFactory.createForClass(Destruction);

================
File: destruction/services/destruction.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Destruction } from '../schemas/destructions.schema';
import { CreateDestructionDTO, UpdateDestructionDTO } from '../dtos/destruction.dto';

@Injectable()
export class DestructionService {
  constructor(
    @InjectModel('Destructions') private destructionModel: Model<Destruction>,
  ) { }

  async create(createDestructionDto: CreateDestructionDTO): Promise<Destruction> {
    const lastDestruction = await this.destructionModel.findOne().sort({ destructionId: -1 }).exec();
    let newDestructionId = 'DTS00001';
  
    if (lastDestruction && lastDestruction.destructionId) {
      const lastNumber = parseInt(lastDestruction.destructionId.replace('DTS', ''), 10);
      const nextNumber = lastNumber + 1;
      newDestructionId = `DTS${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdDestruction = new this.destructionModel({
      ...createDestructionDto,
      destructionId: newDestructionId
    });
  
    return createdDestruction.save();
  }

  async findAll(): Promise<Destruction[]> {
    return this.destructionModel.find().exec();
  }

  async findOne(id: string): Promise<Destruction> {
    const destruction = await this.destructionModel.findById(id).exec();
    if (!destruction) {
        throw new NotFoundException(`Destruction with ID ${id} not found`);
    }
    return destruction;
  }

  async update(id: string, updateDestructionDto: UpdateDestructionDTO): Promise<Destruction> {
    const destruction = await this.destructionModel
      .findByIdAndUpdate(id, updateDestructionDto, { new: true })
      .exec();
    if (!destruction) {
      throw new NotFoundException(`Destruction with ID ${id} not found`);
    }
    return destruction;
  }

  async remove(id: string): Promise<Destruction> {
    const destruction = await this.destructionModel.findByIdAndDelete(id).exec();
    if (!destruction) {
        throw new NotFoundException(`Destruction with ID ${id} not found`);
    }
    return destruction;
  }
}

================
File: employee/controllers/employee.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { EmployeeService } from '../services/employee.service';
import { CreateEmployeeDTO, UpdateEmployeeDTO } from '../dtos/employee.dto';
@Controller('api/employees')
export class EmployeeController {
  constructor(private readonly employeeService: EmployeeService) { }

  @Post()
  create(@Body() createEmployeeDto: CreateEmployeeDTO) {
    return this.employeeService.create(createEmployeeDto);
  }

  @Get()
  findAll() {
    return this.employeeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.employeeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateEmployeeDto: UpdateEmployeeDTO) {
    return this.employeeService.update(id, updateEmployeeDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.employeeService.remove(id);
  }
}

================
File: employee/dtos/employee.dto.ts
================
// EmployeeDTO: Đại diện toàn bộ schema
export class EmployeeDTO {
  employeeId: string; // Mã nhân viên
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  branchSalary: string; // Mã chi nhánh tính lương
  branchWork: string; // Mã chi nhánh làm việc
  startDate: Date; // Ngày bắt đầu
  position: string; // Mã vị trí
  department: string; // Mã phòng ban
  userAccount: string; // Mã tài khoản
  idCard: string; // CMND/CCCD
  dob: Date; // Ngày sinh
  gender: string; // Giới tính
  salaryType: string; // Loại lương
  salaryDetails: {
    shiftRate: number;
    hourlyRate: number;
    dailyRate: number;
    fixedRate: number;
  }; // Chi tiết lương
  bonus: { type: string; form: string; value: number }[]; // Thưởng
  commission: number; // Hoa hồng
  commissionTable: string; // Mã bảng hoa hồng
  allowance: { name: string; type: string; value: number; valueType: string }[]; // Phụ cấp
  deduction: { name: string; type: string; condition: string; value: number }[]; // Khấu trừ
  status: string; // Trạng thái
}

// CreateEmployeeDTO: Dùng để tạo mới
export class CreateEmployeeDTO {
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  branchSalary: string; // Mã chi nhánh tính lương
  branchWork: string; // Mã chi nhánh làm việc
  startDate: Date; // Ngày bắt đầu
  position: string; // Mã vị trí
  department: string; // Mã phòng ban
  userAccount: string; // Mã tài khoản
  idCard: string; // CMND/CCCD
  dob: Date; // Ngày sinh
  gender: string; // Giới tính
  salaryType: string; // Loại lương
  salaryDetails: {
    shiftRate: number;
    hourlyRate: number;
    dailyRate: number;
    fixedRate: number;
  }; // Chi tiết lương
  bonus: { type: string; form: string; value: number }[]; // Thưởng
  commission: number; // Hoa hồng
  commissionTable: string; // Mã bảng hoa hồng
  allowance: { name: string; type: string; value: number; valueType: string }[]; // Phụ cấp
  deduction: { name: string; type: string; condition: string; value: number }[]; // Khấu trừ
  status: string; // Trạng thái
}

// UpdateEmployeeDTO: Dùng để cập nhật
export class UpdateEmployeeDTO {
  name?: string; // Tên
  phone?: string; // Số điện thoại
  email?: string; // Email
  address?: string; // Địa chỉ
  branchSalary?: string; // Mã chi nhánh tính lương
  branchWork?: string; // Mã chi nhánh làm việc
  startDate?: Date; // Ngày bắt đầu
  position?: string; // Mã vị trí
  department?: string; // Mã phòng ban
  userAccount?: string; // Mã tài khoản
  idCard?: string; // CMND/CCCD
  dob?: Date; // Ngày sinh
  gender?: string; // Giới tính
  salaryType?: string; // Loại lương
  salaryDetails?: {
    shiftRate?: number;
    hourlyRate?: number;
    dailyRate?: number;
    fixedRate?: number;
  }; // Chi tiết lương
  bonus?: { type: string; form: string; value: number }[]; // Thưởng
  commission?: number; // Hoa hồng
  commissionTable?: string; // Mã bảng hoa hồng
  allowance?: { name: string; type: string; value: number; valueType: string }[]; // Phụ cấp
  deduction?: { name: string; type: string; condition: string; value: number }[]; // Khấu trừ
  status?: string; // Trạng thái
}

================
File: employee/employee.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { EmployeeController } from './controllers/employee.controller';
import { EmployeeService } from './services/employee.service';
import { Employee, EmployeeSchema } from './schemas/employee.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Employees', schema: EmployeeSchema }
    ]),
  ],
  controllers: [EmployeeController],
  providers: [EmployeeService],
  exports: [EmployeeService],
})
export class EmployeeModule { }

================
File: employee/schemas/employee.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
@Schema({ collection: 'Employees' })
export class Employee extends Document {
  @Prop({ unique: true, required: true })
  employeeId: string; // Mã nhân viên

  @Prop({ required: true })
  name: string; // Tên nhân viên

  @Prop({ required: true })
  phone: string; // Số điện thoại

  @Prop({ type: Types.ObjectId, ref: 'Stores' })
  storeId: Types.ObjectId; // Chi nhánh làm việc

  @Prop({ type: Types.ObjectId, ref: 'Stores' })
  payrollStoreId: Types.ObjectId; // Chi nhánh trả lương

  @Prop({ type: Types.ObjectId, ref: 'Departments' })
  departmentId: Types.ObjectId; // Mã phòng ban

  @Prop({ type: Types.ObjectId, ref: 'Positions' })
  positionId: Types.ObjectId; // Mã chức danh

  @Prop()
  startDate: Date; // Ngày bắt đầu làm việc

  @Prop({
    type: {
      gender: String,
      dateOfBirth: Date,
      idNumber: String,
    },
  })
  personalInfo: {
    gender: string; // Giới tính
    dateOfBirth: Date; // Ngày sinh
    idNumber: string; // CMND/CCCD
  }; // Thông tin cá nhân

  @Prop({
    type: {
      address: String,
      email: String,
      facebook: String,
    },
  })
  contactInfo: {
    address: string; // Địa chỉ
    email: string; // Email
    facebook: string; // Facebook
  }; // Thông tin liên hệ

  @Prop({
    type: {
      salaryType: String,
      baseSalary: Number,
      shiftRate: Number,
      hourlyRate: Number,
      dailyRate: Number,
      overtimeRate: Number,
    },
  })
  salarySettings: {
    salaryType: string; // Loại lương: 'shift', 'hourly', 'daily', 'fixed'
    baseSalary: number; // Lương cơ bản (nếu cố định)
    shiftRate: number; // Lương theo ca
    hourlyRate: number; // Lương theo giờ
    dailyRate: number; // Lương theo ngày công
    overtimeRate: number; // Tỷ lệ làm thêm giờ
  }; // Thiết lập lương

  @Prop({
    type: {
      bonusType: String,
      bonusRate: Number,
      bonusScope: String,
    },
  })
  bonusSettings: {
    bonusType: string; // Loại thưởng: 'revenue', 'branchProfit', 'totalProfit'
    bonusRate: number; // Tỷ lệ thưởng
    bonusScope: string; // Phạm vi: 'personal', 'branch', 'system'
  }; // Thiết lập thưởng

  @Prop({
    type: {
      commissionRate: Number,
    },
  })
  commissionSettings: {
    commissionRate: number; // Tỷ lệ hoa hồng
  }; // Thiết lập hoa hồng

  @Prop({ type: [{ name: String, amount: Number, type: String }] })
  allowanceSettings: { name: string; amount: number; type: string }[]; // Phụ cấp

  @Prop({ type: [{ name: String, amount: Number, condition: String }] })
  deductionSettings: { name: string; amount: number; condition: string }[]; // Giảm trừ

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  notes: string; // Ghi chú

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}
export const EmployeeSchema = SchemaFactory.createForClass(Employee);

================
File: employee/services/employee.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Employee } from '../schemas/employee.schema';
import { CreateEmployeeDTO, UpdateEmployeeDTO } from '../dtos/employee.dto';
@Injectable()
export class EmployeeService {
  constructor(
    @InjectModel('Employees') private employeeModel: Model<Employee>,
  ) { }

  async create(createEmployeeDto: CreateEmployeeDTO): Promise<Employee> {
    const lastEmployee = await this.employeeModel.findOne().sort({ employeeId: -1 }).exec();
    let newEmployeeId = 'NV00001';
  
    if (lastEmployee && lastEmployee.employeeId) {
      const lastNumber = parseInt(lastEmployee.employeeId.replace('NV', ''), 10);
      const nextNumber = lastNumber + 1;
      newEmployeeId = `NV${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdEmployee = new this.employeeModel({
      ...createEmployeeDto,
      employeeId: newEmployeeId
    });
  
    return createdEmployee.save();
  }

  async findAll(): Promise<Employee[]> {
    return this.employeeModel
      .find()
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
  }

  async findOne(id: string): Promise<Employee> {
    const employee = await this.employeeModel
      .findById(id)
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }

  async update(id: string, updateEmployeeDto: UpdateEmployeeDTO): Promise<Employee> {
    const employee = await this.employeeModel
      .findByIdAndUpdate(id, updateEmployeeDto, { new: true })
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }

  async remove(id: string): Promise<Employee> {
    const employee = await this.employeeModel.findByIdAndDelete(id).exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }
}

================
File: holiday/controllers/holiday.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { HolidayService } from '../services/holiday.service';
import { Holiday } from '../schemas/holiday.schema';
import { CreateHolidayDTO, UpdateHolidayDTO } from '../dtos/holiday.dto';
@Controller('api/holidays')
export class HolidayController {
  constructor(private readonly holidayService: HolidayService) { }

  @Post()
  async create(@Body() createHolidayDto: CreateHolidayDTO): Promise<Holiday> {
    return this.holidayService.create(createHolidayDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<Holiday[]> {
    return this.holidayService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Holiday> {
    return this.holidayService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateHolidayDto: UpdateHolidayDTO,
  ): Promise<Holiday> {
    return this.holidayService.update(id, updateHolidayDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Holiday> {
    return this.holidayService.remove(id);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<Holiday[]> {
    return this.holidayService.findByStore(storeId);
  }

  @Get('date/:date')
  async findByDate(@Param('date') date: string): Promise<Holiday[]> {
    return this.holidayService.findByDate(date);
  }

  @Get('month/:year/:month')
  async findByMonth(
    @Param('year') year: number,
    @Param('month') month: number,
  ): Promise<Holiday[]> {
    return this.holidayService.findByMonth(year, month);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<Holiday> {
    return this.holidayService.updateStatus(id, status);
  }
}

================
File: holiday/dtos/holiday.dto.ts
================
// HolidayDTO: Đại diện toàn bộ schema
export class HolidayDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên ngày lễ
  type: string; // Loại
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  duration: number; // Thời gian
  description: string; // Mô tả
  isRecurring: boolean; // Lặp lại
  recurringPattern: {
    frequency: string; // Tần suất
    interval: number; // Khoảng cách
    endAfter: Date; // Kết thúc sau
  };
  status: string; // Trạng thái
}

// CreateHolidayDTO: Dùng để tạo mới
export class CreateHolidayDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên ngày lễ
  type: string; // Loại
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  duration: number; // Thời gian
  description: string; // Mô tả
  isRecurring: boolean; // Lặp lại
  recurringPattern: {
    frequency: string; // Tần suất
    interval: number; // Khoảng cách
    endAfter: Date; // Kết thúc sau
  };
  status: string; // Trạng thái
}

// UpdateHolidayDTO: Dùng để cập nhật
export class UpdateHolidayDTO {
  name?: string; // Tên ngày lễ
  type?: string; // Loại
  startDate?: Date; // Ngày bắt đầu
  endDate?: Date; // Ngày kết thúc
  duration?: number; // Thời gian
  description?: string; // Mô tả
  isRecurring?: boolean; // Lặp lại
  recurringPattern?: {
    frequency?: string; // Tần suất
    interval?: number; // Khoảng cách
    endAfter?: Date; // Kết thúc sau
  };
  status?: string; // Trạng thái
}

================
File: holiday/holiday.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Holiday, HolidaySchema } from './schemas/holiday.schema';
import { HolidayController } from './controllers/holiday.controller';
import { HolidayService } from './services/holiday.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Holidays', schema: HolidaySchema }])
  ],
  controllers: [HolidayController],
  providers: [HolidayService],
  exports: [HolidayService]
})
export class HolidayModule { }

================
File: holiday/schemas/holiday.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Holidays' })
export class Holiday extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên ngày lễ

  @Prop({ enum: ['holiday', 'special', 'company'], required: true })
  type: string; // Loại ngày lễ

  @Prop({ required: true })
  startDate: Date; // Ngày bắt đầu

  @Prop({ required: true })
  endDate: Date; // Ngày kết thúc

  @Prop()
  duration: number; // Thời gian (ngày)

  @Prop()
  description: string; // Mô tả

  @Prop({ default: false })
  isRecurring: boolean; // Lặp lại hàng năm

  @Prop({ type: { frequency: String, interval: Number, endAfter: Date } })
  recurringPattern: {
    frequency: string; // Tần suất lặp
    interval: number; // Khoảng cách
    endAfter: Date; // Kết thúc sau
  };

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái
}

export const HolidaySchema = SchemaFactory.createForClass(Holiday);

================
File: holiday/services/holiday.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Holiday } from '../schemas/holiday.schema';
import { CreateHolidayDTO, UpdateHolidayDTO } from '../dtos/holiday.dto';

@Injectable()
export class HolidayService {
  constructor(
    @InjectModel('Holidays')
    private holidayModel: Model<Holiday>,
  ) { }

  async create(createHolidayDto: CreateHolidayDTO): Promise<Holiday> {
    const created = new this.holidayModel(createHolidayDto);
    return created.save();
  }

  async findAll(query: any = {}): Promise<Holiday[]> {
    return this.holidayModel.find(query).exec();
  }

  async findOne(id: string): Promise<Holiday> {
    const holiday = await this.holidayModel.findById(id).exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async update(id: string, updateHolidayDto: UpdateHolidayDTO): Promise<Holiday> {
    const holiday = await this.holidayModel
      .findByIdAndUpdate(id, updateHolidayDto, { new: true })
      .exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async remove(id: string): Promise<Holiday> {
    const holiday = await this.holidayModel.findByIdAndDelete(id).exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async findByStore(storeId: string): Promise<Holiday[]> {
    return this.holidayModel.find({ storeId }).exec();
  }

  async findByDate(date: string): Promise<Holiday[]> {
    const startDate = new Date(date);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(date);
    endDate.setHours(23, 59, 59, 999);

    return this.holidayModel.find({
      date: {
        $gte: startDate,
        $lte: endDate,
      },
    }).exec();
  }

  async findByMonth(year: number, month: number): Promise<Holiday[]> {
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0);

    return this.holidayModel.find({
      date: {
        $gte: startDate,
        $lte: endDate,
      },
    }).exec();
  }

  async updateStatus(id: string, status: string): Promise<Holiday> {
    const holiday = await this.holidayModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }
}

================
File: inventory-check/controllers/inventory-check.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete } from '@nestjs/common';
import { InventoryCheckService } from '../services/inventory-check.service';
import { InventoryCheck } from '../schemas/inventory-check.schema';
import { CreateInventoryCheckDTO, UpdateInventoryCheckDTO } from '../dtos/inventory-check.dto';
@Controller('api/inventory-checks')
export class InventoryCheckController {
  constructor(private readonly inventoryCheckService: InventoryCheckService) { }

  @Post()
  async create(@Body() createInventoryCheckDto: CreateInventoryCheckDTO): Promise<InventoryCheck> {
    return this.inventoryCheckService.create(createInventoryCheckDto);
  }

  @Get()
  async findAll(): Promise<InventoryCheck[]> {
    return this.inventoryCheckService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<InventoryCheck> {
    return this.inventoryCheckService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateInventoryCheckDto: UpdateInventoryCheckDTO,
  ): Promise<InventoryCheck> {
    return this.inventoryCheckService.update(id, updateInventoryCheckDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<InventoryCheck> {
    return this.inventoryCheckService.remove(id);
  }

  @Put(':id/approve')
  async approve(@Param('id') id: string): Promise<InventoryCheck> {
    const updateDto = { status: 'approved' };
    return this.inventoryCheckService.update(id, updateDto);
  }

  @Put(':id/reject')
  async reject(@Param('id') id: string): Promise<InventoryCheck> {
    const updateDto = { status: 'rejected' };
    return this.inventoryCheckService.update(id, updateDto);
  }
}

================
File: inventory-check/dtos/inventory-check.dto.ts
================
// InventoryCheckDTO: Đại diện toàn bộ schema
export class InventoryCheckDTO {
  checkId: string; // Mã kiểm kê
  storeId: string; // Mã cửa hàng
  warehouseId: string; // Mã kho
  checkDate: Date; // Ngày kiểm kê
  type: string; // Loại kiểm kê
  status: string; // Trạng thái
  items: { productId: string; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết
  totalItems: number; // Tổng sản phẩm
  totalValue: number; // Tổng giá trị
  totalDifference: number; // Tổng chênh lệch
  checkedBy: string; // Mã nhân viên kiểm kê
  verifiedBy: string; // Mã nhân viên xác nhận
  attachments: string[]; // Tệp đính kèm
  notes: string; // Ghi chú
}

// CreateInventoryCheckDTO: Dùng để tạo mới
export class CreateInventoryCheckDTO {
  storeId: string; // Mã cửa hàng
  warehouseId: string; // Mã kho
  checkDate: Date; // Ngày kiểm kê
  type: string; // Loại kiểm kê
  status: string; // Trạng thái
  items: { productId: string; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết
  totalItems: number; // Tổng sản phẩm
  totalValue: number; // Tổng giá trị
  totalDifference: number; // Tổng chênh lệch
  checkedBy: string; // Mã nhân viên kiểm kê
  verifiedBy: string; // Mã nhân viên xác nhận
  attachments: string[]; // Tệp đính kèm
  notes: string; // Ghi chú
}

// UpdateInventoryCheckDTO: Dùng để cập nhật
export class UpdateInventoryCheckDTO {
  checkDate?: Date; // Ngày kiểm kê
  type?: string; // Loại kiểm kê
  status?: string; // Trạng thái
  items?: { productId: string; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết
  totalItems?: number; // Tổng sản phẩm
  totalValue?: number; // Tổng giá trị
  totalDifference?: number; // Tổng chênh lệch
  checkedBy?: string; // Mã nhân viên kiểm kê
  verifiedBy?: string; // Mã nhân viên xác nhận
  attachments?: string[]; // Tệp đính kèm
  notes?: string; // Ghi chú
}

================
File: inventory-check/inventory-check.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { InventoryCheckSchema } from './schemas/inventory-check.schema';
import { InventoryCheckController } from './controllers/inventory-check.controller';
import { InventoryCheckService } from './services/inventory-check.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'InventoryChecks', schema: InventoryCheckSchema }])
  ],
  controllers: [InventoryCheckController],
  providers: [InventoryCheckService],
  exports: [InventoryCheckService]
})
export class InventoryCheckModule { }

================
File: inventory-check/schemas/inventory-check.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'InventoryChecks' })
export class InventoryCheck extends Document {
  @Prop({ unique: true, required: true })
  checkId: string; // Mã kiểm kê

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  warehouseId: Types.ObjectId; // Mã kho

  @Prop({ required: true })
  checkDate: Date; // Ngày kiểm kê

  @Prop({ enum: ['periodic', 'spot', 'request'], required: true })
  type: string; // Loại kiểm kê

  @Prop({ enum: ['draft', 'in_progress', 'completed', 'cancelled'], default: 'draft' })
  status: string; // Trạng thái

  @Prop({ type: [{ productId: Types.ObjectId, systemQuantity: Number, actualQuantity: Number, difference: Number, unitPrice: Number, totalValue: Number, notes: String }] })
  items: { productId: Types.ObjectId; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết kiểm kê

  @Prop({ default: 0 })
  totalItems: number; // Tổng số sản phẩm

  @Prop({ default: 0 })
  totalValue: number; // Tổng giá trị

  @Prop({ default: 0 })
  totalDifference: number; // Tổng chênh lệch

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  checkedBy: Types.ObjectId; // Mã nhân viên kiểm kê

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  verifiedBy: Types.ObjectId; // Mã nhân viên xác nhận

  @Prop([String])
  attachments: string[]; // Tệp đính kèm

  @Prop()
  notes: string; // Ghi chú
}

export const InventoryCheckSchema = SchemaFactory.createForClass(InventoryCheck);

================
File: inventory-check/services/inventory-check.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { InventoryCheck } from '../schemas/inventory-check.schema';
import { CreateInventoryCheckDTO, UpdateInventoryCheckDTO } from '../dtos/inventory-check.dto';

@Injectable()
export class InventoryCheckService {
  constructor(
    @InjectModel('InventoryChecks') private inventoryCheckModel: Model<InventoryCheck>,
  ) { }

  async create(createInventoryCheckDto: CreateInventoryCheckDTO): Promise<InventoryCheck> {
    const createdCheck = new this.inventoryCheckModel(createInventoryCheckDto);
    return createdCheck.save();
  }

  async findAll(): Promise<InventoryCheck[]> {
    return this.inventoryCheckModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('approvedBy')
      .exec();
  }

  async findOne(id: string): Promise<InventoryCheck> {
    const check = await this.inventoryCheckModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('approvedBy')
      .exec();
    if (!check) {
      throw new NotFoundException(`Inventory check with ID ${id} not found`);
    }
    return check;
  }

  async update(id: string, updateInventoryCheckDto: UpdateInventoryCheckDTO): Promise<InventoryCheck> {
    const check = await this.inventoryCheckModel
      .findByIdAndUpdate(id, updateInventoryCheckDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('approvedBy')
      .exec();
    if (!check) {
      throw new NotFoundException(`Inventory check with ID ${id} not found`);
    }
    return check;
  }

  async remove(id: string): Promise<InventoryCheck> {
    const check = await this.inventoryCheckModel.findByIdAndDelete(id).exec();
    if (!check) {
      throw new NotFoundException(`Inventory check with ID ${id} not found`);
    }
    return check;
  }
}

================
File: invoice/controllers/invoice.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { InvoiceService } from '../services/invoice.service';
import { Invoice } from '../schemas/invoice.schema';
import { CreateInvoiceDTO, UpdateInvoiceDTO } from '../dtos/invoice.dto';
@Controller('api/invoices')
export class InvoiceController {
  constructor(private readonly invoiceService: InvoiceService) { }

  @Post()
  create(@Body() createInvoiceDto: CreateInvoiceDTO) {
    return this.invoiceService.create(createInvoiceDto);
  }

  @Get()
  findAll() {
    return this.invoiceService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.invoiceService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateInvoiceDto: UpdateInvoiceDTO) {
    return this.invoiceService.update(id, updateInvoiceDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.invoiceService.remove(id);
  }
}

================
File: invoice/dtos/invoice.dto.ts
================
// InvoiceDTO: Đại diện toàn bộ schema
export class InvoiceDTO {
  invoiceId: string; // Mã hóa đơn
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  invoiceNumber: string; // Số hóa đơn
  invoiceDate: Date; // Ngày hóa đơn
  dueDate: Date; // Ngày đến hạn
  items: { productId: string; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết
  subtotal: number; // Tạm tính
  tax: number; // Thuế
  shipping: number; // Phí vận chuyển
  total: number; // Tổng cộng
  paymentMethod: string; // Phương thức thanh toán
  paymentStatus: string; // Trạng thái thanh toán
  notes: string; // Ghi chú
  status: string; // Trạng thái
}

// CreateInvoiceDTO: Dùng để tạo mới
export class CreateInvoiceDTO {
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  invoiceNumber: string; // Số hóa đơn
  invoiceDate: Date; // Ngày hóa đơn
  dueDate: Date; // Ngày đến hạn
  items: { productId: string; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết
  subtotal: number; // Tạm tính
  tax: number; // Thuế
  shipping: number; // Phí vận chuyển
  total: number; // Tổng cộng
  paymentMethod: string; // Phương thức thanh toán
  paymentStatus: string; // Trạng thái thanh toán
  notes: string; // Ghi chú
  status: string; // Trạng thái
}

// UpdateInvoiceDTO: Dùng để cập nhật
export class UpdateInvoiceDTO {
  invoiceNumber?: string; // Số hóa đơn
  invoiceDate?: Date; // Ngày hóa đơn
  dueDate?: Date; // Ngày đến hạn
  items?: { productId: string; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết
  subtotal?: number; // Tạm tính
  tax?: number; // Thuế
  shipping?: number; // Phí vận chuyển
  total?: number; // Tổng cộng
  paymentMethod?: string; // Phương thức thanh toán
  paymentStatus?: string; // Trạng thái thanh toán
  notes?: string; // Ghi chú
  status?: string; // Trạng thái
}

================
File: invoice/invoice.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { InvoiceController } from './controllers/invoice.controller';
import { InvoiceService } from './services/invoice.service';
import { Invoice, InvoiceSchema } from './schemas/invoice.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Invoices', schema: InvoiceSchema }])
  ],
  controllers: [InvoiceController],
  providers: [InvoiceService],
  exports: [InvoiceService]
})
export class InvoiceModule { }

================
File: invoice/schemas/invoice.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Invoices' })
export class Invoice extends Document {
  @Prop({ unique: true, required: true })
  invoiceId: string; // Mã hóa đơn

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId; // Mã đơn hàng

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng

  @Prop({ required: true })
  invoiceNumber: string; // Số hóa đơn

  @Prop({ required: true, default: Date.now })
  invoiceDate: Date; // Ngày hóa đơn

  @Prop()
  dueDate: Date; // Ngày đến hạn

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number, unitPrice: Number, discount: Number, total: Number }] })
  items: { productId: Types.ObjectId; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết hóa đơn

  @Prop({ required: true })
  subtotal: number; // Tạm tính

  @Prop({ default: 0 })
  tax: number; // Thuế

  @Prop({ default: 0 })
  shipping: number; // Phí vận chuyển

  @Prop({ required: true })
  total: number; // Tổng cộng

  @Prop({ enum: ['cash', 'bank_transfer', 'credit_card', 'wallet'], required: true })
  paymentMethod: string; // Phương thức thanh toán

  @Prop({ enum: ['unpaid', 'partial', 'paid', 'cancelled'], default: 'unpaid' })
  paymentStatus: string; // Trạng thái thanh toán

  @Prop()
  notes: string; // Ghi chú

  @Prop({ enum: ['draft', 'issued', 'cancelled', 'void'], default: 'draft' })
  status: string; // Trạng thái hóa đơn
}

export const InvoiceSchema = SchemaFactory.createForClass(Invoice);

================
File: invoice/services/invoice.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Invoice } from '../schemas/invoice.schema';
import { CreateInvoiceDTO, UpdateInvoiceDTO } from '../dtos/invoice.dto';
@Injectable()
export class InvoiceService {
  constructor(
    @InjectModel('Invoices') private invoiceModel: Model<Invoice>,
  ) { }

  async create(createInvoiceDto: CreateInvoiceDTO): Promise<Invoice> {
    const lastInvoice = await this.invoiceModel.findOne().sort({ invoiceId: -1 }).exec();
    let newInvoiceId = 'HD00001';
  
    if (lastInvoice && lastInvoice.invoiceId) {
      const lastNumber = parseInt(lastInvoice.invoiceId.replace('HD', ''), 10);
      const nextNumber = lastNumber + 1;
      newInvoiceId = `HD${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdInvoice = new this.invoiceModel({
      ...createInvoiceDto,
      invoiceId: newInvoiceId
    });
  
    return createdInvoice.save();
  }

  async findAll(): Promise<Invoice[]> {
    return this.invoiceModel
      .find()
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
  }

  async findOne(id: string): Promise<Invoice> {
    const invoice = await this.invoiceModel
      .findById(id)
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }

  async update(id: string, updateInvoiceDto: UpdateInvoiceDTO): Promise<Invoice> {
    const invoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateInvoiceDto, { new: true })
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }

  async remove(id: string): Promise<Invoice> {
    const invoice = await this.invoiceModel.findByIdAndDelete(id).exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }
}

================
File: livestream/controllers/livestream.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { LivestreamService } from '../services/livestream.service';
import { CreateLiveStreamDTO, UpdateLiveStreamDTO } from '../dtos/livestream.dto';
@Controller('api/livestreams')
export class LivestreamController {
  constructor(private readonly livestreamService: LivestreamService) { }

  @Post()
  create(@Body() createLiveStreamDto: CreateLiveStreamDTO) {
    return this.livestreamService.create(createLiveStreamDto);
  }

  @Get()
  findAll() {
    return this.livestreamService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.livestreamService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateLiveStreamDto: UpdateLiveStreamDTO) {
    return this.livestreamService.update(id, updateLiveStreamDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.livestreamService.remove(id);
  }
}

================
File: livestream/dtos/livestream.dto.ts
================
// LiveStreamDTO: Đại diện toàn bộ schema
export class LiveStreamDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  title: string; // Tiêu đề
  description: string; // Mô tả
  thumbnail: string; // Ảnh đại diện
  scheduledStartTime: Date; // Thời gian bắt đầu dự kiến
  actualStartTime: Date; // Thời gian bắt đầu thực tế
  endTime: Date; // Thời gian kết thúc
  duration: number; // Thời lượng
  status: string; // Trạng thái
  products: { productId: string; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm
  promotions: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi
  engagement: {
    viewers: number;
    likes: number;
    comments: number;
    shares: number;
    peakViewers: number;
  }; // Tương tác
  sales: {
    orders: number;
    totalRevenue: number;
    averageOrderValue: number;
  }; // Doanh số
  comments: { userId: string; userName: string; content: string; timestamp: Date; isPinned: boolean }[]; // Bình luận
  recording: {
    url: string;
    duration: number;
    size: number;
    format: string;
  }; // Bản ghi
  analytics: {
    viewerRetention: number;
    engagementRate: number;
    conversionRate: number;
    topProducts: { productId: string; sales: number; revenue: number }[];
  }; // Phân tích
}

// CreateLiveStreamDTO: Dùng để tạo mới
export class CreateLiveStreamDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  title: string; // Tiêu đề
  description: string; // Mô tả
  thumbnail: string; // Ảnh đại diện
  scheduledStartTime: Date; // Thời gian bắt đầu dự kiến
  status: string; // Trạng thái
  products: { productId: string; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm
  promotions: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi
}

// UpdateLiveStreamDTO: Dùng để cập nhật
export class UpdateLiveStreamDTO {
  title?: string; // Tiêu đề
  description?: string; // Mô tả
  thumbnail?: string; // Ảnh đại diện
  scheduledStartTime?: Date; // Thời gian bắt đầu dự kiến
  actualStartTime?: Date; // Thời gian bắt đầu thực tế
  endTime?: Date; // Thời gian kết thúc
  duration?: number; // Thời lượng
  status?: string; // Trạng thái
  products?: { productId: string; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm
  promotions?: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi
  engagement?: {
    viewers?: number;
    likes?: number;
    comments?: number;
    shares?: number;
    peakViewers?: number;
  }; // Tương tác
  sales?: {
    orders?: number;
    totalRevenue?: number;
    averageOrderValue?: number;
  }; // Doanh số
  comments?: { userId: string; userName: string; content: string; timestamp: Date; isPinned: boolean }[]; // Bình luận
  recording?: {
    url?: string;
    duration?: number;
    size?: number;
    format?: string;
  }; // Bản ghi
  analytics?: {
    viewerRetention?: number;
    engagementRate?: number;
    conversionRate?: number;
    topProducts?: { productId: string; sales: number; revenue: number }[];
  }; // Phân tích
}

================
File: livestream/livestream.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { LiveStreamSchema } from './schemas/livestream.schema';
import { LivestreamController } from './controllers/livestream.controller';
import { LivestreamService } from './services/livestream.service';
@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'LiveStreams', schema: LiveStreamSchema }])
  ],
  controllers: [LivestreamController],
  providers: [LivestreamService],
  exports: [LivestreamService]
})
export class LivestreamModule { }

================
File: livestream/schemas/livestream.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'LiveStreams' })
export class LiveStream extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels', required: true })
  channelId: Types.ObjectId; // Mã kênh bán hàng

  @Prop({ required: true })
  title: string; // Tiêu đề livestream

  @Prop()
  description: string; // Mô tả

  @Prop()
  thumbnail: string; // Ảnh đại diện

  @Prop({ required: true })
  scheduledStartTime: Date; // Thời gian bắt đầu dự kiến

  @Prop()
  actualStartTime: Date; // Thời gian bắt đầu thực tế

  @Prop()
  endTime: Date; // Thời gian kết thúc

  @Prop()
  duration: number; // Thời lượng (phút)

  @Prop({ enum: ['scheduled', 'live', 'ended', 'cancelled'], default: 'scheduled' })
  status: string; // Trạng thái

  @Prop({ type: [{ productId: Types.ObjectId, name: String, price: Number, discount: Number, stock: Number, order: Number }] })
  products: { productId: Types.ObjectId; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm trong livestream

  @Prop({ type: [{ type: String, value: Number, description: String, startTime: Date, endTime: Date }] })
  promotions: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi

  @Prop({ type: { viewers: Number, likes: Number, comments: Number, shares: Number, peakViewers: Number } })
  engagement: {
    viewers: number; // Số người xem
    likes: number; // Lượt thích
    comments: number; // Bình luận
    shares: number; // Chia sẻ
    peakViewers: number; // Số người xem cao nhất
  };

  @Prop({ type: { orders: Number, totalRevenue: Number, averageOrderValue: Number } })
  sales: {
    orders: number; // Số đơn hàng
    totalRevenue: number; // Doanh thu
    averageOrderValue: number; // Giá trị trung bình đơn hàng
  };

  @Prop({ type: [{ userId: String, userName: String, content: String, timestamp: Date, isPinned: Boolean }] })
  comments: { userId: string; userName: string; content: string; timestamp: Date; isPinned: boolean }[]; // Bình luận

  @Prop({ type: { url: String, duration: Number, size: Number, format: String } })
  recording: {
    url: string; // Đường dẫn bản ghi
    duration: number; // Thời lượng
    size: number; // Kích thước
    format: string; // Định dạng
  };

  @Prop({ type: { viewerRetention: Number, engagementRate: Number, conversionRate: Number, topProducts: [{ productId: Types.ObjectId, sales: Number, revenue: Number }] } })
  analytics: {
    viewerRetention: number; // Tỷ lệ giữ chân người xem
    engagementRate: number; // Tỷ lệ tương tác
    conversionRate: number; // Tỷ lệ chuyển đổi
    topProducts: { productId: Types.ObjectId; sales: number; revenue: number }[]; // Sản phẩm bán chạy
  };
}

export const LiveStreamSchema = SchemaFactory.createForClass(LiveStream);

================
File: livestream/services/livestream.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { LiveStream } from '../schemas/livestream.schema';
import { CreateLiveStreamDTO, UpdateLiveStreamDTO } from '../dtos/livestream.dto';

@Injectable()
export class LivestreamService {
  constructor(
    @InjectModel('LiveStreams') private livestreamModel: Model<LiveStream>,
  ) { }

  async create(createLiveStreamDto: CreateLiveStreamDTO): Promise<LiveStream> {
    const created = new this.livestreamModel(createLiveStreamDto);
    return created.save();
  }

  async findAll(): Promise<LiveStream[]> {
    return this.livestreamModel
      .find()
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
  }

  async findOne(id: string): Promise<LiveStream> {
    const livestream = await this.livestreamModel
      .findById(id)
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!livestream) {
      throw new NotFoundException(`Livestream with ID ${id} not found`);
    }
    return livestream;
  }

  async update(id: string, updateLivestreamDto: UpdateLiveStreamDTO): Promise<LiveStream> {
    const livestream = await this.livestreamModel
      .findByIdAndUpdate(id, updateLivestreamDto, { new: true })
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!livestream) {
      throw new NotFoundException(`Livestream with ID ${id} not found`);
    }
    return livestream;
  }

  async remove(id: string): Promise<LiveStream> {
    const livestream = await this.livestreamModel.findByIdAndDelete(id).exec();
    if (!livestream) {
      throw new NotFoundException(`Livestream with ID ${id} not found`);
    }
    return livestream;
  }
}

================
File: loyalty-program/controllers/loyalty-program.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { LoyaltyProgramService } from '../services/loyalty-program.service';
import { CreateLoyaltyProgramDTO, UpdateLoyaltyProgramDTO } from '../dtos/loyalty-program.dto';
@Controller('api/loyalty-programs')
export class LoyaltyProgramController {
  constructor(private readonly loyaltyProgramService: LoyaltyProgramService) { }

  @Post()
  create(@Body() createLoyaltyProgramDto: CreateLoyaltyProgramDTO) {
    return this.loyaltyProgramService.create(createLoyaltyProgramDto);
  }

  @Get()
  findAll() {
    return this.loyaltyProgramService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.loyaltyProgramService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateLoyaltyProgramDto: UpdateLoyaltyProgramDTO) {
    return this.loyaltyProgramService.update(id, updateLoyaltyProgramDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.loyaltyProgramService.remove(id);
  }
}

================
File: loyalty-program/dtos/loyalty-program.dto.ts
================
export class TierDTO {
  name: string;
  minPoints: number;
  maxPoints?: number;
  benefits: { type: string; value: number; description: string }[];
}

export class RewardDTO {
  rewardId: string;
  name: string;
  points: number;
  description: string;
  image: string;
  stock: number;
  status: string;
  expiryDate?: Date;
}

export class LoyaltyProgramDTO {
  storeId: string;
  name: string;
  description: string;
  status: string;
  pointRules: {
    earnRate: number;
    minPoints: number;
    pointValue: number;
    expiryDays: number;
  };
  tiers: TierDTO[];
  rewards: RewardDTO[];
  statistics: {
    totalMembers: number;
    totalPointsIssued: number;
    totalPointsRedeemed: number;
    totalRewardsRedeemed: number;
    totalRevenueFromLoyalty: number;
  };
  members?: string[];
  createdAt: Date;
  updatedAt: Date;
}

export class CreateLoyaltyProgramDTO {
  storeId: string;
  name: string;
  description?: string;
  status?: string;
  pointRules: {
    earnRate: number;
    minPoints: number;
    pointValue: number;
    expiryDays: number;
  };
  tiers: TierDTO[];
  rewards: RewardDTO[];
}

export class UpdateLoyaltyProgramDTO {
  name?: string;
  description?: string;
  status?: string;
  pointRules?: {
    earnRate?: number;
    minPoints?: number;
    pointValue?: number;
    expiryDays?: number;
  };
  tiers?: TierDTO[];
  rewards?: RewardDTO[];
  statistics?: {
    totalMembers?: number;
    totalPointsIssued?: number;
    totalPointsRedeemed?: number;
    totalRewardsRedeemed?: number;
    totalRevenueFromLoyalty?: number;
  };
  members?: string[];
}

================
File: loyalty-program/loyalty-program.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { LoyaltyProgramSchema } from './schemas/loyalty-program.schema';
import { LoyaltyProgramController } from './controllers/loyalty-program.controller';
import { LoyaltyProgramService } from './services/loyalty-program.service';
@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'LoyaltyPrograms', schema: LoyaltyProgramSchema }])
  ],
  controllers: [LoyaltyProgramController],
  providers: [LoyaltyProgramService],
  exports: [LoyaltyProgramService]
})
export class LoyaltyProgramModule { }

================
File: loyalty-program/schemas/loyalty-program.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema()
export class Tier {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  minPoints: number;

  @Prop() // Thêm trường maxPoints
  maxPoints?: number; // Số điểm tối đa của cấp bậc (tùy chọn nếu không có giới hạn trên)

  @Prop({
    type: [
      {
        type: { type: String, enum: ['Giảm giá', 'Miễn phí vận chuyển', 'Quà tặng', 'Quyền truy cập đặc biệt'] },
        value: Number,
        description: String,
      },
    ],
  })
  benefits: { type: string; value: number; description: string }[];
}

export const TierSchema = SchemaFactory.createForClass(Tier);

@Schema()
export class Reward {
  @Prop({ required: true, unique: true }) // Thêm rewardId để định danh
  rewardId: string;

  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  points: number;

  @Prop()
  description: string;

  @Prop()
  image: string;

  @Prop({ default: 0 })
  stock: number;

  @Prop({ enum: ['Có sẵn', 'Hết hàng', 'Không hoạt động'], default: 'Có sẵn' })
  status: string;

  // Gợi ý nâng cấp
  @Prop({ type: Date })
  expiryDate?: Date; // Ngày hết hạn phần thưởng
}

export const RewardSchema = SchemaFactory.createForClass(Reward);

@Schema({ timestamps: true, collection: 'LoyaltyPrograms' })
export class LoyaltyProgram extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ enum: ['Đang hoạt động', 'Ngừng hoạt động'], default: 'Đang hoạt động' })
  status: string;

  @Prop({
    type: {
      earnRate: Number,
      minPoints: Number,
      pointValue: Number,
      expiryDays: Number,
    },
  })
  pointRules: {
    earnRate: number; // Tỷ lệ kiếm điểm (ví dụ: 1 điểm mỗi 1000 VNĐ)
    minPoints: number; // Điểm tối thiểu để sử dụng
    pointValue: number; // Giá trị quy đổi (ví dụ: 1 điểm = 100 VNĐ)
    expiryDays: number; // Số ngày điểm hết hạn
  };

  @Prop({ type: [TierSchema] })
  tiers: Tier[];

  @Prop({ type: [RewardSchema] })
  rewards: Reward[];

  @Prop({
    type: {
      totalMembers: { type: Number, default: 0 },
      totalPointsIssued: { type: Number, default: 0 },
      totalPointsRedeemed: { type: Number, default: 0 },
      totalRewardsRedeemed: { type: Number, default: 0 },
      totalRevenueFromLoyalty: { type: Number, default: 0 }, // Thêm
    },
  })
  statistics: {
    totalMembers: number;
    totalPointsIssued: number;
    totalPointsRedeemed: number;
    totalRewardsRedeemed: number;
    totalRevenueFromLoyalty: number; // Doanh thu từ chương trình
  };

  // Gợi ý nâng cấp
  @Prop({ type: [{ type: Types.ObjectId, ref: 'Customers' }] })
  members?: Types.ObjectId[]; // Danh sách khách hàng tham gia
}

export const LoyaltyProgramSchema = SchemaFactory.createForClass(LoyaltyProgram);

// Indexes (giữ nguyên và bổ sung)
LoyaltyProgramSchema.index({ storeId: 1 });
LoyaltyProgramSchema.index({ status: 1 });
LoyaltyProgramSchema.index({ 'tiers.minPoints': 1 });
LoyaltyProgramSchema.index({ 'rewards.points': 1 });
LoyaltyProgramSchema.index({ 'rewards.status': 1 });
LoyaltyProgramSchema.index({ 'rewards.rewardId': 1 }); // Thêm index cho rewardId

================
File: loyalty-program/services/loyalty-program.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { LoyaltyProgram } from '../schemas/loyalty-program.schema';

@Injectable()
export class LoyaltyProgramService {
  constructor(
    @InjectModel('LoyaltyPrograms') private loyaltyProgramModel: Model<LoyaltyProgram>,
  ) { }

  async create(createLoyaltyProgramDto: any): Promise<LoyaltyProgram> {
    const createdProgram = new this.loyaltyProgramModel(createLoyaltyProgramDto);
    return createdProgram.save();
  }

  async findAll(): Promise<LoyaltyProgram[]> {
    return this.loyaltyProgramModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('customerGroup')
      .exec();
  }

  async findOne(id: string): Promise<LoyaltyProgram> {
    const program = await this.loyaltyProgramModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('customerGroup')
      .exec();
    if (!program) {
      throw new NotFoundException(`Loyalty program with ID ${id} not found`);
    }
    return program;
  }

  async update(id: string, updateLoyaltyProgramDto: any): Promise<LoyaltyProgram> {
    const program = await this.loyaltyProgramModel
      .findByIdAndUpdate(id, updateLoyaltyProgramDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('customerGroup')
      .exec();
    if (!program) {
      throw new NotFoundException(`Loyalty program with ID ${id} not found`);
    }
    return program;
  }

  async remove(id: string): Promise<LoyaltyProgram> {
    const program = await this.loyaltyProgramModel.findByIdAndDelete(id).exec();
    if (!program) {
      throw new NotFoundException(`Loyalty program with ID ${id} not found`);
    }
    return program;
  }
}

================
File: marketing-campaign/controllers/marketing-campaign.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { MarketingCampaignService } from '../services/marketing-campaign.service';
import { MarketingCampaign } from '../schemas/marketing-campaign.schema';
import { CreateMarketingCampaignDTO, UpdateMarketingCampaignDTO } from '../dtos/marketing-campaign.dto';
@Controller('marketing-campaigns')
export class MarketingCampaignController {
  constructor(private readonly marketingCampaignService: MarketingCampaignService) { }

  @Post()
  async create(@Body() createCampaignDto: CreateMarketingCampaignDTO): Promise<MarketingCampaign> {
    return this.marketingCampaignService.create(createCampaignDto);
  }

  @Get()
  async findAll(
    @Query('branchId') branchId?: string,
    @Query('status') status?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('type') type?: string,
  ): Promise<MarketingCampaign[]> {
    // TODO: Implement filtering logic in service
    return this.marketingCampaignService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateCampaignDto: UpdateMarketingCampaignDTO,
  ): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, updateCampaignDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status });
  }

  @Post(':id/launch')
  async launch(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'active' });
  }

  @Post(':id/pause')
  async pause(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'paused' });
  }

  @Post(':id/resume')
  async resume(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'active' });
  }

  @Post(':id/complete')
  async complete(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'completed' });
  }

}

================
File: marketing-campaign/dtos/marketing-campaign.dto.ts
================
// MarketingCampaignDTO: Đại diện toàn bộ schema
export class MarketingCampaignDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên chiến dịch
  type: string; // Loại chiến dịch
  description: string; // Mô tả
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  status: string; // Trạng thái
  conditions: {
    minOrderValue: number;
    maxDiscount: number;
    applicableProducts: string[];
    applicableCategories: string[];
    applicableCustomerGroups: string[];
    usageLimit: number;
    usagePerCustomer: number;
  }; // Điều kiện
  rewards: {
    discountType: string;
    discountValue: number;
    freeShipping: boolean;
    giftProduct: string;
    bundleProducts: { product: string; quantity: number }[];
    loyaltyPoints: number;
  }; // Phần thưởng
  statistics: {
    totalUsage: number;
    totalRevenue: number;
    totalCustomers: number;
  }; // Thống kê
}

// CreateMarketingCampaignDTO: Dùng để tạo mới
export class CreateMarketingCampaignDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên chiến dịch
  type: string; // Loại chiến dịch
  description: string; // Mô tả
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  status: string; // Trạng thái
  conditions: {
    minOrderValue: number;
    maxDiscount: number;
    applicableProducts: string[];
    applicableCategories: string[];
    applicableCustomerGroups: string[];
    usageLimit: number;
    usagePerCustomer: number;
  }; // Điều kiện
  rewards: {
    discountType: string;
    discountValue: number;
    freeShipping: boolean;
    giftProduct: string;
    bundleProducts: { product: string; quantity: number }[];
    loyaltyPoints: number;
  }; // Phần thưởng
}

// UpdateMarketingCampaignDTO: Dùng để cập nhật
export class UpdateMarketingCampaignDTO {
  name?: string; // Tên chiến dịch
  type?: string; // Loại chiến dịch
  description?: string; // Mô tả
  startDate?: Date; // Ngày bắt đầu
  endDate?: Date; // Ngày kết thúc
  status?: string; // Trạng thái
  conditions?: {
    minOrderValue?: number;
    maxDiscount?: number;
    applicableProducts?: string[];
    applicableCategories?: string[];
    applicableCustomerGroups?: string[];
    usageLimit?: number;
    usagePerCustomer?: number;
  }; // Điều kiện
  rewards?: {
    discountType?: string;
    discountValue?: number;
    freeShipping?: boolean;
    giftProduct?: string;
    bundleProducts?: { product: string; quantity: number }[];
    loyaltyPoints?: number;
  }; // Phần thưởng
  statistics?: {
    totalUsage?: number;
    totalRevenue?: number;
    totalCustomers?: number;
  }; // Thống kê
}

================
File: marketing-campaign/marketing-campaign.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MarketingCampaignSchema } from './schemas/marketing-campaign.schema';
import { MarketingCampaignController } from './controllers/marketing-campaign.controller';
import { MarketingCampaignService } from './services/marketing-campaign.service';
@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'MarketingCampaigns', schema: MarketingCampaignSchema }])
  ],
  controllers: [MarketingCampaignController],
  providers: [MarketingCampaignService],
  exports: [MarketingCampaignService]
})
export class MarketingCampaignModule { }

================
File: marketing-campaign/schemas/marketing-campaign.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'MarketingCampaigns' })
export class MarketingCampaign extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên chiến dịch

  @Prop({ enum: ['discount', 'free_shipping', 'gift', 'bundle', 'loyalty_points'], required: true })
  type: string; // Loại chiến dịch

  @Prop()
  description: string; // Mô tả

  @Prop({ required: true })
  startDate: Date; // Ngày bắt đầu

  @Prop({ required: true })
  endDate: Date; // Ngày kết thúc

  @Prop({ enum: ['draft', 'active', 'paused', 'ended', 'cancelled'], default: 'draft' })
  status: string; // Trạng thái

  @Prop({ type: { minOrderValue: Number, maxDiscount: Number, applicableProducts: [Types.ObjectId], applicableCategories: [Types.ObjectId], applicableCustomerGroups: [Types.ObjectId], usageLimit: Number, usagePerCustomer: Number } })
  conditions: {
    minOrderValue: number; // Giá trị đơn hàng tối thiểu
    maxDiscount: number; // Chiết khấu tối đa
    applicableProducts: Types.ObjectId[]; // Sản phẩm áp dụng
    applicableCategories: Types.ObjectId[]; // Danh mục áp dụng
    applicableCustomerGroups: Types.ObjectId[]; // Nhóm khách hàng áp dụng
    usageLimit: number; // Giới hạn sử dụng
    usagePerCustomer: number; // Giới hạn sử dụng mỗi khách
  };

  @Prop({ type: { discountType: String, discountValue: Number, freeShipping: Boolean, giftProduct: Types.ObjectId, bundleProducts: [{ product: Types.ObjectId, quantity: Number }], loyaltyPoints: Number } })
  rewards: {
    discountType: string; // Loại chiết khấu
    discountValue: number; // Giá trị chiết khấu
    freeShipping: boolean; // Miễn phí vận chuyển
    giftProduct: Types.ObjectId; // Sản phẩm tặng
    bundleProducts: { product: Types.ObjectId; quantity: number }[]; // Gói sản phẩm
    loyaltyPoints: number; // Điểm khách hàng thân thiết
  };

  @Prop({ type: { totalUsage: Number, totalRevenue: Number, totalCustomers: Number } })
  statistics: {
    totalUsage: number; // Tổng lần sử dụng
    totalRevenue: number; // Tổng doanh thu
    totalCustomers: number; // Tổng khách hàng
  };
}

export const MarketingCampaignSchema = SchemaFactory.createForClass(MarketingCampaign);

================
File: marketing-campaign/services/marketing-campaign.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MarketingCampaign } from '../schemas/marketing-campaign.schema';
import { CreateMarketingCampaignDTO, UpdateMarketingCampaignDTO } from '../dtos/marketing-campaign.dto';
@Injectable()
export class MarketingCampaignService {
  constructor(
    @InjectModel('MarketingCampaigns') private marketingCampaignModel: Model<MarketingCampaign>,
  ) { }

  async create(createMarketingCampaignDto: CreateMarketingCampaignDTO): Promise<MarketingCampaign> {
    const createdCampaign = new this.marketingCampaignModel(createMarketingCampaignDto);
    return createdCampaign.save();
  }

  async findAll(): Promise<MarketingCampaign[]> {
    return this.marketingCampaignModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('targetCustomers')
      .populate('products')
      .exec();
  }

  async findOne(id: string): Promise<MarketingCampaign> {
    const campaign = await this.marketingCampaignModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('targetCustomers')
      .populate('products')
      .exec();
    if (!campaign) {
      throw new NotFoundException(`Marketing campaign with ID ${id} not found`);
    }
    return campaign;
  }

  async update(id: string, updateMarketingCampaignDto: UpdateMarketingCampaignDTO): Promise<MarketingCampaign> {
    const campaign = await this.marketingCampaignModel
      .findByIdAndUpdate(id, updateMarketingCampaignDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('targetCustomers')
      .populate('products')
      .exec();
    if (!campaign) {
      throw new NotFoundException(`Marketing campaign with ID ${id} not found`);
    }
    return campaign;
  }

  async remove(id: string): Promise<MarketingCampaign> {
    const campaign = await this.marketingCampaignModel.findByIdAndDelete(id).exec();
    if (!campaign) {
      throw new NotFoundException(`Marketing campaign with ID ${id} not found`);
    }
    return campaign;
  }
}

================
File: marketplace-listing/controllers/marketplace-listing.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { MarketplaceListingService } from '../services/marketplace-listing.service';
import { CreateMarketplaceListingDTO, UpdateMarketplaceListingDTO } from '../dtos/marketplace-listing.dto';
@Controller('marketplace-listings')
export class MarketplaceListingController {
  constructor(private readonly marketplaceListingService: MarketplaceListingService) { }

  @Post()
  create(@Body() createMarketplaceListingDto: CreateMarketplaceListingDTO) {
    return this.marketplaceListingService.create(createMarketplaceListingDto);
  }

  @Get()
  findAll() {
    return this.marketplaceListingService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.marketplaceListingService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateMarketplaceListingDto: UpdateMarketplaceListingDTO) {
    return this.marketplaceListingService.update(id, updateMarketplaceListingDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.marketplaceListingService.remove(id);
  }
}

================
File: marketplace-listing/dtos/marketplace-listing.dto.ts
================
// MarketplaceListingDTO: Đại diện toàn bộ schema
export class MarketplaceListingDTO {
  storeId: string; // Mã cửa hàng
  productId: string; // Mã sản phẩm
  marketplace: string; // Tên sàn
  listingId: string; // Mã listing
  listingUrl: string; // Đường dẫn
  title: string; // Tiêu đề
  description: string; // Mô tả
  images: string[]; // Ảnh
  price: number; // Giá
  originalPrice: number; // Giá gốc
  stock: number; // Tồn kho
  sku: string; // SKU
  attributes: { name: string; value: string }[]; // Thuộc tính
  category: string; // Danh mục
  subCategory: string; // Danh mục con
  shipping: {
    methods: string[];
    weight: number;
    dimensions: {
      length: number;
      width: number;
      height: number;
    };
  }; // Vận chuyển
  sales: {
    totalSales: number;
    totalRevenue: number;
    rating: number;
    reviews: number;
  }; // Doanh số
  status: string; // Trạng thái
  lastSync: Date; // Đồng bộ cuối
  syncStatus: string; // Trạng thái đồng bộ
  syncError: string; // Lỗi đồng bộ
}

// CreateMarketplaceListingDTO: Dùng để tạo mới
export class CreateMarketplaceListingDTO {
  storeId: string; // Mã cửa hàng
  productId: string; // Mã sản phẩm
  marketplace: string; // Tên sàn
  title: string; // Tiêu đề
  description: string; // Mô tả
  images: string[]; // Ảnh
  price: number; // Giá
  originalPrice: number; // Giá gốc
  stock: number; // Tồn kho
  sku: string; // SKU
  attributes: { name: string; value: string }[]; // Thuộc tính
  category: string; // Danh mục
  subCategory: string; // Danh mục con
  shipping: {
    methods: string[];
    weight: number;
    dimensions: {
      length: number;
      width: number;
      height: number;
    };
  }; // Vận chuyển
  status: string; // Trạng thái
}

// UpdateMarketplaceListingDTO: Dùng để cập nhật
export class UpdateMarketplaceListingDTO {
  title?: string; // Tiêu đề
  description?: string; // Mô tả
  images?: string[]; // Ảnh
  price?: number; // Giá
  originalPrice?: number; // Giá gốc
  stock?: number; // Tồn kho
  sku?: string; // SKU
  attributes?: { name: string; value: string }[]; // Thuộc tính
  category?: string; // Danh mục
  subCategory?: string; // Danh mục con
  shipping?: {
    methods?: string[];
    weight?: number;
    dimensions?: {
      length?: number;
      width?: number;
      height?: number;
    };
  }; // Vận chuyển
  status?: string; // Trạng thái
  syncStatus?: string; // Trạng thái đồng bộ
  syncError?: string; // Lỗi đồng bộ
}

================
File: marketplace-listing/marketplace-listing.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MarketplaceListingSchema } from './schemas/marketplace-listing.schema';
import { MarketplaceListingController } from './controllers/marketplace-listing.controller';
import { MarketplaceListingService } from './services/marketplace-listing.service';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'MarketplaceListings', schema: MarketplaceListingSchema }
    ])
  ],
  controllers: [MarketplaceListingController],
  providers: [MarketplaceListingService],
  exports: [MarketplaceListingService]
})
export class MarketplaceListingModule { }

================
File: marketplace-listing/schemas/marketplace-listing.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'MarketplaceListings' })
export class MarketplaceListing extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Products', required: true })
  productId: Types.ObjectId; // Mã sản phẩm

  @Prop({ enum: ['Shopee', 'Lazada', 'Tiki', 'Sendo', 'ZaloShop', 'FacebookShop'], required: true })
  marketplace: string; // Tên sàn thương mại

  @Prop()
  listingId: string; // Mã listing trên sàn

  @Prop()
  listingUrl: string; // Đường dẫn listing

  @Prop({ required: true })
  title: string; // Tiêu đề listing

  @Prop()
  description: string; // Mô tả

  @Prop([String])
  images: string[]; // Ảnh

  @Prop({ required: true })
  price: number; // Giá

  @Prop()
  originalPrice: number; // Giá gốc

  @Prop({ required: true })
  stock: number; // Tồn kho

  @Prop()
  sku: string; // Mã SKU

  @Prop({ type: [{ name: String, value: String }] })
  attributes: { name: string; value: string }[]; // Thuộc tính

  @Prop()
  category: string; // Danh mục

  @Prop()
  subCategory: string; // Danh mục con

  @Prop({ type: { methods: [String], weight: Number, dimensions: { length: Number, width: Number, height: Number } } })
  shipping: {
    methods: string[]; // Phương thức vận chuyển
    weight: number; // Trọng lượng
    dimensions: {
      length: number; // Chiều dài
      width: number; // Chiều rộng
      height: number; // Chiều cao
    };
  };

  @Prop({ type: { totalSales: Number, totalRevenue: Number, rating: Number, reviews: Number } })
  sales: {
    totalSales: number; // Tổng bán
    totalRevenue: number; // Tổng doanh thu
    rating: number; // Đánh giá
    reviews: number; // Số đánh giá
  };

  @Prop({ enum: ['active', 'paused', 'deleted', 'error'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  lastSync: Date; // Thời gian đồng bộ cuối

  @Prop({ enum: ['success', 'failed', 'processing'], default: 'success' })
  syncStatus: string; // Trạng thái đồng bộ

  @Prop()
  syncError: string; // Lỗi đồng bộ
}

export const MarketplaceListingSchema = SchemaFactory.createForClass(MarketplaceListing);

================
File: marketplace-listing/services/marketplace-listing.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MarketplaceListing } from '../schemas/marketplace-listing.schema';
import { CreateMarketplaceListingDTO, UpdateMarketplaceListingDTO } from '../dtos/marketplace-listing.dto';
@Injectable()
export class MarketplaceListingService {
  constructor(
    @InjectModel(MarketplaceListing.name)
    private marketplaceListingModel: Model<MarketplaceListing>,
  ) {}

  async create(createMarketplaceListingDto: CreateMarketplaceListingDTO): Promise<MarketplaceListing> {
    const createdListing = new this.marketplaceListingModel(createMarketplaceListingDto);
    return createdListing.save();
  }

  async findAll(): Promise<MarketplaceListing[]> {
    return this.marketplaceListingModel.find().exec();
  }

  async findOne(id: string): Promise<MarketplaceListing> {
    const listing = await this.marketplaceListingModel.findById(id).exec();
    if (!listing) {
      throw new NotFoundException(`Marketplace listing with ID ${id} not found`);
    }
    return listing;
  }

  async update(id: string, updateMarketplaceListingDto: UpdateMarketplaceListingDTO): Promise<MarketplaceListing> {
    const updatedListing = await this.marketplaceListingModel
      .findByIdAndUpdate(id, updateMarketplaceListingDto, { new: true })
      .exec();
    if (!updatedListing) {
      throw new NotFoundException(`Marketplace listing with ID ${id} not found`);
    }
    return updatedListing;
  }

  async remove(id: string): Promise<MarketplaceListing> {
    const deletedListing = await this.marketplaceListingModel.findByIdAndDelete(id).exec();
    if (!deletedListing) {
      throw new NotFoundException(`Marketplace listing with ID ${id} not found`);
    }
    return deletedListing;
  }
}

================
File: order/controllers/order.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { OrderService } from '../services/order.service';
import { CreateOrderDTO, UpdateOrderDTO } from '../dtos/order.dto';
@Controller('api/orders')
export class OrderController {
  constructor(private readonly orderService: OrderService) { }

  @Post()
  create(@Body() createOrderDto: CreateOrderDTO) {
    return this.orderService.create(createOrderDto);
  }

  @Get()
  findAll() {
    return this.orderService.findAll();
  }

  @Get('doanhthu')
  doanhThu() {
    return this.orderService.doanhThu();
  }
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.orderService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateOrderDto: UpdateOrderDTO) {
    return this.orderService.update(id, updateOrderDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.orderService.remove(id);
  }
}

================
File: order/dtos/order.dto.ts
================
// OrderDTO: Đại diện toàn bộ schema
export class OrderDTO {
  orderId: string; // Mã đơn hàng
  orderCode: string; // Mã hiển thị
  customerId: string; // Mã khách hàng
  products: { productId: string; quantity: number; price: number; discount: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  discount: number; // Chiết khấu
  paymentMethod: string; // Phương thức thanh toán
  status: string; // Trạng thái
  channel: string; // Mã kênh
  carrierId: string; // Mã đơn vị vận chuyển
  deliveryDate: Date; // Ngày giao hàng
}

// CreateOrderDTO: Dùng để tạo mới
export class CreateOrderDTO {
  customerId: string; // Mã khách hàng
  products: { productId: string; quantity: number; price: number; discount: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  discount: number; // Chiết khấu
  paymentMethod: string; // Phương thức thanh toán
  status: string; // Trạng thái
  channel: string; // Mã kênh
  carrierId: string; // Mã đơn vị vận chuyển
  deliveryDate: Date; // Ngày giao hàng
}

// UpdateOrderDTO: Dùng để cập nhật
export class UpdateOrderDTO {
  customerId?: string; // Mã khách hàng
  products?: { productId: string; quantity: number; price: number; discount: number }[]; // Sản phẩm
  totalAmount?: number; // Tổng tiền
  discount?: number; // Chiết khấu
  paymentMethod?: string; // Phương thức thanh toán
  status?: string; // Trạng thái
  channel?: string; // Mã kênh
  carrierId?: string; // Mã đơn vị vận chuyển
  deliveryDate?: Date; // Ngày giao hàng
}

================
File: order/order.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { OrderController } from './controllers/order.controller';
import { OrderService } from './services/order.service';
import { Order, OrderSchema } from './schemas/order.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Orders', schema: OrderSchema }])
  ],
  controllers: [OrderController],
  providers: [OrderService],
  exports: [OrderService]
})
export class OrderModule { }

================
File: order/schemas/order.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Orders' })
export class Order extends Document {
  @Prop({ unique: true, required: true })
  orderId: string; // Mã đơn hàng

  @Prop({ unique: true, required: true })
  orderCode: string; // Mã đơn hàng hiển thị

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number, price: Number, discount: Number }] })
  products: { productId: Types.ObjectId; quantity: number; price: number; discount: number }[]; // Sản phẩm

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền

  @Prop({ default: 0 })
  discount: number; // Chiết khấu

  @Prop({ enum: ['cash', 'bank_transfer', 'card', 'wallet'] })
  paymentMethod: string; // Phương thức thanh toán

  @Prop({ enum: ['pending', 'confirmed', 'shipping', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels' })
  channel: Types.ObjectId; // Mã kênh bán hàng

  @Prop({ type: Types.ObjectId, ref: 'Carriers' })
  carrierId: Types.ObjectId; // Mã đơn vị vận chuyển

  @Prop()
  deliveryDate: Date; // Ngày giao hàng
}

export const OrderSchema = SchemaFactory.createForClass(Order);

================
File: order/services/order.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Order } from '../schemas/order.schema';

@Injectable()
export class OrderService {
  constructor(
    @InjectModel('Orders') private orderModel: Model<Order>,
  ) { }

  async create(createOrderDto: any): Promise<Order> {
    const lastOrder = await this.orderModel.findOne().sort({ orderId: -1 }).exec();
    let newOrderId = 'HD00001';
  
    if (lastOrder && lastOrder.orderId) {
      const lastNumber = parseInt(lastOrder.orderId.replace('HD', ''), 10);
      const nextNumber = lastNumber + 1;
      newOrderId = `HD${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdOrder = new this.orderModel({
      ...createOrderDto,
      orderId: newOrderId
    });
  
    return createdOrder.save();
  }

  async findAll(): Promise<Order[]> {
    return this.orderModel
      .find()
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
  }
  async doanhThu(): Promise<Order[]> {
    return this.orderModel
      .find()
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .populate('products.productId.priceList')
      .exec();
  }
  async findOne(id: string): Promise<Order> {
    const order = await this.orderModel
      .findById(id)
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  async update(id: string, updateOrderDto: any): Promise<Order> {
    const order = await this.orderModel
      .findByIdAndUpdate(id, updateOrderDto, { new: true })
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  async remove(id: string): Promise<Order> {
    const order = await this.orderModel.findByIdAndDelete(id).exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

}

================
File: payroll/controllers/payroll.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Payroll } from '../schemas/payroll.schema';
import { PayrollService } from '../services/payroll.service';
import { CreatePayrollDTO, UpdatePayrollDTO } from '../dtos/payroll.dto';

@Controller('api/payrolls')
export class PayrollController {
  constructor(private readonly payrollService: PayrollService) { }

  @Post()
  async create(@Body() createPayrollDto: CreatePayrollDTO): Promise<Payroll> {
    return this.payrollService.create(createPayrollDto);
  }

  @Get()
  findAll() {
    return this.payrollService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.payrollService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatepayrollDto: UpdatePayrollDTO) {
    return this.payrollService.update(id, updatepayrollDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.payrollService.remove(id);
  }
}

================
File: payroll/dtos/payroll.dto.ts
================
// PayrollDTO: Đại diện toàn bộ schema
export class PayrollDTO {
  payrollId: string; // Mã bảng lương
  employeeId: string; // Mã nhân viên
  month: number; // Tháng
  year: number; // Năm
  basicSalary: number; // Lương cơ bản
  bonus: number; // Thưởng
  commission: number; // Hoa hồng
  allowance: number; // Phụ cấp
  deduction: number; // Khấu trừ
  total: number; // Tổng lương
  paid: number; // Đã trả
  status: string; // Trạng thái
  branch: string; // Mã chi nhánh
}

// CreatePayrollDTO: Dùng để tạo mới
export class CreatePayrollDTO {
  employeeId: string; // Mã nhân viên
  month: number; // Tháng
  year: number; // Năm
  basicSalary: number; // Lương cơ bản
  bonus: number; // Thưởng
  commission: number; // Hoa hồng
  allowance: number; // Phụ cấp
  deduction: number; // Khấu trừ
  total: number; // Tổng lương
  paid: number; // Đã trả
  status: string; // Trạng thái
  branch: string; // Mã chi nhánh
}

// UpdatePayrollDTO: Dùng để cập nhật
export class UpdatePayrollDTO {
  month?: number; // Tháng
  year?: number; // Năm
  basicSalary?: number; // Lương cơ bản
  bonus?: number; // Thưởng
  commission?: number; // Hoa hồng
  allowance?: number; // Phụ cấp
  deduction?: number; // Khấu trừ
  total?: number; // Tổng lương
  paid?: number; // Đã trả
  status?: string; // Trạng thái
  branch?: string; // Mã chi nhánh
}

================
File: payroll/payroll.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Payroll, PayrollSchema } from './schemas/payroll.schema';
import { PayrollController } from './controllers/payroll.controller';
import { PayrollService } from  './services/payroll.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Payrolls', schema: PayrollSchema }])
  ],
  controllers: [PayrollController],
  providers: [PayrollService],
  exports: [PayrollService]
})
export class PayrollModule { }

================
File: payroll/schemas/payroll.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Payrolls' })
export class Payroll extends Document {
  @Prop({ unique: true, required: true })
  payrollId: string; // Mã bảng lương

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId; // Mã nhân viên

  @Prop({ required: true })
  month: number; // Tháng

  @Prop({ required: true })
  year: number; // Năm

  @Prop({ required: true })
  basicSalary: number; // Lương cơ bản

  @Prop({ default: 0 })
  bonus: number; // Thưởng

  @Prop({ default: 0 })
  commission: number; // Hoa hồng

  @Prop({ default: 0 })
  allowance: number; // Phụ cấp

  @Prop({ default: 0 })
  deduction: number; // Khấu trừ

  @Prop({ required: true })
  total: number; // Tổng lương

  @Prop({ default: 0 })
  paid: number; // Đã trả

  @Prop({ enum: ['creating', 'calculated', 'confirmed', 'cancelled'], default: 'creating' })
  status: string; // Trạng thái

  @Prop({ type: Types.ObjectId, ref: 'Branches', required: true })
  branch: Types.ObjectId; // Mã chi nhánh
}

export const PayrollSchema = SchemaFactory.createForClass(Payroll);

================
File: payroll/services/payroll.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Payroll } from '../schemas/payroll.schema';
import { CreatePayrollDTO, UpdatePayrollDTO } from '../dtos/payroll.dto';
@Injectable()
export class PayrollService {
  constructor(
    @InjectModel('Payrolls') private payrollModel: Model<Payroll>,
  ) { }

  async create(createPayrollDto: CreatePayrollDTO): Promise<Payroll> {
    const lastPayroll = await this.payrollModel.findOne().sort({ payrollId: -1 }).exec();
    let newPayrollId = 'PR00001';
  
    if (lastPayroll && lastPayroll.payrollId) {
      const lastNumber = parseInt(lastPayroll.payrollId.replace('PR', ''), 10);
      const nextNumber = lastNumber + 1;
      newPayrollId = `PR${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdPayroll = new this.payrollModel({
      ...createPayrollDto,
      payrollId: newPayrollId
    });
  
    return createdPayroll.save();
  }

  async findAll(): Promise<Payroll[]> {
    return this.payrollModel.find().exec();
  }

  async findOne(id: string): Promise<Payroll> {
    const payroll = await this.payrollModel.findById(id).exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }

  async update(id: string, updatePayrollDto: UpdatePayrollDTO): Promise<Payroll> {
    const payroll = await this.payrollModel
      .findByIdAndUpdate(id, updatePayrollDto, { new: true })
      .exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }

  async remove(id: string): Promise<Payroll> {
    const payroll = await this.payrollModel.findByIdAndDelete(id).exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }
}

================
File: position/controllers/position.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Position } from '../schemas/position.schema';
import { PositionService } from '../services/position.service';

@Controller('api/positions')
export class PositionController {
  constructor(private readonly positionService: PositionService) { }

  @Post()
  async create(@Body() createPositionDto: any): Promise<Position> {
    return this.positionService.create(createPositionDto);
  }

  @Get()
  findAll() {
    return this.positionService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.positionService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePositionDto: any) {
    return this.positionService.update(id, updatePositionDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.positionService.remove(id);
  }
}

================
File: position/dtos/position.dto.ts
================
// PositionDTO: Đại diện toàn bộ schema
export class PositionDTO {
  positionId: string; // Mã vị trí
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreatePositionDTO: Dùng để tạo mới
export class CreatePositionDTO {
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
}

// UpdatePositionDTO: Dùng để cập nhật
export class UpdatePositionDTO {
  name?: string; // Tên
  description?: string; // Mô tả
  status?: string; // Trạng thái
}

================
File: position/position.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Position, PositionSchema } from './schemas/position.schema';
import { PositionService } from './services/position.service';
import { PositionController } from  './controllers/position.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Positions', schema: PositionSchema }])
  ],
  controllers: [PositionController],
  providers: [PositionService],
  exports: [PositionService]
})
export class PositionModule { }

================
File: position/schemas/position.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Positions' })
export class Position extends Document {
  @Prop({ unique: true, required: true })
  positionId: string; // Mã vị trí

  @Prop({ required: true })
  name: string; // Tên vị trí

  @Prop()
  description: string; // Mô tả

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const PositionSchema = SchemaFactory.createForClass(Position);

================
File: position/services/position.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Position } from '../schemas/position.schema';
import { CreatePositionDTO, UpdatePositionDTO } from '../dtos/position.dto';
@Injectable()
export class PositionService {
  constructor(
    @InjectModel('Positions') private PositionModel: Model<Position>,
  ) { }

  async create(createPositionDto: CreatePositionDTO): Promise<Position> {
    const lastPosition = await this.PositionModel.findOne().sort({ positionId: -1 }).exec();
    let newPositionId = 'CV00001';
  
    if (lastPosition && lastPosition.positionId) {
      const lastNumber = parseInt(lastPosition.positionId.replace('CV', ''), 10);
      const nextNumber = lastNumber + 1;
      newPositionId = `CV${nextNumber.toString().padStart(5, '0')}`;
    }

    const createdPosition = new this.PositionModel({
      ...createPositionDto,
      positionId: newPositionId
    });
  
    return createdPosition.save();
  }

  async findAll(): Promise<Position[]> {
    return this.PositionModel.find().exec();
  }

  async findOne(id: string): Promise<Position> {
    const position = await this.PositionModel.findById(id).exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }

  async update(id: string, updatePositionDto: UpdatePositionDTO): Promise<Position> {
    const position = await this.PositionModel
      .findByIdAndUpdate(id, updatePositionDto, { new: true })
      .exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }

  async remove(id: string): Promise<Position> {
    const position = await this.PositionModel.findByIdAndDelete(id).exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }
}

================
File: price-list/controllers/price-list.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { PriceListService } from '../services/price-list.service';
import { CreatePriceListDTO, UpdatePriceListDTO } from '../dtos/price-list.dto';
import { PriceList } from '../schemas/price-list.schema';

@Controller('price-lists')
export class PriceListController {
  constructor(private readonly priceListService: PriceListService) { }

  @Post()
  async create(@Body() createPriceListDto: CreatePriceListDTO): Promise<PriceList> {
    return this.priceListService.create(createPriceListDto);
  }

  @Get()
  async findAll(
    @Query('branchId') branchId?: string,
    @Query('status') status?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
  ): Promise<PriceList[]> {
    // TODO: Implement filtering logic in service
    return this.priceListService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<PriceList> {
    return this.priceListService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updatePriceListDto: UpdatePriceListDTO,
  ): Promise<PriceList> {
    return this.priceListService.update(id, updatePriceListDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<PriceList> {
    return this.priceListService.remove(id);
  }

  @Put(':id/activate')
  async activate(@Param('id') id: string): Promise<PriceList> {
    const updateDto = { status: 'active' };
    return this.priceListService.update(id, updateDto);
  }

  @Put(':id/deactivate')
  async deactivate(@Param('id') id: string): Promise<PriceList> {
    const updateDto = { status: 'inactive' };
    return this.priceListService.update(id, updateDto);
  }
}

================
File: price-list/dtos/price-list.dto.ts
================
// PriceListDTO: Đại diện toàn bộ schema
export class PriceListDTO {
  priceListId: string; // Mã bảng giá
  storeId: string; // Mã cửa hàng
  name: string; // Tên
  description: string; // Mô tả
  type: string; // Loại
  status: string; // Trạng thái
  validFrom: Date; // Ngày bắt đầu
  validTo: Date; // Ngày kết thúc
  products: { productId: string; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm
  customerGroups: string[]; // Nhóm khách hàng
  conditions: {
    minOrderValue: number;
    maxOrderValue: number;
    paymentMethods: string[];
    locations: string[];
  }; // Điều kiện
}

// CreatePriceListDTO: Dùng để tạo mới
export class CreatePriceListDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên
  description: string; // Mô tả
  type: string; // Loại
  status: string; // Trạng thái
  validFrom: Date; // Ngày bắt đầu
  validTo: Date; // Ngày kết thúc
  products: { productId: string; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm
  customerGroups: string[]; // Nhóm khách hàng
  conditions: {
    minOrderValue: number;
    maxOrderValue: number;
    paymentMethods: string[];
    locations: string[];
  }; // Điều kiện
}

// UpdatePriceListDTO: Dùng để cập nhật
export class UpdatePriceListDTO {
  name?: string; // Tên
  description?: string; // Mô tả
  type?: string; // Loại
  status?: string; // Trạng thái
  validFrom?: Date; // Ngày bắt đầu
  validTo?: Date; // Ngày kết thúc
  products?: { productId: string; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm
  customerGroups?: string[]; // Nhóm khách hàng
  conditions?: {
    minOrderValue?: number;
    maxOrderValue?: number;
    paymentMethods?: string[];
    locations?: string[];
  }; // Điều kiện
}

================
File: price-list/price-list.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PriceListSchema } from './schemas/price-list.schema';
import { PriceListService } from './services/price-list.service';
import { PriceListController } from  './controllers/price-list.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PriceLists', schema: PriceListSchema }])
  ],
  controllers: [PriceListController],
  providers: [PriceListService],
  exports: [PriceListService]
})
export class PriceListModule { }

================
File: price-list/schemas/price-list.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PriceLists' })
export class PriceList extends Document {
  @Prop({ unique: true, required: true })
  priceListId: string; // Mã bảng giá

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên bảng giá

  @Prop()
  description: string; // Mô tả

  @Prop({ enum: ['retail', 'wholesale', 'agency', 'promotion'], required: true })
  type: string; // Loại bảng giá

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  validFrom: Date; // Ngày bắt đầu

  @Prop()
  validTo: Date; // Ngày kết thúc

  @Prop({ type: [{ productId: Types.ObjectId, price: Number, minQuantity: Number, maxQuantity: Number, discount: Number, discountType: String }] })
  products: { productId: Types.ObjectId; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm

  @Prop({ type: [Types.ObjectId], ref: 'CustomerGroups' })
  customerGroups: Types.ObjectId[]; // Nhóm khách hàng

  @Prop({ type: { minOrderValue: Number, maxOrderValue: Number, paymentMethods: [String], locations: [String] } })
  conditions: {
    minOrderValue: number; // Giá trị đơn hàng tối thiểu
    maxOrderValue: number; // Giá trị đơn hàng tối đa
    paymentMethods: string[]; // Phương thức thanh toán
    locations: string[]; // Vị trí
  };
}

export const PriceListSchema = SchemaFactory.createForClass(PriceList);

================
File: price-list/services/price-list.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PriceList } from '../schemas/price-list.schema';
import { CreatePriceListDTO, UpdatePriceListDTO } from '../dtos/price-list.dto';
@Injectable()
export class PriceListService {
  constructor(
    @InjectModel('PriceLists') private priceListModel: Model<PriceList>,
  ) { }

  async create(createPriceListDto: CreatePriceListDTO): Promise<PriceList> {
    const createdPriceList = new this.priceListModel(createPriceListDto);
    return createdPriceList.save();
  }

  async findAll(): Promise<PriceList[]> {
    return this.priceListModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('products')
      .exec();
  }

  async findOne(id: string): Promise<PriceList> {
    const priceList = await this.priceListModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('products')
      .exec();
    if (!priceList) {
      throw new NotFoundException(`Price list with ID ${id} not found`);
    }
    return priceList;
  }

  async update(id: string, updatePriceListDto: UpdatePriceListDTO): Promise<PriceList> {
    const priceList = await this.priceListModel
      .findByIdAndUpdate(id, updatePriceListDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('products')
      .exec();
    if (!priceList) {
      throw new NotFoundException(`Price list with ID ${id} not found`);
    }
    return priceList;
  }

  async remove(id: string): Promise<PriceList> {
    const priceList = await this.priceListModel.findByIdAndDelete(id).exec();
    if (!priceList) {
      throw new NotFoundException(`Price list with ID ${id} not found`);
    }
    return priceList;
  }
}

================
File: product/controllers/product.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ProductService } from '../services/product.service';
import { CreateProductDTO, UpdateProductDTO } from '../dtos/product.schema';

@Controller('api/products')
export class ProductController {
  constructor(private readonly productService: ProductService) { }

  @Post()
  create(@Body() createProductDto: CreateProductDTO) {
    return this.productService.create(createProductDto);
  }

  @Get()
  findAll() {
    return this.productService.findAll();
  }

  @Get(':id')
  async getProduct(@Param('id') id: string) {
    return this.productService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateProductDto: UpdateProductDTO) {
    return this.productService.update(id, updateProductDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.productService.remove(id);
  }
}

================
File: product/dtos/product.schema.ts
================
// ProductDTO: Đại diện toàn bộ schema
export class ProductDTO {
  productId: string; // Mã sản phẩm
  barcode: string; // Mã vạch
  name: string; // Tên
  category: string; // Mã danh mục
  brand: string; // Mã thương hiệu
  price: number; // Giá bán
  cost: number; // Giá vốn
  stock: number; // Tồn kho
  location: string; // Vị trí
  minStock: number; // Tồn kho tối thiểu
  maxStock: number; // Tồn kho tối đa
  status: string; // Trạng thái
  image: string; // Ảnh
  weight: number; // Trọng lượng
  unit: string; // Đơn vị
  description: string; // Mô tả
  images: string[]; // Danh sách ảnh
  reviews: { userId: string; rating: number; comment: string; createdAt: Date }[]; // Đánh giá
}

// CreateProductDTO: Dùng để tạo mới
export class CreateProductDTO {
  name: string; // Tên
  barcode: string; // Mã vạch
  category: string; // Mã danh mục
  brand: string; // Mã thương hiệu
  price: number; // Giá bán
  cost: number; // Giá vốn
  stock: number; // Tồn kho
  location: string; // Vị trí
  minStock: number; // Tồn kho tối thiểu
  maxStock: number; // Tồn kho tối đa
  status: string; // Trạng thái
  image: string; // Ảnh
  weight: number; // Trọng lượng
  unit: string; // Đơn vị
  description: string; // Mô tả
  images: string[]; // Danh sách ảnh
}

// UpdateProductDTO: Dùng để cập nhật
export class UpdateProductDTO {
  name?: string; // Tên
  barcode?: string; // Mã vạch
  category?: string; // Mã danh mục
  brand?: string; // Mã thương hiệu
  price?: number; // Giá bán
  cost?: number; // Giá vốn
  stock?: number; // Tồn kho
  location?: string; // Vị trí
  minStock?: number; // Tồn kho tối thiểu
  maxStock?: number; // Tồn kho tối đa
  status?: string; // Trạng thái
  image?: string; // Ảnh
  weight?: number; // Trọng lượng
  unit?: string; // Đơn vị
  description?: string; // Mô tả
  images?: string[]; // Danh sách ảnh
  reviews?: { userId: string; rating: number; comment: string; createdAt: Date }[]; // Đánh giá
}

================
File: product/product.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ProductController } from './controllers/product.controller';
import { ProductService } from './services/product.service';
import { ProductSchema } from './schemas/product.schema';
import { BrandModule } from '../brand/brand.module';
import { CategoriesModule } from '../categories/categories.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Products', schema: ProductSchema }]),
    BrandModule,
    CategoriesModule
  ],
  controllers: [ProductController],
  providers: [ProductService],
  exports: [ProductService]
})
export class ProductModule { }

================
File: product/schemas/product.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Products' })
export class Product extends Document {
  @Prop({ unique: true, required: true })
  productId: string; // Mã sản phẩm

  @Prop({ unique: true })
  barcode: string; // Mã vạch

  @Prop({ required: true })
  name: string; // Tên sản phẩm

  @Prop({ type: Types.ObjectId, ref: 'Categories', required: true })
  category: Types.ObjectId; // Mã danh mục

  @Prop({ type: Types.ObjectId, ref: 'Brands', required: true })
  brand: Types.ObjectId; // Mã thương hiệu

  @Prop({ required: true })
  price: number; // Giá bán

  @Prop({ required: true })
  cost: number; // Giá vốn

  @Prop({ default: 0 })
  stock: number; // Tồn kho

  @Prop()
  location: string; // Vị trí kho

  @Prop({ default: 0 })
  minStock: number; // Tồn kho tối thiểu

  @Prop({ default: 100 })
  maxStock: number; // Tồn kho tối đa

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  image: string; // Ảnh

  @Prop()
  weight: number; // Trọng lượng

  @Prop({ required: true })
  unit: string; // Đơn vị

  @Prop()
  description: string; // Mô tả

  @Prop({ type: [String], default: [] })
  images: string[]; // Danh sách ảnh

  @Prop({ type: [{ userId: Types.ObjectId, rating: Number, comment: String, createdAt: Date }], default: [] })
  reviews: { userId: Types.ObjectId; rating: number; comment: string; createdAt: Date }[]; // Đánh giá
}

export const ProductSchema = SchemaFactory.createForClass(Product);

================
File: product/services/product.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Product } from '../schemas/product.schema';
import { CreateProductDTO, UpdateProductDTO } from '../dtos/product.schema';
@Injectable()
export class ProductService {
  constructor(
    @InjectModel('Products') private productModel: Model<Product>,
  ) { }

  async create(createProductDto: CreateProductDTO): Promise<Product> {
    const lastUser = await this.productModel.findOne().sort({ productId: -1 }).exec();
    let newProductId = 'SP0001';
  
    if (lastUser && lastUser.productId) {
      const lastNumber = parseInt(lastUser.productId.replace('SP', ''), 10);
      const nextNumber = lastNumber + 1;
      newProductId = `SP${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdProduct = new this.productModel({
      ...createProductDto,
      productId: newProductId
    });
  
    return createdProduct.save();
  }

  async findAll(): Promise<Product[]> {
    try {
      const products = await this.productModel.find().exec();
      
      // Populate category and brand only if they exist
      const populatedProducts = await Promise.all(
        products.map(async (product) => {
          if (product.category) {
            await product.populate('category');
          }
          if (product.brand) {
            await product.populate('brand');
          }
          return product;
        })
      );
      
      return populatedProducts;
    } catch (error) {
      console.error('Error in findAll:', error);
      throw error;
    }
  }

  async findOne(id: string): Promise<Product | null> {
    try {
      const product = await this.productModel.findById(id).exec();
      if (!product) {
        return null;
      }
      
      if (product.category) {
        await product.populate('category');
      }
      if (product.brand) {
        await product.populate('brand');
      }
      
      return product;
    } catch (error) {
      console.error('Error in findOne:', error);
      throw error;
    }
  }

  async update(id: string, updateProductDto: UpdateProductDTO): Promise<Product | null> {
    try {
      const product = await this.productModel
        .findByIdAndUpdate(id, updateProductDto, { new: true })
        .exec();
        
      if (!product) {
        return null;
      }
      
      if (product.category) {
        await product.populate('category');
      }
      if (product.brand) {
        await product.populate('brand');
      }
      
      return product;
    } catch (error) {
      console.error('Error in update:', error);
      throw error;
    }
  }

  async remove(id: string): Promise<Product | null> {
    return this.productModel.findByIdAndDelete(id).exec();
  }
}

================
File: purchase-history/controllers/purchase-history.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PurchaseHistoryService } from '../services/purchase-history.service';
import { PurchaseHistory } from '../schemas/purchase-history.schema';
import { CreatePurchaseHistoryDTO, UpdatePurchaseHistoryDTO } from '../dtos/purchase-history.dto';
@Controller('api/purchase-historys')
export class PurchaseHistoryController {
  constructor(private readonly PurchaseHistoryService: PurchaseHistoryService) { }

  @Post()
  async create(@Body() createPurchaseHistoryDto: CreatePurchaseHistoryDTO): Promise<PurchaseHistory> {
    return this.PurchaseHistoryService.create(createPurchaseHistoryDto);
  }

  @Get()
  findAll() {
    return this.PurchaseHistoryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.PurchaseHistoryService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePurchaseHistoryDto: UpdatePurchaseHistoryDTO) {
    return this.PurchaseHistoryService.update(id, updatePurchaseHistoryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.PurchaseHistoryService.remove(id);
  }
}

================
File: purchase-history/dtos/purchase-history.dto.ts
================
// PurchaseHistoryDTO: Đại diện toàn bộ schema
export class PurchaseHistoryDTO {
  purchaseHistoryId: string; // Mã lịch sử mua hàng
  storeId: string; // Mã cửa hàng
  packageId: string; // Mã gói dịch vụ
  purchaseDate: Date; // Ngày mua
  amount: number; // Số tiền
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreatePurchaseHistoryDTO: Dùng để tạo mới
export class CreatePurchaseHistoryDTO {
  storeId: string; // Mã cửa hàng
  packageId: string; // Mã gói dịch vụ
  purchaseDate: Date; // Ngày mua
  amount: number; // Số tiền
  status: string; // Trạng thái
}

// UpdatePurchaseHistoryDTO: Dùng để cập nhật
export class UpdatePurchaseHistoryDTO {
  purchaseDate?: Date; // Ngày mua
  amount?: number; // Số tiền
  status?: string; // Trạng thái
}

================
File: purchase-history/purchase-history.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PurchaseHistorySchema } from './schemas/purchase-history.schema';
import { PurchaseHistoryService } from './services/purchase-history.service';
import { PurchaseHistoryController } from './controllers/purchase-history.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PurchaseHistories', schema: PurchaseHistorySchema }])
  ],
  controllers: [PurchaseHistoryController],
  providers: [PurchaseHistoryService],
  exports: [PurchaseHistoryService]
})
export class PurchaseHistoryModule { }

================
File: purchase-history/schemas/purchase-history.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PurchaseHistories' })
export class PurchaseHistory extends Document {
  @Prop({ unique: true, required: true })
  purchaseHistoryId: string; // Mã lịch sử mua hàng

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'ServicePackages', required: true })
  packageId: Types.ObjectId; // Mã gói dịch vụ

  @Prop({ required: true })
  purchaseDate: Date; // Ngày mua

  @Prop({ required: true })
  amount: number; // Số tiền

  @Prop({ enum: ['paid', 'pending', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop()
  paymentMethod: string; // Phương thức thanh toán

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}
export const PurchaseHistorySchema = SchemaFactory.createForClass(PurchaseHistory);

================
File: purchase-history/services/purchase-history.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PurchaseHistory } from '../schemas/purchase-history.schema';
import { CreatePurchaseHistoryDTO, UpdatePurchaseHistoryDTO } from '../dtos/purchase-history.dto';
@Injectable()
export class PurchaseHistoryService {
  constructor(
    @InjectModel('PurchaseHistories') private PurchaseHistoryModel: Model<PurchaseHistory>,
  ) { }

  async create(createPurchaseHistoryDto: CreatePurchaseHistoryDTO): Promise<PurchaseHistory> {
    const lastPurchaseHistory = await this.PurchaseHistoryModel.findOne().sort({ purchaseHistoryId: -1 }).exec();
    let newPurchaseHistoryId = 'PH0001';
  
    if (lastPurchaseHistory && lastPurchaseHistory.purchaseHistoryId) {
      const lastNumber = parseInt(lastPurchaseHistory.purchaseHistoryId.replace('PH', ''), 10);
      const nextNumber = lastNumber + 1;
      newPurchaseHistoryId = `PH${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPurchaseHistory = new this.PurchaseHistoryModel({
      ...createPurchaseHistoryDto,
      purchaseHistoryId: newPurchaseHistoryId
    });
  
    return createdPurchaseHistory.save();
  }

  async findAll(): Promise<PurchaseHistory[]> {
    return this.PurchaseHistoryModel.find().exec();
  }

  async findOne(id: string): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel.findById(id).exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }

  async update(id: string, updatePurchaseHistoryDto: UpdatePurchaseHistoryDTO): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel
      .findByIdAndUpdate(id, updatePurchaseHistoryDto, { new: true })
      .exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }

  async remove(id: string): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel.findByIdAndDelete(id).exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }
}

================
File: purchase-order/controllers/purchase-orders.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PurchaseOrderService } from '../services/purchase-orders.service';
import { PurchaseOrder } from '../schemas/purchase-orders.schema';
import { CreatePurchaseOrderDTO, UpdatePurchaseOrderDTO } from '../dtos/purchase-order.dto';
@Controller('api/purchase-orders')
export class PurchaseOrderController {
  constructor(private readonly purchaseOrderService: PurchaseOrderService) { }

  @Post()
  async create(@Body() createPurchaseOrderDto: CreatePurchaseOrderDTO): Promise<PurchaseOrder> {
    return this.purchaseOrderService.create(createPurchaseOrderDto);
  }

  @Get()
  findAll() {
    return this.purchaseOrderService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.purchaseOrderService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatepurchaseOrderDto: UpdatePurchaseOrderDTO) {
    return this.purchaseOrderService.update(id, updatepurchaseOrderDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.purchaseOrderService.remove(id);
  }
}

================
File: purchase-order/dtos/purchase-order.dto.ts
================
// PurchaseOrderDTO: Đại diện toàn bộ schema
export class PurchaseOrderDTO {
  purchaseOrderId: string; // Mã đơn đặt hàng
  supplierId: string; // Mã nhà cung cấp
  products: { productId: string; quantity: number; price: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreatePurchaseOrderDTO: Dùng để tạo mới
export class CreatePurchaseOrderDTO {
  supplierId: string; // Mã nhà cung cấp
  products: { productId: string; quantity: number; price: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  status: string; // Trạng thái
}

// UpdatePurchaseOrderDTO: Dùng để cập nhật
export class UpdatePurchaseOrderDTO {
  supplierId?: string; // Mã nhà cung cấp
  products?: { productId: string; quantity: number; price: number }[]; // Sản phẩm
  totalAmount?: number; // Tổng tiền
  status?: string; // Trạng thái
}

================
File: purchase-order/purchase-orders.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PurchaseOrderSchema } from './schemas/purchase-orders.schema';
import { PurchaseOrderController } from './controllers/purchase-orders.controller';
import { PurchaseOrderService } from './services/purchase-orders.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PurchaseOrders', schema: PurchaseOrderSchema }])
  ],
  controllers: [PurchaseOrderController],
  providers: [PurchaseOrderService],
  exports: [PurchaseOrderService]
})
export class PurchaseOrderModule { }

================
File: purchase-order/schemas/purchase-orders.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PurchaseOrders' })
export class PurchaseOrder extends Document {
  @Prop({ unique: true, required: true })
  purchaseOrderId: string; // Mã đơn đặt hàng

  @Prop({ type: Types.ObjectId, ref: 'Suppliers', required: true })
  supplierId: Types.ObjectId; // Mã nhà cung cấp

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number, price: Number }] })
  products: { productId: Types.ObjectId; quantity: number; price: number }[]; // Sản phẩm

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền

  @Prop({ enum: ['pending', 'confirmed', 'shipping', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const PurchaseOrderSchema = SchemaFactory.createForClass(PurchaseOrder);

================
File: purchase-order/services/purchase-orders.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PurchaseOrder } from '../schemas/purchase-orders.schema';
import { CreatePurchaseOrderDTO, UpdatePurchaseOrderDTO } from '../dtos/purchase-order.dto';
@Injectable()
export class PurchaseOrderService {
  constructor(
    @InjectModel('PurchaseOrders') private PurchaseOrderModel: Model<PurchaseOrder>,
  ) { }

  async create(createPurchaseOrderDto: CreatePurchaseOrderDTO): Promise<PurchaseOrder> {
    const lastPurchaseOrder = await this.PurchaseOrderModel.findOne().sort({ purchaseOrderId: -1 }).exec();
    let newPurchaseOrderId = 'PO00001';
  
    if (lastPurchaseOrder && lastPurchaseOrder.purchaseOrderId) {
      const lastNumber = parseInt(lastPurchaseOrder.purchaseOrderId.replace('PO', ''), 10);
      const nextNumber = lastNumber + 1;
      newPurchaseOrderId = `PO${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdPurchaseOrder = new this.PurchaseOrderModel({
      ...createPurchaseOrderDto,
      purchaseOrderId: newPurchaseOrderId
    });
  
    return createdPurchaseOrder.save();
  }

  async findAll(): Promise<PurchaseOrder[]> {
    return this.PurchaseOrderModel.find().exec();
  }

  async findOne(id: string): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel.findById(id).exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }

  async update(id: string, updatePurchaseOrderDto: UpdatePurchaseOrderDTO): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel
      .findByIdAndUpdate(id, updatePurchaseOrderDto, { new: true })
      .exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }

  async remove(id: string): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel.findByIdAndDelete(id).exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }
}

================
File: return-purchase/controllers/return-purchase.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ReturnPurchaseService } from '../services/return-purchase.service';
import { ReturnPurchase } from '../schemas/return-purchase.schema';
import { CreateReturnPurchaseDTO, UpdateReturnPurchaseDTO } from '../dtos/return-purchase.dto';
@Controller('api/return-purchases')
export class ReturnPurchaseController {
  constructor(private readonly returnPurchaseService: ReturnPurchaseService) { }

  @Post()
  async create(@Body() createReturnPurchaseDto: CreateReturnPurchaseDTO): Promise<ReturnPurchase> {
    return this.returnPurchaseService.create(createReturnPurchaseDto);
  }

  @Get()
  findAll() {
    return this.returnPurchaseService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.returnPurchaseService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateReturnPurchaseDto: UpdateReturnPurchaseDTO) {
    return this.returnPurchaseService.update(id, updateReturnPurchaseDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.returnPurchaseService.remove(id);
  }
}

================
File: return-purchase/dtos/return-purchase.dto.ts
================
// ReturnPurchaseDTO: Đại diện toàn bộ schema
export class ReturnPurchaseDTO {
  returnPurchaseId: string; // Mã trả hàng
  purchaseOrderId: string; // Mã đơn đặt hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateReturnPurchaseDTO: Dùng để tạo mới
export class CreateReturnPurchaseDTO {
  purchaseOrderId: string; // Mã đơn đặt hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
}

// UpdateReturnPurchaseDTO: Dùng để cập nhật
export class UpdateReturnPurchaseDTO {
  products?: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount?: number; // Tổng tiền trả
  status?: string; // Trạng thái
}

================
File: return-purchase/return-purchase.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ReturnPurchaseSchema } from './schemas/return-purchase.schema';
import { ReturnPurchaseController } from './controllers/return-purchase.controller';
import { ReturnPurchaseService } from './services/return-purchase.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'ReturnPurchases', schema: ReturnPurchaseSchema }])
  ],
  controllers: [ReturnPurchaseController],
  providers: [ReturnPurchaseService],
  exports: [ReturnPurchaseService]
})
export class ReturnPurchaseModule { }

================
File: return-purchase/schemas/return-purchase.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'ReturnPurchases' })
export class ReturnPurchase extends Document {
  @Prop({ unique: true, required: true })
  returnPurchaseId: string; // Mã trả hàng

  @Prop({ type: Types.ObjectId, ref: 'PurchaseOrders', required: true })
  purchaseOrderId: Types.ObjectId; // Mã đơn đặt hàng

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  products: { productId: Types.ObjectId; quantity: number }[]; // Sản phẩm trả

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền trả

  @Prop({ enum: ['pending', 'confirmed', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const ReturnPurchaseSchema = SchemaFactory.createForClass(ReturnPurchase);

================
File: return-purchase/services/return-purchase.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ReturnPurchase } from '../schemas/return-purchase.schema';
import { CreateReturnPurchaseDTO, UpdateReturnPurchaseDTO } from '../dtos/return-purchase.dto';
@Injectable()
export class ReturnPurchaseService {
  constructor(
    @InjectModel('ReturnPurchases') private ReturnPurchaseModel: Model<ReturnPurchase>,
  ) { }

  async create(createReturnPurchaseDto: CreateReturnPurchaseDTO): Promise<ReturnPurchase> {
    const lastReturnPurchase = await this.ReturnPurchaseModel.findOne().sort({ returnPurchaseId: -1 }).exec();
    let newReturnPurchaseId = 'RP00001';
  
    if (lastReturnPurchase && lastReturnPurchase.returnPurchaseId) {
      const lastNumber = parseInt(lastReturnPurchase.returnPurchaseId.replace('RP', ''), 10);
      const nextNumber = lastNumber + 1;
      newReturnPurchaseId = `RP${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdReturnPurchase = new this.ReturnPurchaseModel({
      ...createReturnPurchaseDto,
      returnPurchaseId: newReturnPurchaseId
    });
  
    return createdReturnPurchase.save();
  }

  async findAll(): Promise<ReturnPurchase[]> {
    return this.ReturnPurchaseModel.find().exec();
  }

  async findOne(id: string): Promise<ReturnPurchase> {
    const ReturnPurchase = await this.ReturnPurchaseModel.findById(id).exec();
    if (!ReturnPurchase) {
      throw new NotFoundException(`ReturnPurchase with ID ${id} not found`);
    }
    return ReturnPurchase;
  }

  async update(id: string, updateReturnPurchaseDto: UpdateReturnPurchaseDTO): Promise<ReturnPurchase> {
    const ReturnPurchase = await this.ReturnPurchaseModel
      .findByIdAndUpdate(id, updateReturnPurchaseDto, { new: true })
      .exec();
    if (!ReturnPurchase) {
      throw new NotFoundException(`ReturnPurchase with ID ${id} not found`);
    }
    return ReturnPurchase;
  }

  async remove(id: string): Promise<ReturnPurchase> {
    const ReturnPurchase = await this.ReturnPurchaseModel.findByIdAndDelete(id).exec();
    if (!ReturnPurchase) {
      throw new NotFoundException(`ReturnPurchase with ID ${id} not found`);
    }
    return ReturnPurchase;
  }
}

================
File: ruturn/controllers/return.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ReturnService } from '../services/return.service';
import { Return } from '../schemas/return.schema';
import { CreateReturnDTO, UpdateReturnDTO } from '../dtos/return.dto';
@Controller('api/returns')
export class ReturnController {
  constructor(private readonly returnService: ReturnService) { }

  @Post()
  async create(@Body() createReturnDto: CreateReturnDTO): Promise<Return> {
    return this.returnService.create(createReturnDto);
  }

  @Get()
  findAll() {
    return this.returnService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.returnService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateReturnDto: UpdateReturnDTO) {
    return this.returnService.update(id, updateReturnDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.returnService.remove(id);
  }
}

================
File: ruturn/dtos/return.dto.ts
================
// ReturnDTO: Đại diện toàn bộ schema
export class ReturnDTO {
  returnId: string; // Mã trả hàng
  orderId: string; // Mã đơn hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateReturnDTO: Dùng để tạo mới
export class CreateReturnDTO {
  orderId: string; // Mã đơn hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
}

// UpdateReturnDTO: Dùng để cập nhật
export class UpdateReturnDTO {
  products?: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount?: number; // Tổng tiền trả
  status?: string; // Trạng thái
}

================
File: ruturn/return.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ReturnSchema } from './schemas/return.schema';
import { ReturnController } from './controllers/return.controller';
import { ReturnService } from './services/return.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Returns', schema: ReturnSchema }])
  ],
  controllers: [ReturnController],
  providers: [ReturnService],
  exports: [ReturnService]
})
export class ReturnModule { }

================
File: ruturn/schemas/return.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Returns' })
export class Return extends Document {
  @Prop({ unique: true, required: true })
  returnId: string; // Mã trả hàng

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId; // Mã đơn hàng

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  products: { productId: Types.ObjectId; quantity: number }[]; // Sản phẩm trả

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền trả

  @Prop({ enum: ['pending', 'confirmed', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const ReturnSchema = SchemaFactory.createForClass(Return);

================
File: ruturn/services/return.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Return } from '../schemas/return.schema';
import { CreateReturnDTO, UpdateReturnDTO } from '../dtos/return.dto';
@Injectable()
export class ReturnService {
  constructor(
    @InjectModel('Returns') private ReturnModel: Model<Return>,
  ) { }

  async create(createReturnDto: CreateReturnDTO): Promise<Return> {
    const lastReturn = await this.ReturnModel.findOne().sort({ returnId: -1 }).exec();
    let newReturnId = 'RT00001';
  
    if (lastReturn && lastReturn.returnId) {
      const lastNumber = parseInt(lastReturn.returnId.replace('RT', ''), 10);
      const nextNumber = lastNumber + 1;
      newReturnId = `RT${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdReturn = new this.ReturnModel({
      ...createReturnDto,
      returnId: newReturnId
    });
  
    return createdReturn.save();
  }

  async findAll(): Promise<Return[]> {
    return this.ReturnModel.find().exec();
  }

  async findOne(id: string): Promise<Return> {
    const Return = await this.ReturnModel.findById(id).exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }

  async update(id: string, updateReturnDto: UpdateReturnDTO): Promise<Return> {
    const Return = await this.ReturnModel
      .findByIdAndUpdate(id, updateReturnDto, { new: true })
      .exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }

  async remove(id: string): Promise<Return> {
    const Return = await this.ReturnModel.findByIdAndDelete(id).exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }
}

================
File: sale-channel/controllers/sale-channel.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SaleChannelService } from '../services/sale-channel.service';
import { CreateSalesChannelDTO, UpdateSalesChannelDTO } from '../dtos/sale-channel.dto';
import { SaleChannel } from '../schemas/sale-channel.schema';
@Controller('api/sale-channels')
export class SaleChannelController {
  constructor(private readonly saleChannelService: SaleChannelService) { }

  @Post()
  async create(@Body() createSalesChannelDto: CreateSalesChannelDTO): Promise<SaleChannel> {
    return this.saleChannelService.create(createSalesChannelDto);
  }

  @Get()
  findAll() {
    return this.saleChannelService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.saleChannelService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSalesChannelDto: UpdateSalesChannelDTO) {
    return this.saleChannelService.update(id, updateSalesChannelDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.saleChannelService.remove(id);
  }
}

================
File: sale-channel/dtos/sale-channel.dto.ts
================
// SalesChannelDTO: Đại diện toàn bộ schema
export class SalesChannelDTO {
  channelId: string; // Mã kênh bán hàng
  storeId: string; // Mã cửa hàng
  name: string; // Tên kênh
  type: string; // Loại kênh
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateSalesChannelDTO: Dùng để tạo mới
export class CreateSalesChannelDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên kênh
  type: string; // Loại kênh
  status: string; // Trạng thái
}

// UpdateSalesChannelDTO: Dùng để cập nhật
export class UpdateSalesChannelDTO {
  name?: string; // Tên kênh (tùy chọn)
  type?: string; // Loại kênh (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: sale-channel/sale-channel.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SaleChannelSchema } from './schemas/sale-channel.schema';
import { SaleChannelController } from './controllers/sale-channel.controller';
import { SaleChannelService } from './services/sale-channel.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'SaleChannels', schema: SaleChannelSchema }])
  ],
  controllers: [SaleChannelController],
  providers: [SaleChannelService],
  exports: [SaleChannelService]
})
export class SaleChannelModule { }

================
File: sale-channel/schemas/sale-channel.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'SaleChannels' })
export class SaleChannel extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({
    enum: [
      'Trực tiếp',
      'Shopee',
      'Tiki',
      'Lazada',
      'Sendo',
      'Facebook',
      'Instagram',
    ],
    required: true,
  })
  type: string;

  @Prop()
  description: string;

  @Prop({ enum: ['Đang hoạt động', 'Ngừng hoạt động'], default: 'Đang hoạt động' })
  status: string;

  @Prop({
    type: {
      syncProducts: { type: Boolean, default: false },
      syncPrices: { type: Boolean, default: false },
      syncStock: { type: Boolean, default: false },
      shopee: {
        shopId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      tiki: {
        sellerId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      lazada: {
        sellerId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      sendo: {
        sellerId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      facebook: {
        pageId: String,
        accessToken: String,
        tokenExpiry: Date,
      },
      instagram: {
        businessAccountId: String,
        accessToken: String,
        tokenExpiry: Date,
      },
    },
  })
  settings: {
    syncProducts: boolean;
    syncPrices: boolean;
    syncStock: boolean;
    shopee: {
      shopId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    tiki: {
      sellerId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    lazada: {
      sellerId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    sendo: {
      sellerId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    facebook: {
      pageId: string;
      accessToken: string;
      tokenExpiry: Date;
    };
    instagram: {
      businessAccountId: string;
      accessToken: string;
      tokenExpiry: Date;
    };
  };

  @Prop({
    type: {
      totalOrders: { type: Number, default: 0 },
      totalRevenue: { type: Number, default: 0 },
      totalProducts: { type: Number, default: 0 },
    },
  })
  statistics: {
    totalOrders: number;
    totalRevenue: number;
    totalProducts: number;
  };
}

export const SaleChannelSchema = SchemaFactory.createForClass(SaleChannel);

================
File: sale-channel/services/sale-channel.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SaleChannel } from '../schemas/sale-channel.schema';
import { CreateSalesChannelDTO, UpdateSalesChannelDTO } from '../dtos/sale-channel.dto';
@Injectable()
export class SaleChannelService {
  constructor(
    @InjectModel('SaleChannels') private SaleChannelModel: Model<SaleChannel>,
  ) { }

  async create(createSaleChannelDto: CreateSalesChannelDTO): Promise<SaleChannel> {
    return this.SaleChannelModel.create(createSaleChannelDto);
  }

  async findAll(): Promise<SaleChannel[]> {
    return this.SaleChannelModel.find().exec();
  }

  async findOne(id: string): Promise<SaleChannel> {
    const SaleChannel = await this.SaleChannelModel.findById(id).exec();
    if (!SaleChannel) {
        throw new NotFoundException(`SaleChannel with ID ${id} not found`);
    }
    return SaleChannel;
  }

  async update(id: string, updateSalesChannelDto: UpdateSalesChannelDTO): Promise<SaleChannel> {
    const SaleChannel = await this.SaleChannelModel
      .findByIdAndUpdate(id, updateSalesChannelDto, { new: true })
      .exec();
    if (!SaleChannel) {
      throw new NotFoundException(`SaleChannel with ID ${id} not found`);
    }
    return SaleChannel;
  }

  async remove(id: string): Promise<SaleChannel> {
    const SaleChannel = await this.SaleChannelModel.findByIdAndDelete(id).exec();
    if (!SaleChannel) {
      throw new NotFoundException(`SaleChannel with ID ${id} not found`);
    }
    return SaleChannel;
  }
}

================
File: service-package/controllers/service-package.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ServicePackageService } from '../services/service-package.service';
import { ServicePackage } from '../schemas/service-package.schems';
import { CreateServicePackageDTO, UpdateServicePackageDTO } from '../dtos/service-package.dto';
@Controller('api/service-packages')
export class ServicePackageController {
  constructor(private readonly ServicePackageService: ServicePackageService) { }

  @Post()
  async create(@Body() createServicePackageDto: CreateServicePackageDTO): Promise<ServicePackage> {
    return this.ServicePackageService.create(createServicePackageDto);
  }

  @Get()
  findAll() {
    return this.ServicePackageService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.ServicePackageService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateServicePackageDto: UpdateServicePackageDTO) {
    return this.ServicePackageService.update(id, updateServicePackageDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.ServicePackageService.remove(id);
  }
}

================
File: service-package/dtos/service-package.dto.ts
================
// ServicePackageDTO: Đại diện toàn bộ schema
export class ServicePackageDTO {
  packageId: string; // Mã gói dịch vụ
  name: string; // Tên gói
  description: string; // Mô tả
  price: number; // Giá
  type: string; // Loại gói
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateServicePackageDTO: Dùng để tạo mới
export class CreateServicePackageDTO {
  name: string; // Tên gói
  description: string; // Mô tả
  price: number; // Giá
  type: string; // Loại gói
  status: string; // Trạng thái
}

// UpdateServicePackageDTO: Dùng để cập nhật
export class UpdateServicePackageDTO {
  name?: string; // Tên gói (tùy chọn)
  description?: string; // Mô tả (tùy chọn)
  price?: number; // Giá (tùy chọn)
  type?: string; // Loại gói (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: service-package/schemas/service-package.schems.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'ServicePackages' })
export class ServicePackage extends Document {
  @Prop({ unique: true, required: true })
  packageId: string; // Mã gói dịch vụ, định danh duy nhất

  @Prop({ required: true })
  name: string; // Tên gói dịch vụ

  @Prop()
  description: string; // Mô tả gói dịch vụ

  @Prop({ required: true })
  price: number; // Giá của gói dịch vụ

  @Prop({ enum: ['monthly', 'yearly', 'lifetime'], required: true })
  type: string; // Loại gói: hàng tháng, hàng năm, trọn đời

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái: hoạt động hoặc không hoạt động

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const ServicePackageSchema = SchemaFactory.createForClass(ServicePackage);

================
File: service-package/service-package.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ServicePackage, ServicePackageSchema } from './schemas/service-package.schems';
import { ServicePackageService } from './services/service-package.service';
import { ServicePackageController } from './controllers/service-package.controller';


@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'ServicePackages', schema: ServicePackageSchema }])
  ],
  controllers: [ServicePackageController],
  providers: [ServicePackageService],
  exports: [ServicePackageService]
})
export class ServicePackageModule { }

================
File: service-package/services/service-package.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ServicePackage } from '../schemas/service-package.schems';
import { CreateServicePackageDTO, UpdateServicePackageDTO } from '../dtos/service-package.dto';

@Injectable()
export class ServicePackageService {
  constructor(
    @InjectModel('ServicePackages') private ServicePackageModel: Model<ServicePackage>,
  ) { }

  async create(createServicePackageDto: CreateServicePackageDTO): Promise<ServicePackage> {
    const lastServicePackage = await this.ServicePackageModel.findOne().sort({ packageId: -1 }).exec();
    let newServicePackageId = 'SVP00001';
  
    if (lastServicePackage && lastServicePackage.packageId) {
      const lastNumber = parseInt(lastServicePackage.packageId.replace('SVP', ''), 10);
      const nextNumber = lastNumber + 1;
      newServicePackageId = `SVP${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdServicePackage = new this.ServicePackageModel({
      ...createServicePackageDto,
      servicePackageId: newServicePackageId
    });
  
    return createdServicePackage.save();
  }

  async findAll(): Promise<ServicePackage[]> {
    return this.ServicePackageModel.find().exec();
  }

  async findOne(id: string): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel.findById(id).exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }

  async update(id: string, updateServicePackageDto: UpdateServicePackageDTO): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel
      .findByIdAndUpdate(id, updateServicePackageDto, { new: true })
      .exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }

  async remove(id: string): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel.findByIdAndDelete(id).exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }
}

================
File: shipment/controllers/shipment.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { ShipmentService } from '../services/shipment.service';
import { Shipment } from '../schemas/shipment.schema';
import { CreateShipmentDTO, UpdateShipmentDTO } from '../dtos/shipment.dto';
@Controller('api/shipments')
export class ShipmentController {
  constructor(private readonly shipmentService: ShipmentService) { }

  @Post()
  async create(@Body() createShipmentDto: CreateShipmentDTO): Promise<Shipment> {
    return this.shipmentService.create(createShipmentDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<Shipment[]> {
    return this.shipmentService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Shipment> {
    return this.shipmentService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateShipmentDto: UpdateShipmentDTO,
  ): Promise<Shipment> {
    return this.shipmentService.update(id, updateShipmentDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Shipment> {
    return this.shipmentService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<Shipment> {
    return this.shipmentService.updateStatus(id, status);
  }

  @Put(':id/tracking')
  async updateTracking(
    @Param('id') id: string,
    @Body() tracking: any,
  ): Promise<Shipment> {
    return this.shipmentService.updateTracking(id, tracking);
  }

  @Put(':id/carrier')
  async updateCarrier(
    @Param('id') id: string,
    @Body('carrierId') carrierId: string,
  ): Promise<Shipment> {
    return this.shipmentService.updateCarrier(id, carrierId);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<Shipment[]> {
    return this.shipmentService.findByStore(storeId);
  }

  @Get('order/:orderId')
  async findByOrder(@Param('orderId') orderId: string): Promise<Shipment[]> {
    return this.shipmentService.findByOrder(orderId);
  }
}

================
File: shipment/dtos/shipment.dto.ts
================
// ShipmentDTO: Đại diện toàn bộ schema
export class ShipmentDTO {
  shipmentId: string; // Mã vận chuyển
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  shippingAddress: string; // Địa chỉ giao hàng
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateShipmentDTO: Dùng để tạo mới
export class CreateShipmentDTO {
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  shippingAddress: string; // Địa chỉ giao hàng
  status: string; // Trạng thái
}

// UpdateShipmentDTO: Dùng để cập nhật
export class UpdateShipmentDTO {
  shippingAddress?: string; // Địa chỉ giao hàng (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: shipment/schemas/shipment.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Shipments' })
export class Shipment extends Document {
  @Prop({ unique: true, required: true })
  shipmentId: string; // Mã vận chuyển, định danh duy nhất

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng, liên kết đến bảng Stores

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId; // Mã đơn hàng, liên kết đến bảng Orders

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng, liên kết đến bảng Customers

  @Prop({ required: true })
  shippingAddress: string; // Địa chỉ giao hàng

  @Prop({ enum: ['pending', 'shipped', 'delivered', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái: đang chờ, đã giao, hoàn thành, hủy

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const ShipmentSchema = SchemaFactory.createForClass(Shipment);

================
File: shipment/services/shipment.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Shipment } from '../schemas/shipment.schema';
import { CreateShipmentDTO, UpdateShipmentDTO } from '../dtos/shipment.dto';
@Injectable()
export class ShipmentService {
  constructor(
    @InjectModel('Shipments')
    private shipmentModel: Model<Shipment>,
  ) { }

  async create(createShipmentDto: CreateShipmentDTO): Promise<Shipment> {
    const lastShipment = await this.shipmentModel.findOne().sort({ shipmentId: -1 }).exec();
    let newShipmentId = 'SM00001';
  
    if (lastShipment && lastShipment.shipmentId) {
      const lastNumber = parseInt(lastShipment.shipmentId.replace('SM', ''), 10);
      const nextNumber = lastNumber + 1;
      newShipmentId = `SM${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdShipment = new this.shipmentModel({
      ...createShipmentDto,
      shipmentId: newShipmentId
    });
  
    return createdShipment.save();
  }

  async findAll(query: any = {}): Promise<Shipment[]> {
    return this.shipmentModel.find(query).exec();
  }

  async findOne(id: string): Promise<Shipment> {
    const shipment = await this.shipmentModel.findById(id).exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async update(id: string, updateShipmentDto: UpdateShipmentDTO): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, updateShipmentDto, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async remove(id: string): Promise<Shipment> {
    const shipment = await this.shipmentModel.findByIdAndDelete(id).exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateStatus(id: string, status: string): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateTracking(id: string, tracking: any): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { tracking }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateCarrier(id: string, carrierId: string): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { carrier: carrierId }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async findByStore(storeId: string): Promise<Shipment[]> {
    return this.shipmentModel.find({ storeId }).exec();
  }

  async findByOrder(orderId: string): Promise<Shipment[]> {
    return this.shipmentModel.find({ order: orderId }).exec();
  }
}

================
File: shipment/shipment.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Shipment, ShipmentSchema } from './schemas/shipment.schema';
import { ShipmentController } from './controllers/shipment.controller';
import { ShipmentService } from './services/shipment.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Shipments', schema: ShipmentSchema }])
  ],
  controllers: [ShipmentController],
  providers: [ShipmentService],
  exports: [ShipmentService]
})
export class ShipmentModule { }

================
File: social-media-conversation/controllers/social-media-conversation.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { SocialMediaConversation } from '../schemas/social-media-conversation.schema';
import { SocialMediaConversationService } from '../services/social-media-conversation.service';
import { CreateSocialMediaConversationDTO, UpdateSocialMediaConversationDTO } from '../dtos/social-media-conversation.dto';
@Controller('social-media-conversations')
export class SocialMediaConversationController {
  constructor(private readonly conversationService: SocialMediaConversationService) { }

  @Post()
  async create(@Body() createConversationDto: CreateSocialMediaConversationDTO): Promise<SocialMediaConversation> {
    return this.conversationService.create(createConversationDto);
  }

  @Get()
  async findAll(
    @Query('branchId') branchId?: string,
    @Query('status') status?: string,
    @Query('platform') platform?: string,
    @Query('assignedTo') assignedTo?: string,
  ): Promise<SocialMediaConversation[]> {
    // TODO: Implement filtering logic in service
    return this.conversationService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<SocialMediaConversation> {
    return this.conversationService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateConversationDto: UpdateSocialMediaConversationDTO,
  ): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, updateConversationDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<SocialMediaConversation> {
    return this.conversationService.remove(id);
  }

  @Put(':id/assign')
  async assignTo(
    @Param('id') id: string,
    @Body('userId') userId: string,
  ): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, { assignedTo: userId });
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, { status });
  }

}

================
File: social-media-conversation/dtos/social-media-conversation.dto.ts
================
export class SocialMediaConversationDTO {
  storeId: string;
  channelId: string;
  platform: string;
  conversationId: string;
  customerName: string;
  messages: { sender: string; message: string; timestamp: Date }[];
  status: string;
  assignedTo: string;
  relatedOrders: { orderId: string }[];
  relatedProducts: { productId: string }[];
  createdAt: Date;
  notes: string; // Thêm
  customerId: string; // Thêm
}

export class CreateSocialMediaConversationDTO {
  storeId: string;
  channelId: string;
  platform: string;
  conversationId: string;
  customerName: string;
  messages: { sender: string; message: string; timestamp: Date }[];
  status: string;
  assignedTo: string;
  relatedOrders: { orderId: string }[];
  relatedProducts: { productId: string }[];
  notes?: string; // Tùy chọn
  customerId?: string; // Tùy chọn
}

export class UpdateSocialMediaConversationDTO {
  messages?: { sender: string; message: string; timestamp: Date }[];
  status?: string;
  assignedTo?: string;
  relatedOrders?: { orderId: string }[];
  relatedProducts?: { productId: string }[];
  notes?: string; // Tùy chọn
  customerId?: string; // Tùy chọn
}

================
File: social-media-conversation/schemas/social-media-conversation.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'SocialMediaConversations' })
export class SocialMediaConversation extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels', required: true })
  channelId: Types.ObjectId;

  @Prop({ required: true })
  platform: string;

  @Prop({ required: true })
  conversationId: string;

  @Prop({ required: true })
  customerName: string;

  @Prop({ type: [{ sender: String, message: String, timestamp: Date }] })
  messages: { sender: string; message: string; timestamp: Date }[];

  @Prop({ enum: ['open', 'closed', 'pending'], default: 'open' })
  status: string;

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  assignedTo: Types.ObjectId;

  @Prop({ type: [{ orderId: Types.ObjectId }] })
  relatedOrders: { orderId: Types.ObjectId }[];

  @Prop({ type: [{ productId: Types.ObjectId }] })
  relatedProducts: { productId: Types.ObjectId }[];

  @Prop({ default: Date.now })
  createdAt: Date;

  // Trường mới
  @Prop()
  notes: string;

  @Prop({ type: Types.ObjectId, ref: 'Customers' })
  customerId: Types.ObjectId;
}

export const SocialMediaConversationSchema = SchemaFactory.createForClass(SocialMediaConversation);

================
File: social-media-conversation/services/social-media-conversation.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SocialMediaConversation } from '../schemas/social-media-conversation.schema';
import { CreateSocialMediaConversationDTO, UpdateSocialMediaConversationDTO } from '../dtos/social-media-conversation.dto';
@Injectable()
export class SocialMediaConversationService {
  constructor(
    @InjectModel('SocialMediaConversations') private conversationModel: Model<SocialMediaConversation>,
  ) { }

  async create(createConversationDto: CreateSocialMediaConversationDTO): Promise<SocialMediaConversation> {
    const createdConversation = new this.conversationModel(createConversationDto);
    return createdConversation.save();
  }

  async findAll(): Promise<SocialMediaConversation[]> {
    return this.conversationModel
      .find()
      .populate('branch')
      .populate('customer')
      .populate('assignedTo')
      .populate('channel')
      .exec();
  }

  async findOne(id: string): Promise<SocialMediaConversation> {
    const conversation = await this.conversationModel
      .findById(id)
      .populate('branch')
      .populate('customer')
      .populate('assignedTo')
      .populate('channel')
      .exec();
    if (!conversation) {
      throw new NotFoundException(`Social media conversation with ID ${id} not found`);
    }
    return conversation;
  }

  async update(id: string, updateConversationDto: UpdateSocialMediaConversationDTO): Promise<SocialMediaConversation> {
    const conversation = await this.conversationModel
      .findByIdAndUpdate(id, updateConversationDto, { new: true })
      .populate('branch')
      .populate('customer')
      .populate('assignedTo')
      .populate('channel')
      .exec();
    if (!conversation) {
      throw new NotFoundException(`Social media conversation with ID ${id} not found`);
    }
    return conversation;
  }

  async remove(id: string): Promise<SocialMediaConversation> {
    const conversation = await this.conversationModel.findByIdAndDelete(id).exec();
    if (!conversation) {
      throw new NotFoundException(`Social media conversation with ID ${id} not found`);
    }
    return conversation;
  }
}

================
File: social-media-conversation/social-media-conversation.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SocialMediaConversationSchema } from './schemas/social-media-conversation.schema';
import { SocialMediaConversationController } from './controllers/social-media-conversation.controller';
import { SocialMediaConversationService } from './services/social-media-conversation.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'SocialMediaConversations', schema: SocialMediaConversationSchema }])
  ],
  controllers: [SocialMediaConversationController],
  providers: [SocialMediaConversationService],
  exports: [SocialMediaConversationService]
})
export class SocialMediaConversationModule { }

================
File: social-media-post/controllers/social-media-post.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete, Query } from '@nestjs/common';
import { SocialMediaPostService } from '../services/social-media-post.service';
import { CreateSocialMediaPostDTO, UpdateSocialMediaPostDTO } from '../dtos/social-media-post.dto';
@Controller('social-media-posts')
export class SocialMediaPostController {
  constructor(private readonly socialMediaPostService: SocialMediaPostService) { }

  @Post()
  create(@Body() createSocialMediaPostDto: CreateSocialMediaPostDTO) {
    return this.socialMediaPostService.create(createSocialMediaPostDto);
  }

  @Get()
  findAll() {
    return this.socialMediaPostService.findAll();
  }

  @Get('store/:storeId')
  findByStore(@Param('storeId') storeId: string) {
    return this.socialMediaPostService.findByStore(storeId);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.socialMediaPostService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSocialMediaPostDto: UpdateSocialMediaPostDTO) {
    return this.socialMediaPostService.update(id, updateSocialMediaPostDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.socialMediaPostService.remove(id);
  }
}

================
File: social-media-post/dtos/social-media-post.dto.ts
================
export class SocialMediaPostDTO {
  storeId: string;
  channelId: string;
  platform: string;
  postId: string;
  content: string;
  images: string[];
  products: { productId: string }[];
  postedBy: string;
  postDate: Date;
  status: string;
  createdAt: Date;
  scheduledDate: Date; // Thêm
  analytics: { views: number; likes: number; comments: number }; // Thêm
}

export class CreateSocialMediaPostDTO {
  storeId: string;
  channelId: string;
  platform: string;
  content: string;
  images: string[];
  products: { productId: string }[];
  postedBy: string;
  postDate: Date;
  status: string;
  scheduledDate?: Date; // Tùy chọn
}

export class UpdateSocialMediaPostDTO {
  content?: string;
  images?: string[];
  products?: { productId: string }[];
  postDate?: Date;
  status?: string;
  scheduledDate?: Date; // Tùy chọn
  analytics?: { views: number; likes: number; comments: number }; // Tùy chọn
}

================
File: social-media-post/schemas/social-media-post.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'SocialMediaPosts' })
export class SocialMediaPost extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels', required: true })
  channelId: Types.ObjectId;

  @Prop({ required: true })
  platform: string;

  @Prop({ required: true })
  postId: string;

  @Prop({ required: true })
  content: string;

  @Prop([String])
  images: string[];

  @Prop({ type: [{ productId: Types.ObjectId }] })
  products: { productId: Types.ObjectId }[];

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  postedBy: Types.ObjectId;

  @Prop({ required: true })
  postDate: Date;

  @Prop({ enum: ['draft', 'published', 'archived'], default: 'draft' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  // Trường mới
  @Prop()
  scheduledDate: Date;

  @Prop({ type: { views: Number, likes: Number, comments: Number } })
  analytics: { views: number; likes: number; comments: number };
}

export const SocialMediaPostSchema = SchemaFactory.createForClass(SocialMediaPost);

================
File: social-media-post/services/social-media-post.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateSocialMediaPostDTO, UpdateSocialMediaPostDTO } from '../dtos/social-media-post.dto';
import { SocialMediaPost } from '../schemas/social-media-post.schema';

@Injectable()
export class SocialMediaPostService {
  constructor(
    @InjectModel('SocialMediaPosts')
    private socialMediaPostModel: Model<SocialMediaPost>,
  ) { }

  async create(createSocialMediaPostDto: CreateSocialMediaPostDTO): Promise<SocialMediaPost> {
    const lastSocialMediaPost = await this.socialMediaPostModel.findOne().sort({ postId: -1 }).exec();
    let newSocialMediaPostId = 'SMP00001';
  
    if (lastSocialMediaPost && lastSocialMediaPost.postId) {
      const lastNumber = parseInt(lastSocialMediaPost.postId.replace('SMP', ''), 10);
      const nextNumber = lastNumber + 1;
      newSocialMediaPostId = `SMP${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdSocialMediaPost = new this.socialMediaPostModel({
      ...createSocialMediaPostDto,
      postId: newSocialMediaPostId
    });
  
    return createdSocialMediaPost.save();
  }

  async findAll(query: any = {}): Promise<SocialMediaPost[]> {
    return this.socialMediaPostModel.find(query).exec();
  }

  async findOne(id: string): Promise<SocialMediaPost> {
    const socialMediaPost = await this.socialMediaPostModel.findById(id).exec();
    if (!socialMediaPost) {
      throw new NotFoundException(`Social media post with ID ${id} not found`);
    }
    return socialMediaPost;
  }

  async update(id: string, updateSocialMediaPostDto: UpdateSocialMediaPostDTO): Promise<SocialMediaPost> {
    const socialMediaPost = await this.socialMediaPostModel
      .findByIdAndUpdate(id, updateSocialMediaPostDto, { new: true })
      .exec();
    if (!socialMediaPost) {
      throw new NotFoundException(`Social media post with ID ${id} not found`);
    }
    return socialMediaPost;
  }

  async remove(id: string): Promise<SocialMediaPost> {
    const socialMediaPost = await this.socialMediaPostModel.findByIdAndDelete(id).exec();
    if (!socialMediaPost) {
      throw new NotFoundException(`Social media post with ID ${id} not found`);
    }
    return socialMediaPost;
  }

  async updateStatus(id: string, status: string): Promise<SocialMediaPost> {
    const socialMediaPost = await this.socialMediaPostModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!socialMediaPost) {
      throw new NotFoundException(`Social media post with ID ${id} not found`);
    }
    return socialMediaPost;
  }

  async updateTracking(id: string, tracking: any): Promise<SocialMediaPost> {
    const socialMediaPost = await this.socialMediaPostModel
      .findByIdAndUpdate(id, { tracking }, { new: true })
      .exec();
    if (!socialMediaPost) {
      throw new NotFoundException(`Social media post with ID ${id} not found`);
    }
    return socialMediaPost;
  }

  async updateCarrier(id: string, carrierId: string): Promise<SocialMediaPost> {
    const socialMediaPost = await this.socialMediaPostModel
      .findByIdAndUpdate(id, { carrier: carrierId }, { new: true })
      .exec();
    if (!socialMediaPost) {
      throw new NotFoundException(`Social media post with ID ${id} not found`);
    }
    return socialMediaPost;
  }

  async findByStore(storeId: string): Promise<SocialMediaPost[]> {
    return this.socialMediaPostModel.find({ storeId }).exec();
  }

  async findByOrder(orderId: string): Promise<SocialMediaPost[]> {
    return this.socialMediaPostModel.find({ order: orderId }).exec();
  }
}

================
File: social-media-post/social-media-post.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SocialMediaPostController } from './controllers/social-media-post.controller';
import { SocialMediaPostService } from './services/social-media-post.service';
import { SocialMediaPostSchema } from './schemas/social-media-post.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'SocialMediaPosts', schema: SocialMediaPostSchema }
    ])
  ],
  controllers: [SocialMediaPostController],
  providers: [SocialMediaPostService],
  exports: [SocialMediaPostService]
})
export class SocialMediaPostModule { }

================
File: store/controllers/store.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { StoreService } from '../services/store.service';
import { Store } from '../schemas/store.schema';
import { CreateStoreDTO, UpdateStoreDTO } from '../dtos/store.dto';
@Controller('api/stores')
export class StoreController {
  constructor(private readonly storeService: StoreService) { }

  @Post()
  create(@Body() createStoreDto: CreateStoreDTO) {
    return this.storeService.create(createStoreDto);
  }

  @Get()
  findAll() {
    return this.storeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.storeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateStoreDto: UpdateStoreDTO) {
    return this.storeService.update(id, updateStoreDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.storeService.remove(id);
  }
}

================
File: store/dtos/store.dto.ts
================
export class StoreDTO {
  storeId: string;
  name: string; // Tên cửa hàng
  phone: string; // Số điện thoại
  country: string; // Quốc gia
  region: string; // Khu vực
  businessIndustry: string; // Ngành hàng kinh doanh
  managerId: string; // ID tài khoản chính
  status: string;
  createdAt: Date;
  address?: string;
  email?: string;
  settings?: { timezone: string };
  servicePackage?: string;
  branches?: string[];
  paymentMethods?: string[];
}

export class CreateStoreDTO {
  name: string; // Bắt buộc - Tên cửa hàng
  phone: string; // Bắt buộc - Số điện thoại
  country: string; // Bắt buộc - Quốc gia
  region: string; // Bắt buộc - Khu vực
  businessIndustry: string; // Bắt buộc - Ngành hàng kinh doanh
  managerId: string; // Bắt buộc - ID tài khoản chính (tạo cùng lúc với User)
  status?: string; // Tùy chọn, mặc định là 'active'
  address?: string; // Tùy chọn
  email?: string; // Tùy chọn
  settings?: { timezone: string }; // Tùy chọn
  servicePackage?: string; // Tùy chọn
}

export class UpdateStoreDTO {
  name?: string;
  phone?: string;
  country?: string;
  region?: string;
  businessIndustry?: string;
  managerId?: string;
  status?: string;
  address?: string;
  email?: string;
  settings?: { timezone: string };
  servicePackage?: string;
  branches?: string[];
  paymentMethods?: string[];
}

================
File: store/schemas/store.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Stores' })
export class Store extends Document {
  @Prop({ unique: true, required: true })
  storeId: string;

  @Prop({ required: true })
  name: string; // Tên cửa hàng

  @Prop({ required: true })
  phone: string; // Số điện thoại cửa hàng

  @Prop({ required: true })
  country: string; // Quốc gia

  @Prop({ required: true })
  region: string; // Khu vực

  @Prop({ required: true })
  businessIndustry: string; // Ngành hàng kinh doanh

  @Prop({ type: Types.ObjectId, ref: 'Users', required: true })
  managerId: Types.ObjectId; // Liên kết với tài khoản chính (Store Owner)

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  // Các trường tùy chọn khác (từ gợi ý trước)
  @Prop()
  address?: string;

  @Prop()
  email?: string;

  @Prop({ type: { timezone: String } })
  settings?: { timezone: string };

  @Prop({ type: Types.ObjectId, ref: 'ServicePackages' })
  servicePackage?: Types.ObjectId;

  @Prop({ type: [Types.ObjectId], ref: 'Branches' })
  branches?: Types.ObjectId[];

  @Prop([String])
  paymentMethods?: string[];
}

export const StoreSchema = SchemaFactory.createForClass(Store);

================
File: store/services/store.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Store } from '../schemas/store.schema';
import { CreateStoreDTO, UpdateStoreDTO } from '../dtos/store.dto';
@Injectable()
export class StoreService {
  constructor(
    @InjectModel('Stores') private storeModel: Model<Store>,
  ) {}

  async create(createStoreDto: CreateStoreDTO): Promise<Store> {
    const lastStore = await this.storeModel.findOne().sort({ storeId: -1 }).exec();
    let newStoreId = 'ST0001';
  
    if (lastStore && lastStore.storeId) {
      const lastNumber = parseInt(lastStore.storeId.replace('ST', ''), 10);
      const nextNumber = lastNumber + 1;
      newStoreId = `ST${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdStore = new this.storeModel({
      ...createStoreDto,
      storeId: newStoreId
    });
  
    return createdStore.save();
  }

  async findAll(): Promise<Store[]> {
    return this.storeModel.find().populate('servicePackage').exec();
  }

  async findOne(id: string): Promise<Store> {
    const store = await this.storeModel.findById(id).populate('servicePackage').exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }

  async update(id: string, updateStoreDto: UpdateStoreDTO): Promise<Store> {
    const store = await this.storeModel
      .findByIdAndUpdate(id, updateStoreDto, { new: true })
      .populate('servicePackage')
      .exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }

  async remove(id: string): Promise<Store> {
    const store = await this.storeModel.findByIdAndDelete(id).exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }
}

================
File: store/store.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { StoreController } from './controllers/store.controller';
import { StoreService } from './services/store.service';
import { Store, StoreSchema } from './schemas/store.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Stores', schema: StoreSchema },
    ]),
  ],
  controllers: [StoreController],
  providers: [StoreService],
  exports: [StoreService],
})
export class StoreModule { }

================
File: supplier-group/controllers/supplier-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SupplierGroupService } from '../services/supplier-group.service';
import { SupplierGroup } from '../schemas/supplier-group.schema';
import { CreateSupplierGroupDTO, UpdateSupplierGroupDTO } from '../dtos/supplier-group.dto';
@Controller('api/supplier-groups')
export class SupplierGroupController {
  constructor(private readonly supplierGroupService: SupplierGroupService) { }

  @Post()
  async create(@Body() createBranchDto: CreateSupplierGroupDTO): Promise<SupplierGroup> {
    return this.supplierGroupService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.supplierGroupService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.supplierGroupService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSupplierGroupDto: UpdateSupplierGroupDTO) {
    return this.supplierGroupService.update(id, updateSupplierGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.supplierGroupService.remove(id);
  }
}

================
File: supplier-group/dtos/supplier-group.dto.ts
================
export class SupplierGroupDTO {
  groupId: string;
  name: string;
  description: string;
  status: string;
  createdAt: Date;
  suppliers: string[]; // Thêm
}

export class CreateSupplierGroupDTO {
  name: string;
  description: string;
  status: string;
  suppliers?: string[]; // Tùy chọn
}

export class UpdateSupplierGroupDTO {
  name?: string;
  description?: string;
  status?: string;
  suppliers?: string[]; // Tùy chọn
}

================
File: supplier-group/schemas/supplier-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'SupplierGroups' })
export class SupplierGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  // Trường mới
  @Prop({ type: [Types.ObjectId], ref: 'Suppliers' })
  suppliers: Types.ObjectId[];
}

export const SupplierGroupSchema = SchemaFactory.createForClass(SupplierGroup);

================
File: supplier-group/services/supplier-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SupplierGroup } from '../schemas/supplier-group.schema';
import { CreateSupplierGroupDTO, UpdateSupplierGroupDTO } from '../dtos/supplier-group.dto';
@Injectable()
export class SupplierGroupService {
  constructor(
    @InjectModel('SupplierGroups') private SupplierGroupModel: Model<SupplierGroup>,
  ) { }

  async create(createSupplierGroupDto: CreateSupplierGroupDTO): Promise<SupplierGroup> {
    const lastSupplierGroup = await this.SupplierGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newSupplierGroupId = 'SSG00001';
  
    if (lastSupplierGroup && lastSupplierGroup.groupId) {
      const lastNumber = parseInt(lastSupplierGroup.groupId.replace('SSG', ''), 10);
      const nextNumber = lastNumber + 1;
      newSupplierGroupId = `SSG${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdSupplierGroup = new this.SupplierGroupModel({
      ...createSupplierGroupDto,
      supplierGroupId: newSupplierGroupId
    });
  
    return createdSupplierGroup.save();
  }

  async findAll(): Promise<SupplierGroup[]> {
    return this.SupplierGroupModel.find().exec();
  }

  async findOne(id: string): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel.findById(id).exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }

  async update(id: string, updateSupplierGroupDto: UpdateSupplierGroupDTO): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel
      .findByIdAndUpdate(id, updateSupplierGroupDto, { new: true })
      .exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }

  async remove(id: string): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel.findByIdAndDelete(id).exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }
}

================
File: supplier-group/supplier-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SupplierGroup, SupplierGroupSchema } from './schemas/supplier-group.schema';
import { SupplierGroupController } from './controllers/supplier-group.controller';
import { SupplierGroupService } from './services/supplier-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'SupplierGroups', schema: SupplierGroupSchema }])
  ],
  controllers: [SupplierGroupController],
  providers: [SupplierGroupService],
  exports: [SupplierGroupService]
})
export class SupplierGroupModule { }

================
File: supplier/controllers/supplier.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SupplierService } from '../services/supplier.service';
import { CreateSupplierDTO, UpdateSupplierDTO } from '../dto/supplier.dto';
@Controller('api/suppliers')
export class SupplierController {
  constructor(private readonly supplierService: SupplierService) { }

  @Post()
  create(@Body() createSupplierDto: CreateSupplierDTO) {
    return this.supplierService.create(createSupplierDto);
  }

  @Get()
  findAll() {
    return this.supplierService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.supplierService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSupplierDto: UpdateSupplierDTO) {
    return this.supplierService.update(id, updateSupplierDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.supplierService.remove(id);
  }
}

================
File: supplier/dto/supplier.dto.ts
================
export class SupplierDTO {
  supplierId: string;
  name: string;
  phone: string;
  email: string;
  address: string;
  group: string;
  status: string;
  createdAt: Date;
  products: string[]; // Thêm
  transactionHistory: string[]; // Thêm
}

export class CreateSupplierDTO {
  name: string;
  phone: string;
  email: string;
  address: string;
  group: string;
  status: string;
  products?: string[]; // Tùy chọn
  transactionHistory?: string[]; // Tùy chọn
}

export class UpdateSupplierDTO {
  name?: string;
  phone?: string;
  email?: string;
  address?: string;
  group?: string;
  status?: string;
  products?: string[]; // Tùy chọn
  transactionHistory?: string[]; // Tùy chọn
}

================
File: supplier/schemas/supplier.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Suppliers' })
export class Supplier extends Document {
  @Prop({ unique: true, required: true })
  supplierId: string;

  @Prop({ required: true })
  name: string;

  @Prop()
  phone: string;

  @Prop()
  email: string;

  @Prop()
  address: string;

  @Prop({ type: Types.ObjectId, ref: 'SupplierGroups' })
  group: Types.ObjectId;

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  // Trường mới
  @Prop({ type: [Types.ObjectId], ref: 'Products' })
  products: Types.ObjectId[];

  @Prop({ type: [Types.ObjectId], ref: 'Transactions' })
  transactionHistory: Types.ObjectId[];
}

export const SupplierSchema = SchemaFactory.createForClass(Supplier);

================
File: supplier/services/supplier.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Supplier } from '../schemas/supplier.schema';
import { CreateSupplierDTO, UpdateSupplierDTO } from '../dto/supplier.dto';
@Injectable()
export class SupplierService {
  constructor(
    @InjectModel('Suppliers') private supplierModel: Model<Supplier>,
  ) { }

  async create(createSupplierDto: CreateSupplierDTO): Promise<Supplier> {
    const lastSupplier = await this.supplierModel.findOne().sort({ supplierId: -1 }).exec();
    let newSupplierId = 'SPR00001';
  
    if (lastSupplier && lastSupplier.supplierId) {
      const lastNumber = parseInt(lastSupplier.supplierId.replace('SPR', ''), 10);
      const nextNumber = lastNumber + 1;
      newSupplierId = `SPR${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdSupplier = new this.supplierModel({
      ...createSupplierDto,
      supplierId: newSupplierId
    });
  
    return createdSupplier.save();
  }
  async findAll(): Promise<Supplier[]> {
    return this.supplierModel.find().populate('group').exec();
  }

  async findOne(id: string): Promise<Supplier> {
    const supplier = await this.supplierModel.findById(id).populate('group').exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }

  async update(id: string, updateSupplierDto: UpdateSupplierDTO): Promise<Supplier> {
    const supplier = await this.supplierModel
      .findByIdAndUpdate(id, updateSupplierDto, { new: true })
      .populate('group')
      .exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }

  async remove(id: string): Promise<Supplier> {
    const supplier = await this.supplierModel.findByIdAndDelete(id).exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }
}

================
File: supplier/supplier.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SupplierController } from './controllers/supplier.controller';
import { SupplierService } from './services/supplier.service';
import { Supplier, SupplierSchema } from './schemas/supplier.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Suppliers', schema: SupplierSchema }
    ]),
  ],
  controllers: [SupplierController],
  providers: [SupplierService],
  exports: [SupplierService],
})
export class SupplierModule { }

================
File: transaction/controllers/transaction.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { TransactionService } from '../services/transaction.service';
import { Transaction } from '../schemas/transaction.schema';
import { CreateTransactionDTO, UpdateTransactionDTO } from '../dtos/transaction.dto';
@Controller('api/transactions')
export class TransactionController {
  constructor(private readonly transactionService: TransactionService) { }

  @Post()
  async create(@Body() createTransactionDto: CreateTransactionDTO): Promise<Transaction> {
    return this.transactionService.create(createTransactionDto);
  }

  @Get()
  findAll() {
    return this.transactionService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.transactionService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateTransactionDto: UpdateTransactionDTO) {
    return this.transactionService.update(id, updateTransactionDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.transactionService.remove(id);
  }
}

================
File: transaction/dtos/transaction.dto.ts
================
export class TransactionDTO {
  transactionId: string;
  storeId: string;
  amount: number;
  type: string;
  status: string;
  createdAt: Date;
  details: { productId: string; quantity: number }[]; // Thêm
  accountId: string; // Thêm
}

export class CreateTransactionDTO {
  storeId: string;
  amount: number;
  type: string;
  status: string;
  details?: { productId: string; quantity: number }[]; // Tùy chọn
  accountId?: string; // Tùy chọn
}

export class UpdateTransactionDTO {
  amount?: number;
  type?: string;
  status?: string;
  details?: { productId: string; quantity: number }[]; // Tùy chọn
  accountId?: string; // Tùy chọn
}

================
File: transaction/schemas/transaction.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Transactions' })
export class Transaction extends Document {
  @Prop({ unique: true, required: true })
  transactionId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  amount: number;

  @Prop({ enum: ['payment', 'refund', 'transfer'], required: true })
  type: string;

  @Prop({ enum: ['pending', 'completed', 'failed'], default: 'pending' })
  status: string;

  @Prop({ default: Date.now })
  createdAt: Date;

  // Trường mới
  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  details: { productId: Types.ObjectId; quantity: number }[];

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  accountId: Types.ObjectId;
}

export const TransactionSchema = SchemaFactory.createForClass(Transaction);

================
File: transaction/services/transaction.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateTransactionDTO, UpdateTransactionDTO } from '../dtos/transaction.dto';
import { Transaction } from '../schemas/transaction.schema';
@Injectable()
export class TransactionService {
  constructor(
    @InjectModel('Transactions') private TransactionModel: Model<Transaction>,
  ) { }

  async create(createTransactionDto: CreateTransactionDTO): Promise<Transaction> {
    const lastTransaction = await this.TransactionModel.findOne().sort({ transactionId: -1 }).exec();
    let newTransactionId = 'TRX00001';
  
    if (lastTransaction && lastTransaction.transactionId) {
      const lastNumber = parseInt(lastTransaction.transactionId.replace('TRX', ''), 10);
      const nextNumber = lastNumber + 1;
      newTransactionId = `TRX${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdTransaction = new this.TransactionModel({
      ...createTransactionDto,
      transactionId: newTransactionId
    });
  
    return createdTransaction.save();
  }

  async findAll(): Promise<Transaction[]> {
    return this.TransactionModel.find().exec();
  }

  async findOne(id: string): Promise<Transaction> {
    const transaction = await this.TransactionModel.findById(id).exec();
    if (!transaction) {
        throw new NotFoundException(`Transaction with ID ${id} not found`);
    }
    return transaction;
  }

  async update(id: string, updateTransactionDto: UpdateTransactionDTO): Promise<Transaction> {
    const transaction = await this.TransactionModel
      .findByIdAndUpdate(id, updateTransactionDto, { new: true })
      .exec();
    if (!transaction) {
      throw new NotFoundException(`Transaction with ID ${id} not found`);
    }
    return transaction;
  }

  async remove(id: string): Promise<Transaction> {
    const transaction = await this.TransactionModel.findByIdAndDelete(id).exec();
    if (!transaction) {
      throw new NotFoundException(`Transaction with ID ${id} not found`);
    }
    return transaction;
  }
}

================
File: transaction/transaction.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { TransactionService } from './services/transaction.service';
import { TransactionSchema } from './schemas/transaction.schema';
import { TransactionController } from './controllers/transaction.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Transactions', schema: TransactionSchema }])
  ],
  controllers: [TransactionController],
  providers: [TransactionService],
  exports: [TransactionService]
})
export class TransactionModule { }

================
File: website-setting/controllers/website-settings.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { WebsiteSettingsService } from '../services/website-settings.service';
import { WebsiteSettings } from '../schemas/website-settings.schema';
import { CreateWebsiteSettingsDTO, UpdateWebsiteSettingsDTO } from '../dtos/website-setting.dto';
@Controller('website-settings')
export class WebsiteSettingsController {
  constructor(private readonly websiteSettingsService: WebsiteSettingsService) { }

  @Post()
  async create(@Body() createWebsiteSettingsDto: CreateWebsiteSettingsDTO): Promise<WebsiteSettings> {
    return this.websiteSettingsService.create(createWebsiteSettingsDto);
  }

  @Get()
  async findAll(): Promise<WebsiteSettings[]> {
    return this.websiteSettingsService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<WebsiteSettings> {
    return this.websiteSettingsService.findOne(id);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<WebsiteSettings> {
    return this.websiteSettingsService.findByStore(storeId);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateWebsiteSettingsDto: UpdateWebsiteSettingsDTO,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, updateWebsiteSettingsDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<WebsiteSettings> {
    return this.websiteSettingsService.remove(id);
  }

  @Put(':id/seo')
  async updateSEO(
    @Param('id') id: string,
    @Body() seo: any,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, { seo });
  }
}

================
File: website-setting/dtos/website-setting.dto.ts
================
export class WebsiteSettingsDTO {
  storeId: string;
  domain: string;
  logo: string;
  favicon: string;
  seo: { title: string; description: string; keywords: string[] };
  general: { currency: string; language: string; timezone: string };
  payment: { methods: string[]; defaultMethod: string };
  shipping: { carriers: string[]; defaultCarrier: string };
  social: { facebook: string; twitter: string; instagram: string };
  customization: { header: string; footer: string; css: string };
  languages: string[]; // Thêm
  thirdPartyServices: { googleAnalytics: string; facebookPixel: string }; // Thêm
}

export class CreateWebsiteSettingsDTO {
  storeId: string;
  domain: string;
  logo: string;
  favicon: string;
  seo: { title: string; description: string; keywords: string[] };
  general: { currency: string; language: string; timezone: string };
  payment: { methods: string[]; defaultMethod: string };
  shipping: { carriers: string[]; defaultCarrier: string };
  social: { facebook: string; twitter: string; instagram: string };
  customization: { header: string; footer: string; css: string };
  languages?: string[]; // Tùy chọn
  thirdPartyServices?: { googleAnalytics: string; facebookPixel: string }; // Tùy chọn
}

export class UpdateWebsiteSettingsDTO {
  domain?: string;
  logo?: string;
  favicon?: string;
  seo?: { title?: string; description?: string; keywords?: string[] };
  general?: { currency?: string; language?: string; timezone?: string };
  payment?: { methods?: string[]; defaultMethod?: string };
  shipping?: { carriers?: string[]; defaultCarrier?: string };
  social?: { facebook?: string; twitter?: string; instagram?: string };
  customization?: { header?: string; footer?: string; css?: string };
  languages?: string[]; // Tùy chọn
  thirdPartyServices?: { googleAnalytics?: string; facebookPixel?: string }; // Tùy chọn
}

================
File: website-setting/schemas/website-settings.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'WebsiteSettings' })
export class WebsiteSettings extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  domain: string;

  @Prop()
  logo: string;

  @Prop()
  favicon: string;

  @Prop({ type: { title: String, description: String, keywords: [String] } })
  seo: { title: string; description: string; keywords: string[] };

  @Prop({ type: { currency: String, language: String, timezone: String } })
  general: { currency: string; language: string; timezone: string };

  @Prop({ type: { methods: [String], defaultMethod: String } })
  payment: { methods: string[]; defaultMethod: string };

  @Prop({ type: { carriers: [String], defaultCarrier: String } })
  shipping: { carriers: string[]; defaultCarrier: string };

  @Prop({ type: { facebook: String, twitter: String, instagram: String } })
  social: { facebook: string; twitter: string; instagram: string };

  @Prop({ type: { header: String, footer: String, css: String } })
  customization: { header: string; footer: string; css: string };

  // Trường mới
  @Prop([String])
  languages: string[];

  @Prop({ type: { googleAnalytics: String, facebookPixel: String } })
  thirdPartyServices: { googleAnalytics: string; facebookPixel: string };
}

export const WebsiteSettingsSchema = SchemaFactory.createForClass(WebsiteSettings);

================
File: website-setting/services/website-settings.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { WebsiteSettings } from '../schemas/website-settings.schema';
import { CreateWebsiteSettingsDTO, UpdateWebsiteSettingsDTO } from '../dtos/website-setting.dto';
@Injectable()
export class WebsiteSettingsService {
  constructor(
    @InjectModel('WebsiteSettings')
    private websiteSettingsModel: Model<WebsiteSettings>,
  ) { }

  async create(createWebsiteSettingsDto: CreateWebsiteSettingsDTO): Promise<WebsiteSettings> {
    const created = new this.websiteSettingsModel(createWebsiteSettingsDto);
    return created.save();
  }

  async findAll(): Promise<WebsiteSettings[]> {
    return this.websiteSettingsModel.find().exec();
  }

  async findOne(id: string): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel.findById(id).exec();
    if (!settings) {
      throw new NotFoundException(`Website settings with ID ${id} not found`);
    }
    return settings;
  }

  async findByStore(storeId: string): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel.findOne({ storeId }).exec();
    if (!settings) {
      throw new NotFoundException(`Website settings for store ${storeId} not found`);
    }
    return settings;
  }

  async update(id: string, updateWebsiteSettingsDto: UpdateWebsiteSettingsDTO): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel
      .findByIdAndUpdate(id, updateWebsiteSettingsDto, { new: true })
      .exec();
    if (!settings) {
      throw new NotFoundException(`Website settings with ID ${id} not found`);
    }
    return settings;
  }

  async remove(id: string): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel.findByIdAndDelete(id).exec();
    if (!settings) {
      throw new NotFoundException(`Website settings with ID ${id} not found`);
    }
    return settings;
  }
}

================
File: work-schedule/controllers/work-schedule.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete, Query } from '@nestjs/common';
import { WorkScheduleService } from '../services/work-schedule.service';
import { WorkSchedule } from '../schemas/work-schedule.schema';
import { CreateWorkScheduleDTO, UpdateWorkScheduleDTO } from '../dtos/work-schedule.dto';
@Controller('work-schedules')
export class WorkScheduleController {
  constructor(private readonly workScheduleService: WorkScheduleService) { }

  @Post()
  create(@Body() createWorkScheduleDto: CreateWorkScheduleDTO) {
    return this.workScheduleService.create(createWorkScheduleDto);
  }

  @Get()
  findAll() {
    return this.workScheduleService.findAll();
  }

  @Get('store/:storeId')
  findByStore(@Param('storeId') storeId: string) {
    return this.workScheduleService.findByStore(storeId);
  }

  @Get('employee/:employeeId')
  findByEmployee(@Param('employeeId') employeeId: string) {
    return this.workScheduleService.findByEmployee(employeeId);
  }

  @Get('special-schedules')
  findSpecialSchedulesByDate(@Query('date') date: string) {
    return this.workScheduleService.findSpecialSchedulesByDate(new Date(date));
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.workScheduleService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateWorkScheduleDto: UpdateWorkScheduleDTO) {
    return this.workScheduleService.update(id, updateWorkScheduleDto);
  }

  @Patch(':id/special-schedule')
  updateSpecialSchedule(
    @Param('id') id: string,
    @Body() specialSchedule: {
      date: Date;
      isWorking: boolean;
      startTime: string;
      endTime: string;
      breakTime: string;
      reason: string;
    }
  ) {
    return this.workScheduleService.updateSpecialSchedule(id, specialSchedule);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.workScheduleService.remove(id);
  }
}

================
File: work-schedule/dtos/work-schedule.dto.ts
================
export class WorkScheduleDTO {
  scheduleId: string; // Thêm
  storeId: string;
  employeeId: string;
  date: Date;
  startTime: Date;
  endTime: Date;
  shiftName: string; // Sửa từ shift thành shiftName
  status: string;
  isHoliday: boolean; // Thêm
  repeatSettings: { repeat: boolean; daysOfWeek: string[]; endRepeat: Date }; // Thêm
  notes: string; // Thêm
  createdAt: Date;
}

export class CreateWorkScheduleDTO {
  storeId: string;
  employeeId: string;
  date: Date;
  startTime: Date;
  endTime: Date;
  shiftName: string; // Sửa từ shift thành shiftName
  status: string;
  isHoliday?: boolean; // Tùy chọn
  repeatSettings?: { repeat: boolean; daysOfWeek: string[]; endRepeat: Date }; // Tùy chọn
  notes?: string; // Tùy chọn
}

export class UpdateWorkScheduleDTO {
  date?: Date;
  startTime?: Date;
  endTime?: Date;
  shiftName?: string; // Sửa từ shift thành shiftName
  status?: string;
  isHoliday?: boolean; // Tùy chọn
  repeatSettings?: { repeat: boolean; daysOfWeek: string[]; endRepeat: Date }; // Tùy chọn
  notes?: string; // Tùy chọn
}

================
File: work-schedule/schemas/work-schedule.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'WorkSchedules' })
export class WorkSchedule extends Document {
  @Prop({ unique: true, required: true })
  scheduleId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId;

  @Prop({ required: true })
  date: Date;

  @Prop({ required: true })
  startTime: Date;

  @Prop({ required: true })
  endTime: Date;

  @Prop({ required: true })
  shiftName: string;

  @Prop({ enum: ['scheduled', 'completed', 'missed'], default: 'scheduled' })
  status: string;

  @Prop({ default: false })
  isHoliday: boolean;

  @Prop({ type: { repeat: Boolean, daysOfWeek: [String], endRepeat: Date } })
  repeatSettings: { repeat: boolean; daysOfWeek: string[]; endRepeat: Date };

  @Prop()
  notes: string;
  @Prop()
  shiftType: string;

  @Prop({ type: Types.ObjectId, ref: 'Attendances' })
  attendanceId: Types.ObjectId;
  
  @Prop({ default: Date.now })
  createdAt: Date;
}

export const WorkScheduleSchema = SchemaFactory.createForClass(WorkSchedule);

================
File: work-schedule/services/work-schedule.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { WorkSchedule } from '../schemas/work-schedule.schema';
import { CreateWorkScheduleDTO, UpdateWorkScheduleDTO } from '../dtos/work-schedule.dto';

@Injectable()
export class WorkScheduleService {
  constructor(
    @InjectModel(WorkSchedule.name)
    private workScheduleModel: Model<WorkSchedule>,
  ) { }

  async create(createWorkScheduleDto: CreateWorkScheduleDTO): Promise<WorkSchedule> {
    const lastWorkSchedule = await this.workScheduleModel.findOne().sort({ scheduleId: -1 }).exec();
    let newScheduleId = 'SCH00001';
  
    if (lastWorkSchedule && lastWorkSchedule.scheduleId) {
      const lastNumber = parseInt(lastWorkSchedule.scheduleId.replace('SCH', ''), 10);
      const nextNumber = lastNumber + 1;
      newScheduleId = `SCH${nextNumber.toString().padStart(5, '0')}`;
    }
  
    const createdWorkSchedule = new this.workScheduleModel({
      ...createWorkScheduleDto,
      scheduleId: newScheduleId
    });
  
    return createdWorkSchedule.save();
  }

  async findAll(): Promise<WorkSchedule[]> {
    return this.workScheduleModel.find().exec();
  }

  async findOne(id: string): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel.findById(id).exec();
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }
    return schedule;
  }

  async update(id: string, updateWorkScheduleDto: UpdateWorkScheduleDTO): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel
      .findByIdAndUpdate(id, updateWorkScheduleDto, { new: true })
      .exec();
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }
    return schedule;
  }

  async remove(id: string): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel.findByIdAndDelete(id).exec();
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }
    return schedule;
  }

  async findByStore(storeId: string): Promise<WorkSchedule[]> {
    return this.workScheduleModel.find({ storeId }).exec();
  }

  async findByEmployee(employeeId: string): Promise<WorkSchedule[]> {
    return this.workScheduleModel.find({ employeeId }).exec();
  }

  async findSpecialSchedulesByDate(date: Date): Promise<WorkSchedule[]> {
    return this.workScheduleModel
      .find({
        'specialSchedules.date': {
          $gte: new Date(date.setHours(0, 0, 0, 0)),
          $lt: new Date(date.setHours(23, 59, 59, 999))
        }
      })
      .exec();
  }

  async updateSpecialSchedule(
    id: string,
    specialSchedule: {
      date: Date;
      isWorking: boolean;
      startTime: string;
      endTime: string;
      breakTime: string;
      reason: string;
    }
  ): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel.findById(id);
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }

    const existingScheduleIndex = (schedule as any).specialSchedules.findIndex(
      s => s.date.getTime() === specialSchedule.date.getTime()
    );
    if (existingScheduleIndex >= 0) {
      (schedule as any).specialSchedules[existingScheduleIndex] = specialSchedule;
    } else {
      (schedule as any).specialSchedules.push(specialSchedule);
    }

    return schedule.save();
  }
}

================
File: work-schedule/work-schedule.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { WorkScheduleController } from './controllers/work-schedule.controller';
import { WorkScheduleService } from './services/work-schedule.service';
import { WorkSchedule, WorkScheduleSchema } from './schemas/work-schedule.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'WorkSchedules', schema: WorkScheduleSchema }
    ])
  ],
  controllers: [WorkScheduleController],
  providers: [WorkScheduleService],
  exports: [WorkScheduleService]
})
export class WorkScheduleModule { }



================================================================
End of Codebase
================================================================
