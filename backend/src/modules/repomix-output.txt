This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
attendance/attendance.module.ts
attendance/controllers/attendance.controller.ts
attendance/dtos/attendance.dto.ts
attendance/schemas/attendance.schema.ts
attendance/services/attendance.service.ts
auth/controllers/user.controller.ts
auth/dtos/user.dto.ts
auth/guard/auth.guard.ts
auth/schemas/user.schema.ts
auth/services/user.service.ts
auth/user.module.ts
blog-category/controllers/blog-category.controller.ts
blog-category/dtos/blog-category.dto.ts
blog-category/schemas/blog-category.schema.ts
blog-category/services/blog-category.service.ts
blog-post/controllers/blog-post.controller.ts
blog-post/dtos/blog-category.dto.ts
blog-post/schemas/blog-post.schema.ts
blog-post/services/blog-post.service.ts
branch/branch.module.ts
branch/controllers/branch.controller.ts
branch/dtos/branch.dto.ts
branch/schemas/branch.schema.ts
branch/services/branch.service.ts
brand/brand.module.ts
brand/controllers/brand.controller.ts
brand/dtos/brand.dto.ts
brand/schemas/brand.schema.ts
brand/services/brand.service.ts
carrier-group/carrier-group.module.ts
carrier-group/controllers/carrier-group.controller.ts
carrier-group/dtos/carrier-group.dto.ts
carrier-group/schemas/carrier-group.schema.ts
carrier-group/services/carrier-group.service.ts
carrier/carrier.module.ts
carrier/controllers/carrier.controller.ts
carrier/dtos/carrier.dto.ts
carrier/schemas/carrier.schema.ts
carrier/services/carrier.service.ts
cash-book/cash-book.module.ts
cash-book/controllers/cash-book.controller.ts
cash-book/dtos/cash-book.dto.ts
cash-book/schemas/cash-book.schema.ts
cash-book/services/cash-book.service.ts
categories/categories.module.ts
categories/controllers/categories.controller.ts
categories/dtos/categories.dto.ts
categories/schemas/categories.schema.ts
categories/services/categories.service.ts
commission-setting/commission-setting.module.ts
commission-setting/controllers/commission-setting.controller.ts
commission-setting/dtos/commisson-setting.dto.ts
commission-setting/schemas/commission-setting.schema.ts
commission-setting/services/commission-setting.service.ts
customer-group/controllers/customer-group.controller.ts
customer-group/customer-group.module.ts
customer-group/dtos/customer-group.dto.ts
customer-group/schemas/customer-group.schema.ts
customer-group/services/customer-group.service.ts
customer-loyalty-point/controllers/customer-loyalty-points.controller.ts
customer-loyalty-point/customer-loyalty.module.ts
customer-loyalty-point/dtos/customer-loyalty-point.dto.ts
customer-loyalty-point/schemas/customer-loyalty-points.schema.ts
customer-loyalty-point/services/customer-loyalty-points.service.ts
customer/controllers/customer.controller.ts
customer/customer.module.ts
customer/dtos/customer.dto.ts
customer/schemas/customer.schema.ts
customer/services/customer.service.ts
department/controllers/department.controller.ts
department/department.module.ts
department/dtos/department.dto.ts
department/schemas/department.schema.ts
department/services/department.service.ts
destruction/dtos/destruction.dto.ts
destruction/schemas/destructions.schema.ts
employee/controllers/employee.controller.ts
employee/dtos/employee.dto.ts
employee/employee.module.ts
employee/schemas/employee.schema.ts
employee/services/employee.service.ts
holiday/controllers/holiday.controller.ts
holiday/dtos/holiday.dto.ts
holiday/holiday.module.ts
holiday/schemas/holiday.schema.ts
holiday/services/holiday.service.ts
inventory-check/controllers/inventory-check.controller.ts
inventory-check/dtos/inventory-check.dto.ts
inventory-check/schemas/inventory-check.schema.ts
inventory-check/services/inventory-check.service.ts
invoice/controllers/invoice.controller.ts
invoice/dtos/invoice.dto.ts
invoice/invoice.module.ts
invoice/schemas/invoice.schema.ts
invoice/services/invoice.service.ts
livestream/dtos/livestream.dto.ts
livestream/schemas/livestream.schema.ts
loyalty-program/schemas/loyalty-program.schema.ts
loyalty-program/services/loyalty-program.service.ts
marketing-campaign/controllers/marketing-campaign.controller.ts
marketing-campaign/dtos/marketing-campaign.dto.ts
marketing-campaign/schemas/marketing-campaign.schema.ts
marketing-campaign/services/marketing-campaign.service.ts
marketplace-listing/controllers/marketplace-listing.controller.ts
marketplace-listing/dtos/marketplace-listing.dto.ts
marketplace-listing/marketplace-listing.module.ts
marketplace-listing/schemas/marketplace-listing.schema.ts
marketplace-listing/services/marketplace-listing.service.ts
order/controllers/order.controller.ts
order/dtos/order.dto.ts
order/order.module.ts
order/schemas/order.schema.ts
order/services/order.service.ts
payroll/controllers/payroll.controller.ts
payroll/dtos/payroll.dto.ts
payroll/payroll.module.ts
payroll/schemas/payroll.schema.ts
payroll/services/payroll.service.ts
position/controllers/position.controller.ts
position/dtos/position.dto.ts
position/position.module.ts
position/schemas/position.schema.ts
position/services/position.service.ts
price-list/controllers/price-list.controller.ts
price-list/dtos/price-list.dto.ts
price-list/schemas/price-list.schema.ts
price-list/services/price-list.service.ts
product/controllers/product.controller.ts
product/dtos/product.schema.ts
product/product.module.ts
product/schemas/product.schema.ts
product/services/product.service.ts
purchase-history/controllers/purchase-history.controller.ts
purchase-history/dtos/purchase-history.dto.ts
purchase-history/purchase-history.module.ts
purchase-history/schemas/purchase-history.schema.ts
purchase-history/services/purchase-history.service.ts
purchase-order/controllers/purchase-orders.controller.ts
purchase-order/dtos/purchase-order.dto.ts
purchase-order/purchase-orders.module.ts
purchase-order/schemas/purchase-orders.schema.ts
purchase-order/services/purchase-orders.service.ts
return-purchase/dtos/return-purchase.dto.ts
return-purchase/schemas/return-purchase.schema.ts
ruturn/controllers/return.controller.ts
ruturn/dtos/return.dto.ts
ruturn/return.module.ts
ruturn/schemas/return.schema.ts
ruturn/services/return.service.ts
sale-channel/dtos/sale-channel.dto.ts
sale-channel/schemas/sale-channel.schema.ts
service-package/controllers/service-package.controller.ts
service-package/dtos/service-package.dto.ts
service-package/schemas/service-package.schems.ts
service-package/service-package.module.ts
service-package/services/service-package.service.ts
shipment/controllers/shipment.controller.ts
shipment/dtos/shipment.dto.ts
shipment/schemas/shipment.schema.ts
shipment/services/shipment.service.ts
shipment/shipment.module.ts
social-media-conversation/controllers/social-media-conversation.controller.ts
social-media-conversation/dtos/social-media-conversation.dto.ts
social-media-conversation/schemas/social-media-conversation.schema.ts
social-media-conversation/services/social-media-conversation.service.ts
social-media-post/controllers/social-media-post.controller.ts
social-media-post/dtos/social-media-post.dto.ts
social-media-post/schemas/social-media-post.schema.ts
social-media-post/social-media-post.module.ts
store/controllers/store.controller.ts
store/dtos/store.dto.ts
store/schemas/store.schema.ts
store/services/store.service.ts
store/store.module.ts
supplier-group/controllers/supplier-group.controller.ts
supplier-group/dtos/supplier-group.dto.ts
supplier-group/schemas/supplier-group.schema.ts
supplier-group/services/supplier-group.service.ts
supplier-group/supplier-group.module.ts
supplier/controllers/supplier.controller.ts
supplier/dto/supplier.dto.ts
supplier/schemas/supplier.schema.ts
supplier/services/supplier.service.ts
supplier/supplier.module.ts
transaction/dtos/transaction.dto.ts
transaction/schemas/transaction.schema.ts
website-setting/controllers/website-settings.controller.ts
website-setting/dtos/website-setting.dto.ts
website-setting/schemas/website-settings.schema.ts
website-setting/services/website-settings.service.ts
work-schedule/controllers/work-schedule.controller.ts
work-schedule/dtos/work-schedule.dto.ts
work-schedule/schemas/work-schedule.schema.ts
work-schedule/services/work-schedule.service.ts
work-schedule/work-schedule.module.ts

================================================================
Files
================================================================

================
File: attendance/attendance.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Attendance, AttendanceSchema } from './schemas/attendance.schema';
import { AttendanceService } from './services/attendance.service';
import { AttendanceController } from './controllers/attendance.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Attendances', schema: AttendanceSchema }]),
  ],
  controllers: [AttendanceController],
  providers: [AttendanceService],
})
export class AttendanceModule {}

================
File: attendance/controllers/attendance.controller.ts
================
import { Controller, Get, Post, Body, Param, Delete, Put } from '@nestjs/common';
import { AttendanceService } from '../services/attendance.service';
import { CreateAttendanceDto } from '../dtos/create-attendance.dto';
import { UpdateAttendanceDto } from '../dtos/update-attendance.dto';
import { Attendance } from '../schemas/attendance.schema';

@Controller('api/attendances')
export class AttendanceController {
  constructor(private readonly attendanceService: AttendanceService) { }

  @Post()
  async create(@Body() createAttendanceDto: CreateAttendanceDto): Promise<Attendance> {
    return this.attendanceService.create(createAttendanceDto);
  }

  @Get()
  async findAll(): Promise<Attendance[]> {
    return this.attendanceService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Attendance> {
    return this.attendanceService.findOne(id);
  }

  @Put(':id')
  async update(@Param('id') id: string, @Body() updateAttendanceDto: UpdateAttendanceDto): Promise<Attendance> {
    return this.attendanceService.update(id, updateAttendanceDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Attendance> {
    return this.attendanceService.remove(id);
  }
}

================
File: attendance/dtos/attendance.dto.ts
================
// AttendanceDTO: Đại diện toàn bộ schema
export class AttendanceDTO {
  attendanceId: string; // Mã chấm công
  employeeId: string; // Mã nhân viên
  date: Date; // Ngày chấm công
  checkIn: Date; // Thời gian check-in
  checkOut: Date; // Thời gian check-out
  status: string; // Trạng thái chấm công
  createdAt: Date; // Thời gian tạo
  absenceReason?: string; // Lý do nghỉ
}

// CreateAttendanceDTO: Dùng để tạo mới
export class CreateAttendanceDTO {
  employeeId: string; // Mã nhân viên
  date: Date; // Ngày chấm công
  checkIn: Date; // Thời gian check-in
  checkOut: Date; // Thời gian check-out
  status: string; // Trạng thái chấm công
  absenceReason?: string; // Lý do nghỉ
}

// UpdateAttendanceDTO: Dùng để cập nhật
export class UpdateAttendanceDTO {
  date?: Date; // Ngày chấm công
  checkIn?: Date; // Thời gian check-in
  checkOut?: Date; // Thời gian check-out
  status?: string; // Trạng thái chấm công
  absenceReason?: string; // Lý do nghỉ
}

================
File: attendance/schemas/attendance.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Attendances' })
export class Attendance extends Document {
  @Prop({ unique: true, required: true })
  attendanceId: string; // Mã chấm công duy nhất

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId; // Mã nhân viên liên kết

  @Prop({ required: true })
  date: Date; // Ngày chấm công

  @Prop()
  checkIn: Date; // Thời gian check-in

  @Prop()
  checkOut: Date; // Thời gian check-out

  @Prop({ enum: ['Đúng giờ', 'Đi muộn', 'Về sớm', 'Chưa chấm công', 'Nghỉ làm'], default: 'Chưa chấm công' })
  status: string; // Trạng thái chấm công

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi

  @Prop()
  absenceReason?: string; // Lý do nghỉ (nếu có)
}

export const AttendanceSchema = SchemaFactory.createForClass(Attendance);

================
File: attendance/services/attendance.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Attendance } from '../schemas/attendance.schema';
import { CreateAttendanceDto } from '../dtos/create-attendance.dto';
import { UpdateAttendanceDto } from '../dtos/update-attendance.dto';

@Injectable()
export class AttendanceService {
  constructor(@InjectModel('Attendances') private attendanceModel: Model<Attendance>) {}

  // Thêm mới attendance
  async create(createAttendance: CreateAttendanceDto): Promise<Attendance> {
    const lastUser = await this.attendanceModel.findOne().sort({ attendanceId: -1 }).exec();
    let newAttendanceId = 'ATT0001';

    if (lastUser && lastUser.attendanceId) {
      const lastNumber = parseInt(lastUser.attendanceId.replace('ATT', ''), 10);
      const nextNumber = lastNumber + 1;
      newAttendanceId = `ATT${nextNumber.toString().padStart(4, '0')}`;
    }

    const createdAttendance = new this.attendanceModel({
      ...createAttendance,
      attendanceId: newAttendanceId
    });

    return createdAttendance.save();
  }

  async findAll(): Promise<Attendance[]> {
    return this.attendanceModel.find().exec();
  }

  // Lấy một attendance theo ID
  async findOne(id: string): Promise<Attendance> {
    const attendance = await this.attendanceModel.findById(id).exec();
    if (!attendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return attendance;
  }

  // Cập nhật attendance
  async update(id: string, updateAttendanceDto: UpdateAttendanceDto): Promise<Attendance> {
    const updatedAttendance = await this.attendanceModel.findByIdAndUpdate(id, updateAttendanceDto, { new: true }).exec();
    if (!updatedAttendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return updatedAttendance;
  }

  // Xóa attendance
  async remove(id: string): Promise<Attendance> {
    const deletedAttendance = await this.attendanceModel.findByIdAndDelete(id).exec();
    if (!deletedAttendance) {
      throw new Error(`Attendance with ID ${id} not found`);
    }
    return deletedAttendance;
  }
}

================
File: auth/controllers/user.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UserService } from '../services/user.service';
import { User } from '../schemas/user.schema';

@Controller('api/auth')
export class UserController {
  constructor(private readonly userService: UserService) { }

  @Post()
  create(@Body() createUserDto: any) {
    return this.userService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.userService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: any) {
    return this.userService.update(id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(id);
  }

  @Post('register')
  register(@Body() registerDto: any) {
    return this.userService.register(registerDto);
  }

  @Post('login')
  login(@Body() loginDto: any) {
    return this.userService.login(loginDto.email, loginDto.password);
  }
}

================
File: auth/dtos/user.dto.ts
================
// UserDTO: Đại diện toàn bộ schema
export class UserDTO {
  userId: string; // Mã người dùng
  username: string; // Tên đăng nhập
  password: string; // Mật khẩu
  fullName: string; // Họ và tên
  role: string; // Vai trò
  branch: string; // Mã chi nhánh
  email: string; // Email
  phone: string; // Số điện thoại
  isAdmin: boolean; // Quản trị viên
  createdAt: Date; // Thời gian tạo
  permissions: string[]; // Quyền truy cập
}

// CreateUserDTO: Dùng để tạo mới
export class CreateUserDTO {
  username: string; // Tên đăng nhập
  password: string; // Mật khẩu
  fullName: string; // Họ và tên
  role: string; // Vai trò
  branch: string; // Mã chi nhánh
  email: string; // Email
  phone: string; // Số điện thoại
  isAdmin: boolean; // Quản trị viên
  permissions: string[]; // Quyền truy cập
}

// UpdateUserDTO: Dùng để cập nhật
export class UpdateUserDTO {
  username?: string; // Tên đăng nhập
  password?: string; // Mật khẩu
  fullName?: string; // Họ và tên
  role?: string; // Vai trò
  branch?: string; // Mã chi nhánh
  email?: string; // Email
  phone?: string; // Số điện thoại
  isAdmin?: boolean; // Quản trị viên
  permissions?: string[]; // Quyền truy cập
}

================
File: auth/guard/auth.guard.ts
================
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException, ForbiddenException } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';

@Injectable()
export class AdminGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest();
    const authHeader = request.headers.authorization;

    if (!authHeader) {
      throw new UnauthorizedException('Missing token');
    }

    try {
      const token = authHeader.split(' ')[1];
      const decoded = jwt.verify(token, 'your-secret-key') as { isAdmin: boolean };

      if (!decoded.isAdmin) {
        throw new ForbiddenException('Admin access required');
      }

      return true;
    } catch (error) {
      throw new UnauthorizedException('Invalid token');
    }
  }
}

================
File: auth/schemas/user.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Users' })
export class User extends Document {
  @Prop({ required: true, unique: true })
  userId: string; // Mã người dùng duy nhất

  @Prop({ required: true, unique: true })
  username: string; // Tên đăng nhập

  @Prop({ required: true })
  password: string; // Mật khẩu (mã hóa)

  @Prop({ required: true })
  fullName: string; // Họ và tên

  @Prop({ enum: ['admin', 'user', 'employee'], default: 'employee' })
  role: string; // Vai trò

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branch: Types.ObjectId; // Mã chi nhánh

  @Prop({ match: /^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$/, required: true })
  email: string; // Email

  @Prop()
  phone: string; // Số điện thoại

  @Prop({ default: false })
  isAdmin: boolean; // Trạng thái quản trị viên

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo

  @Prop({ type: [String], default: [] })
  permissions: string[]; // Danh sách quyền
}

export const UserSchema = SchemaFactory.createForClass(User);

================
File: auth/services/user.service.ts
================
import { Injectable, ConflictException, UnauthorizedException, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as bcrypt from 'bcryptjs';
import * as jwt from 'jsonwebtoken';
import { User } from '../schemas/user.schema';

@Injectable()
export class UserService {
  constructor(
    @InjectModel('Users') private userModel: Model<User>,
  ) { }

  async create(createUserDto: any): Promise<User> {
    const existingUser = await this.userModel.findOne({ email: createUserDto.email });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }
  
    // Lấy userId lớn nhất từ database
    const lastUser = await this.userModel.findOne().sort({ userId: -1 }).exec();
    let newUserId = 'USR0001'; // Giá trị mặc định nếu chưa có user nào
  
    if (lastUser && lastUser.userId) {
      const lastNumber = parseInt(lastUser.userId.replace('USR', ''), 10);
      const nextNumber = lastNumber + 1;
      newUserId = `USR${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
    const createdUser = new this.userModel({
      ...createUserDto,
      userId: newUserId,
      password: hashedPassword,
    });
  
    return createdUser.save();
  }
  

  async findAll(): Promise<User[]> {
    return this.userModel.find().exec();
  }

  async findOne(id: string): Promise<User> {
    const user = await this.userModel.findById(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async update(id: string, updateUserDto: any): Promise<User> {
    if (updateUserDto.password) {
      updateUserDto.password = await bcrypt.hash(updateUserDto.password, 10);
    }

    const user = await this.userModel
      .findByIdAndUpdate(id, updateUserDto, { new: true })
      .exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async remove(id: string): Promise<User> {
    const user = await this.userModel.findByIdAndDelete(id).exec();
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }

  async login(email: string, password: string) {
    const user = await this.userModel.findOne({ email });
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const token = jwt.sign(
      {
        userId: user._id,
        role: user.role
      },
      'your-secret-key',
      { expiresIn: '1h' }
    );

    return { token, user };
  }

  async register(registerDto: any) {
    const existingUser = await this.userModel.findOne({ email: registerDto.email });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }

    // Lấy userId lớn nhất từ database
    const lastUser = await this.userModel.findOne().sort({ userId: -1 }).exec();
    let newUserId = 'USR0001'; // Giá trị mặc định nếu chưa có user nào
  
    if (lastUser && lastUser.userId) {
      const lastNumber = parseInt(lastUser.userId.replace('USR', ''), 10);
      const nextNumber = lastNumber + 1;
      newUserId = `USR${nextNumber.toString().padStart(4, '0')}`;
    }

    const hashedPassword = await bcrypt.hash(registerDto.password, 10);
    const user = new this.userModel({
      ...registerDto,
      userId: newUserId,
      password: hashedPassword,
    });
    await user.save();
    return { message: 'User registered successfully' };
  }
}

================
File: auth/user.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from './schemas/user.schema';
import { Branch, BranchSchema } from '../branch/schemas/branch.schema';
import { UserService } from './services/user.service';
import { UserController } from './controllers/user.controller';

@Module({
  imports: [
    // MongooseModule.forFeature([{ name: 'Users', schema: UserSchema }]),
    MongooseModule.forFeature([{ name: 'Users', schema: UserSchema }]),
    MongooseModule.forFeature([{ name: 'Branches', schema: BranchSchema }]),
  ],
  controllers: [UserController],
  providers: [UserService],
  exports: [UserService]
})
export class UserModule { }

================
File: blog-category/controllers/blog-category.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { BlogCategoryService } from '../services/blog-category.service';
import { BlogCategory } from '../schemas/blog-category.schema';

@Controller('api/blog-categories')
export class BlogCategoryController {
  constructor(private readonly blogCategoryService: BlogCategoryService) { }

  @Post()
  async create(@Body() createBlogCategoryDto: any): Promise<BlogCategory> {
    return this.blogCategoryService.create(createBlogCategoryDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<BlogCategory[]> {
    return this.blogCategoryService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<BlogCategory> {
    return this.blogCategoryService.findOne(id);
  }

  @Get('slug/:slug')
  async findBySlug(@Param('slug') slug: string): Promise<BlogCategory> {
    return this.blogCategoryService.findBySlug(slug);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateBlogCategoryDto: any,
  ): Promise<BlogCategory> {
    return this.blogCategoryService.update(id, updateBlogCategoryDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<BlogCategory> {
    return this.blogCategoryService.remove(id);
  }
}

================
File: blog-category/dtos/blog-category.dto.ts
================
// BlogCategoryDTO: Đại diện toàn bộ schema
export class BlogCategoryDTO {
    storeId: string; // Mã cửa hàng
    name: string; // Tên danh mục
    slug: string; // Đường dẫn tĩnh
    description: string; // Mô tả
    parentCategory: string; // Mã danh mục cha
    order: number; // Thứ tự
    status: string; // Trạng thái
    seo: {
      metaTitle: string; // Tiêu đề SEO
      metaDescription: string; // Mô tả SEO
    };
  }
  
  // CreateBlogCategoryDTO: Dùng để tạo mới
  export class CreateBlogCategoryDTO {
    storeId: string; // Mã cửa hàng
    name: string; // Tên danh mục
    slug: string; // Đường dẫn tĩnh
    description: string; // Mô tả
    parentCategory: string; // Mã danh mục cha
    order: number; // Thứ tự
    status: string; // Trạng thái
    seo: {
      metaTitle: string; // Tiêu đề SEO
      metaDescription: string; // Mô tả SEO
    };
  }
  
  // UpdateBlogCategoryDTO: Dùng để cập nhật
  export class UpdateBlogCategoryDTO {
    name?: string; // Tên danh mục
    slug?: string; // Đường dẫn tĩnh
    description?: string; // Mô tả
    parentCategory?: string; // Mã danh mục cha
    order?: number; // Thứ tự
    status?: string; // Trạng thái
    seo?: {
      metaTitle?: string; // Tiêu đề SEO
      metaDescription?: string; // Mô tả SEO
    };
  }

================
File: blog-category/schemas/blog-category.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'BlogCategories' })
export class BlogCategory extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên danh mục

  @Prop({ required: true, unique: true })
  slug: string; // Đường dẫn tĩnh

  @Prop()
  description: string; // Mô tả

  @Prop({ type: Types.ObjectId, ref: 'BlogCategories' })
  parentCategory: Types.ObjectId; // Danh mục cha

  @Prop({ default: 0 })
  order: number; // Thứ tự hiển thị

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ type: { metaTitle: String, metaDescription: String } })
  seo: {
    metaTitle: string; // Tiêu đề SEO
    metaDescription: string; // Mô tả SEO
  };
}

export const BlogCategorySchema = SchemaFactory.createForClass(BlogCategory);

================
File: blog-category/services/blog-category.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BlogCategory } from '../blog-category/schemas/blog-category.schema';

@Injectable()
export class BlogCategoryService {
  constructor(
    @InjectModel(BlogCategory.name)
    private blogCategoryModel: Model<BlogCategory>,
  ) { }

  async create(createBlogCategoryDto: any): Promise<BlogCategory> {
    const created = new this.blogCategoryModel(createBlogCategoryDto);
    return created.save();
  }

  async findAll(query: any = {}): Promise<BlogCategory[]> {
    return this.blogCategoryModel.find(query).exec();
  }

  async findOne(id: string): Promise<BlogCategory> {
    const category = await this.blogCategoryModel.findById(id).exec();
    if (!category) {
      throw new NotFoundException(`Blog category with ID ${id} not found`);
    }
    return category;
  }

  async findBySlug(slug: string): Promise<BlogCategory> {
    const category = await this.blogCategoryModel.findOne({ slug }).exec();
    if (!category) {
      throw new NotFoundException(`Blog category with slug ${slug} not found`);
    }
    return category;
  }

  async update(id: string, updateBlogCategoryDto: any): Promise<BlogCategory> {
    const category = await this.blogCategoryModel
      .findByIdAndUpdate(id, updateBlogCategoryDto, { new: true })
      .exec();
    if (!category) {
      throw new NotFoundException(`Blog category with ID ${id} not found`);
    }
    return category;
  }

  async remove(id: string): Promise<BlogCategory> {
    const category = await this.blogCategoryModel.findByIdAndDelete(id).exec();
    if (!category) {
      throw new NotFoundException(`Blog category with ID ${id} not found`);
    }
    return category;
  }
}

================
File: blog-post/controllers/blog-post.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { BlogPostService } from '../services/blog-post.service';
import { BlogPost } from '../schemas/blog-post.schema';

@Controller('api/blog-posts')
export class BlogPostController {
  constructor(private readonly blogPostService: BlogPostService) { }

  @Post()
  async create(@Body() createBlogPostDto: any): Promise<BlogPost> {
    return this.blogPostService.create(createBlogPostDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<BlogPost[]> {
    return this.blogPostService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.findOne(id);
  }

  @Get('slug/:slug')
  async findBySlug(@Param('slug') slug: string): Promise<BlogPost> {
    return this.blogPostService.findBySlug(slug);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateBlogPostDto: any,
  ): Promise<BlogPost> {
    return this.blogPostService.update(id, updateBlogPostDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<BlogPost> {
    return this.blogPostService.update(id, { status });
  }

  @Post(':id/publish')
  async publish(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, {
      status: 'published',
      'settings.publishDate': new Date(),
    });
  }

  @Post(':id/archive')
  async archive(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { status: 'archived' });
  }

  @Post(':id/feature')
  async feature(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isFeatured': true });
  }

  @Post(':id/unfeature')
  async unfeature(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isFeatured': false });
  }

  @Post(':id/sticky')
  async makeSticky(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isSticky': true });
  }

  @Post(':id/unsticky')
  async removeSticky(@Param('id') id: string): Promise<BlogPost> {
    return this.blogPostService.update(id, { 'settings.isSticky': false });
  }
}

================
File: blog-post/dtos/blog-category.dto.ts
================
// BlogPostDTO: Đại diện toàn bộ schema
export class BlogPostDTO {
  storeId: string; // Mã cửa hàng
  title: string; // Tiêu đề
  slug: string; // Đường dẫn tĩnh
  category: string; // Mã danh mục
  thumbnail: string; // Ảnh đại diện
  content: string; // Nội dung
  excerpt: string; // Đoạn trích
  author: string; // Mã tác giả
  tags: string[]; // Thẻ tag
  status: string; // Trạng thái
  publishedAt: Date; // Thời gian xuất bản
  views: number; // Lượt xem
  likes: number; // Lượt thích
  comments: { user: string; content: string; createdAt: Date }[]; // Bình luận
  seo: {
    metaTitle: string; // Tiêu đề SEO
    metaDescription: string; // Mô tả SEO
    ogImage: string; // Ảnh Open Graph
  };
  title_en?: string; // Tiêu đề tiếng Anh
}

// CreateBlogPostDTO: Dùng để tạo mới
export class CreateBlogPostDTO {
  storeId: string; // Mã cửa hàng
  title: string; // Tiêu đề
  slug: string; // Đường dẫn tĩnh
  category: string; // Mã danh mục
  thumbnail: string; // Ảnh đại diện
  content: string; // Nội dung
  excerpt: string; // Đoạn trích
  author: string; // Mã tác giả
  tags: string[]; // Thẻ tag
  status: string; // Trạng thái
  publishedAt: Date; // Thời gian xuất bản
  seo: {
    metaTitle: string; // Tiêu đề SEO
    metaDescription: string; // Mô tả SEO
    ogImage: string; // Ảnh Open Graph
  };
  title_en?: string; // Tiêu đề tiếng Anh
}

// UpdateBlogPostDTO: Dùng để cập nhật
export class UpdateBlogPostDTO {
  title?: string; // Tiêu đề
  slug?: string; // Đường dẫn tĩnh
  category?: string; // Mã danh mục
  thumbnail?: string; // Ảnh đại diện
  content?: string; // Nội dung
  excerpt?: string; // Đoạn trích
  author?: string; // Mã tác giả
  tags?: string[]; // Thẻ tag
  status?: string; // Trạng thái
  publishedAt?: Date; // Thời gian xuất bản
  seo?: {
    metaTitle?: string; // Tiêu đề SEO
    metaDescription?: string; // Mô tả SEO
    ogImage?: string; // Ảnh Open Graph
  };
  title_en?: string; // Tiêu đề tiếng Anh
}

================
File: blog-post/schemas/blog-post.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'BlogPosts' })
export class BlogPost extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  title: string; // Tiêu đề

  @Prop({ required: true, unique: true })
  slug: string; // Đường dẫn tĩnh

  @Prop({ type: Types.ObjectId, ref: 'BlogCategories', required: true })
  category: Types.ObjectId; // Mã danh mục

  @Prop()
  thumbnail: string; // Ảnh đại diện

  @Prop({ required: true })
  content: string; // Nội dung

  @Prop()
  excerpt: string; // Đoạn trích

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  author: Types.ObjectId; // Mã tác giả

  @Prop({ type: [String], default: [] })
  tags: string[]; // Thẻ tag

  @Prop({ enum: ['draft', 'published', 'archived'], default: 'draft' })
  status: string; // Trạng thái

  @Prop()
  publishedAt: Date; // Thời gian xuất bản

  @Prop({ default: 0 })
  views: number; // Lượt xem

  @Prop({ default: 0 })
  likes: number; // Lượt thích

  @Prop({ type: [{ user: { type: Types.ObjectId, ref: 'Users' }, content: String, createdAt: Date }], default: [] })
  comments: { user: Types.ObjectId; content: string; createdAt: Date }[]; // Bình luận

  @Prop({ type: { metaTitle: String, metaDescription: String, ogImage: String } })
  seo: {
    metaTitle: string; // Tiêu đề SEO
    metaDescription: string; // Mô tả SEO
    ogImage: string; // Ảnh Open Graph
  };

  @Prop()
  title_en?: string; // Tiêu đề tiếng Anh
}

export const BlogPostSchema = SchemaFactory.createForClass(BlogPost);

================
File: blog-post/services/blog-post.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { BlogPost } from '../blog-post/schemas/blog-post.schema';

@Injectable()
export class BlogPostService {
  constructor(
    @InjectModel(BlogPost.name) private blogPostModel: Model<BlogPost>,
  ) { }

  async create(createBlogPostDto: any): Promise<BlogPost> {
    const createdPost = new this.blogPostModel(createBlogPostDto);
    return createdPost.save();
  }

  async findAll(query: any = {}): Promise<BlogPost[]> {
    return this.blogPostModel.find(query).exec();
  }

  async findOne(id: string): Promise<BlogPost> {
    const post = await this.blogPostModel.findById(id).exec();
    if (!post) {
      throw new NotFoundException(`Blog post with ID ${id} not found`);
    }
    return post;
  }

  async findBySlug(slug: string): Promise<BlogPost> {
    const post = await this.blogPostModel.findOne({ slug }).exec();
    if (!post) {
      throw new NotFoundException(`Blog post with slug ${slug} not found`);
    }
    return post;
  }

  async update(id: string, updateBlogPostDto: any): Promise<BlogPost> {
    const post = await this.blogPostModel
      .findByIdAndUpdate(id, updateBlogPostDto, { new: true })
      .exec();
    if (!post) {
      throw new NotFoundException(`Blog post with ID ${id} not found`);
    }
    return post;
  }

  async remove(id: string): Promise<BlogPost> {
    const post = await this.blogPostModel.findByIdAndDelete(id).exec();
    if (!post) {
      throw new NotFoundException(`Blog post with ID ${id} not found`);
    }
    return post;
  }

}

================
File: branch/branch.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BranchController } from './controllers/branch.controller';
import { BranchService } from './services/branch.service';
import { Branch, BranchSchema } from './schemas/branch.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Branches', schema: BranchSchema }])
  ],
  controllers: [BranchController],
  providers: [BranchService],
  exports: [BranchService]
})
export class BranchModule { }

================
File: branch/controllers/branch.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BranchService } from '../services/branch.service';
import { Branch } from '../schemas/branch.schema';
import { CreateBranchDto } from '../dtos/branch.dto';

@Controller('api/branches')
export class BranchController {
  constructor(private readonly branchService: BranchService) { }

  @Post()
  async create(@Body() createBranchDto: CreateBranchDto): Promise<Branch> {
    return this.branchService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.branchService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.branchService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBranchDto: any) {
    return this.branchService.update(id, updateBranchDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.branchService.remove(id);
  }
}

================
File: branch/dtos/branch.dto.ts
================
// BranchDTO: Đại diện toàn bộ schema
export class BranchDTO {
  name: string; // Tên chi nhánh
  location: string; // Vị trí
  createdAt: Date; // Thời gian tạo
  updatedAt: Date; // Thời gian cập nhật
}

// CreateBranchDTO: Dùng để tạo mới
export class CreateBranchDTO {
  name: string; // Tên chi nhánh
  location: string; // Vị trí
}

// UpdateBranchDTO: Dùng để cập nhật
export class UpdateBranchDTO {
  name?: string; // Tên chi nhánh
  location?: string; // Vị trí
}

================
File: branch/schemas/branch.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Branches' })
export class Branch extends Document {
  @Prop({ required: true })
  name: string; // Tên chi nhánh

  @Prop({ required: true })
  location: string; // Vị trí chi nhánh

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo

  @Prop({ default: Date.now })
  updatedAt: Date; // Thời gian cập nhật
}

export const BranchSchema = SchemaFactory.createForClass(Branch);

================
File: branch/services/branch.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Branch } from '../schemas/branch.schema';

@Injectable()
export class BranchService {
  constructor(
    @InjectModel('Branches') private branchModel: Model<Branch>,
  ) { }

  async create(createBranchDto: any): Promise<Branch> {
    const createdBranch = new this.branchModel(createBranchDto);
    return createdBranch.save();
  }

  async findAll(): Promise<Branch[]> {
    return this.branchModel.find().exec();
  }

  async findOne(id: string): Promise<Branch> {
    const branch = await this.branchModel.findById(id).exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }

  async update(id: string, updateBranchDto: any): Promise<Branch> {
    const branch = await this.branchModel
      .findByIdAndUpdate(id, updateBranchDto, { new: true })
      .exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }

  async remove(id: string): Promise<Branch> {
    const branch = await this.branchModel.findByIdAndDelete(id).exec();
    if (!branch) {
      throw new NotFoundException(`Branch with ID ${id} not found`);
    }
    return branch;
  }
}

================
File: brand/brand.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { BrandController } from './controllers/brand.controller';
import { BrandService } from './services/brand.service';
import { Brand, BrandSchema } from './schemas/brand.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Brands', schema: BrandSchema }])
  ],
  controllers: [BrandController],
  providers: [BrandService],
  exports: [BrandService]
})
export class BrandModule { }

================
File: brand/controllers/brand.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { BrandService } from '../services/brand.service';
import { Brand } from '../schemas/brand.schema';

@Controller('api/brands')
export class BrandController {
  constructor(private readonly brandService: BrandService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<Brand> {
    return this.brandService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.brandService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.brandService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.brandService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.brandService.remove(id);
  }
}

================
File: brand/dtos/brand.dto.ts
================
// BrandDTO: Đại diện toàn bộ schema
export class BrandDTO {
    brandId: string; // Mã thương hiệu
    name: string; // Tên thương hiệu
    createdAt: Date; // Thời gian tạo
  }
  
  // CreateBrandDTO: Dùng để tạo mới
  export class CreateBrandDTO {
    name: string; // Tên thương hiệu
  }
  
  // UpdateBrandDTO: Dùng để cập nhật
  export class UpdateBrandDTO {
    name?: string; // Tên thương hiệu
  }

================
File: brand/schemas/brand.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Brands' })
export class Brand extends Document {
  @Prop({ unique: true, required: true })
  brandId: string; // Mã thương hiệu

  @Prop({ required: true })
  name: string; // Tên thương hiệu

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const BrandSchema = SchemaFactory.createForClass(Brand);

================
File: brand/services/brand.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Brand } from '../schemas/brand.schema';

@Injectable()
export class BrandService {
  constructor(
    @InjectModel('Brands') private brandModel: Model<Brand>,
  ) { }

  async create(createBrandDto: any): Promise<Brand> {
    const lastBrand = await this.brandModel.findOne().sort({ brandId: -1 }).exec();
    let newBrandId = 'BR0001';
  
    if (lastBrand && lastBrand.brandId) {
      const lastNumber = parseInt(lastBrand.brandId.replace('BR', ''), 10);
      const nextNumber = lastNumber + 1;
      newBrandId = `BR${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdBrand = new this.brandModel({
      ...createBrandDto,
      brandId: newBrandId
    });
  
    return createdBrand.save();
  }

  async findAll(): Promise<Brand[]> {
    return this.brandModel.find().exec();
  }

  async findOne(id: string): Promise<Brand> {
    const brand = await this.brandModel.findById(id).exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }

  async update(id: string, updateBrandDto: any): Promise<Brand> {
    const brand = await this.brandModel
      .findByIdAndUpdate(id, updateBrandDto, { new: true })
      .exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }

  async remove(id: string): Promise<Brand> {
    const brand = await this.brandModel.findByIdAndDelete(id).exec();
    if (!brand) {
      throw new NotFoundException(`Brand with ID ${id} not found`);
    }
    return brand;
  }
}

================
File: carrier-group/carrier-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CarrierGroup, CarrierGroupSchema } from './schemas/carrier-group.schema';
import { CarrierGroupController } from './controllers/carrier-group.controller';
import { CarrierGroupService } from './services/carrier-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CarrierGroups', schema: CarrierGroupSchema }])
  ],
  controllers: [CarrierGroupController],
  providers: [CarrierGroupService],
  exports: [CarrierGroupService]
})
export class CarrierGroupModule { }

================
File: carrier-group/controllers/carrier-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CarrierGroupService } from '../services/carrier-group.service';
import { CarrierGroup } from '../schemas/carrier-group.schema';

@Controller('api/carriers-groups')
export class CarrierGroupController {
  constructor(private readonly carriersService: CarrierGroupService) { }

  @Post()
  async create(@Body() createCarrierGroupDto: any): Promise<CarrierGroup> {
    return this.carriersService.create(createCarrierGroupDto);
  }

  @Get()
  findAll() {
    return this.carriersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.carriersService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCarrierGroupDto: any) {
    return this.carriersService.update(id, updateCarrierGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.carriersService.remove(id);
  }
}

================
File: carrier-group/dtos/carrier-group.dto.ts
================
// CarrierGroupDTO: Đại diện toàn bộ schema
export class CarrierGroupDTO {
    groupId: string; // Mã nhóm
    name: string; // Tên nhóm
    description: string; // Mô tả
    createdAt: Date; // Thời gian tạo
  }
  
  // CreateCarrierGroupDTO: Dùng để tạo mới
  export class CreateCarrierGroupDTO {
    name: string; // Tên nhóm
    description: string; // Mô tả
  }
  
  // UpdateCarrierGroupDTO: Dùng để cập nhật
  export class UpdateCarrierGroupDTO {
    name?: string; // Tên nhóm
    description?: string; // Mô tả
  }

================
File: carrier-group/schemas/carrier-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'CarrierGroups' })
export class CarrierGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string; // Mã nhóm đơn vị vận chuyển

  @Prop({ required: true })
  name: string; // Tên nhóm

  @Prop()
  description: string; // Mô tả

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CarrierGroupSchema = SchemaFactory.createForClass(CarrierGroup);

================
File: carrier-group/services/carrier-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CarrierGroup } from '../schemas/carrier-group.schema';

@Injectable()
export class CarrierGroupService {
  constructor(
    @InjectModel('CarrierGroups') private carrierGroupModel: Model<CarrierGroup>,
  ) { }

  async create(createCarrierGroupDto: any): Promise<CarrierGroup> {
    const lastCarrierGroup = await this.carrierGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newCarrierGroupId = 'CG0001';
  
    if (lastCarrierGroup && lastCarrierGroup.groupId) {
      const lastNumber = parseInt(lastCarrierGroup.groupId.replace('CG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCarrierGroupId = `CG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCarrierGroup = new this.carrierGroupModel({
      ...createCarrierGroupDto,
      carrierGroupId: newCarrierGroupId
    });
  
    return createdCarrierGroup.save();
  }

  async findAll(): Promise<CarrierGroup[]> {
    return this.carrierGroupModel.find().exec();
  }

  async findOne(id: string): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel.findById(id).exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }

  async update(id: string, updateCarrierGroupDto: any): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel
      .findByIdAndUpdate(id, updateCarrierGroupDto, { new: true })
      .exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }

  async remove(id: string): Promise<CarrierGroup> {
    const carrierGroup = await this.carrierGroupModel.findByIdAndDelete(id).exec();
    if (!carrierGroup) {
      throw new NotFoundException(`carrierGroup with ID ${id} not found`);
    }
    return carrierGroup;
  }
}

================
File: carrier/carrier.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Carrier, CarrierSchema } from './schemas/carrier.schema';
import { CarrierService } from './services/carrier.service';
import { CarrierController } from './controllers/carrier.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Carriers', schema: CarrierSchema }])
  ],
  controllers: [CarrierController],
  providers: [CarrierService],
  exports: [CarrierService]
})
export class CarrierModule { }

================
File: carrier/controllers/carrier.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CarrierService } from '../services/carrier.service';

@Controller('api/carriers')
export class CarrierController {
  constructor(private readonly carrierService: CarrierService) { }
  @Post()
  create(@Body() createBrandDto: any) {
    return this.carrierService.create(createBrandDto);
  }
  @Get()
  findAll() {
    return this.carrierService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.carrierService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.carrierService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.carrierService.remove(id);
  }
}

================
File: carrier/dtos/carrier.dto.ts
================
// CarrierDTO: Đại diện toàn bộ schema
export class CarrierDTO {
    carrierId: string; // Mã đơn vị vận chuyển
    name: string; // Tên
    phone: string; // Số điện thoại
    email: string; // Email
    address: string; // Địa chỉ
    group: string; // Mã nhóm
    totalOrders: number; // Tổng đơn hàng
    totalFees: number; // Tổng phí
    status: string; // Trạng thái
    createdAt: Date; // Thời gian tạo
    updatedAt: Date; // Thời gian cập nhật
  }
  
  // CreateCarrierDTO: Dùng để tạo mới
  export class CreateCarrierDTO {
    name: string; // Tên
    phone: string; // Số điện thoại
    email: string; // Email
    address: string; // Địa chỉ
    group: string; // Mã nhóm
    status: string; // Trạng thái
  }
  
  // UpdateCarrierDTO: Dùng để cập nhật
  export class UpdateCarrierDTO {
    name?: string; // Tên
    phone?: string; // Số điện thoại
    email?: string; // Email
    address?: string; // Địa chỉ
    group?: string; // Mã nhóm
    status?: string; // Trạng thái
  }

================
File: carrier/schemas/carrier.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Carriers' })
export class Carrier extends Document {
  @Prop({ unique: true, required: true })
  carrierId: string; // Mã đơn vị vận chuyển

  @Prop({ required: true })
  name: string; // Tên đơn vị vận chuyển

  @Prop()
  phone: string; // Số điện thoại

  @Prop()
  email: string; // Email

  @Prop()
  address: string; // Địa chỉ

  @Prop({ type: Types.ObjectId, ref: 'CarrierGroups' })
  group: Types.ObjectId; // Mã nhóm đơn vị vận chuyển

  @Prop({ default: 0 })
  totalOrders: number; // Tổng số đơn hàng

  @Prop({ default: 0 })
  totalFees: number; // Tổng phí vận chuyển

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo

  @Prop({ default: Date.now })
  updatedAt: Date; // Thời gian cập nhật
}

export const CarrierSchema = SchemaFactory.createForClass(Carrier);

================
File: carrier/services/carrier.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Carrier } from '../schemas/carrier.schema';

@Injectable()
export class CarrierService {
  constructor(@InjectModel('Carriers') private CarrierModel: Model<Carrier>) {}

  async create(createCarrierDto: any): Promise<Carrier> {
    const lastCarrier = await this.CarrierModel.findOne().sort({ carrierId: -1 }).exec();
    let newCarrierId = 'CG0001';
  
    if (lastCarrier && lastCarrier.carrierId) {
      const lastNumber = parseInt(lastCarrier.carrierId.replace('CG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCarrierId = `CG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCarrier = new this.CarrierModel({
      ...createCarrierDto,
      carrierId: newCarrierId
    });
  
    return createdCarrier.save();
  }
  async findAll(): Promise<Carrier[]> {
    return this.CarrierModel.find().exec();
  }

  async findOne(id: string): Promise<Carrier> {
    const brand = await this.CarrierModel.findById(id).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }

  async update(id: string, updateBrandDto: any): Promise<Carrier> {
    const brand = await this.CarrierModel.findByIdAndUpdate(
      id,
      updateBrandDto,
      { new: true },
    ).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }

  async remove(id: string): Promise<Carrier> {
    const brand = await this.CarrierModel.findByIdAndDelete(id).exec();
    if (!brand) {
      throw new NotFoundException(`Carrier with ID ${id} not found`);
    }
    return brand;
  }
}

================
File: cash-book/cash-book.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CashBookController } from './controllers/cash-book.controller';
import { CashBookService } from './services/cash-book.service';
import { CashBook, CashBookSchema } from './schemas/cash-book.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CashBooks', schema: CashBookSchema }])
  ],
  controllers: [CashBookController],
  providers: [CashBookService],
  exports: [CashBookService]
})
export class CashBookModule { }

================
File: cash-book/controllers/cash-book.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { CashBookService } from '../services/cash-book.service';
import { CashBook } from '../schemas/cash-book.schema';

@Controller('api/cash-books')
export class CashBookController {
  constructor(private readonly cashBookService: CashBookService) { }

  @Post()
  async create(@Body() createCashBookDto: any): Promise<CashBook> {
    return this.cashBookService.create(createCashBookDto);
  }

  @Get()
  async findAll(
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('type') type?: string
  ): Promise<CashBook[]> {
    return this.cashBookService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<CashBook> {
    return this.cashBookService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateCashBookDto: any,
  ): Promise<CashBook> {
    return this.cashBookService.update(id, updateCashBookDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<CashBook> {
    return this.cashBookService.remove(id);
  }

  @Put(':id/approve')
  async approve(@Param('id') id: string): Promise<CashBook> {
    const updateDto = { status: 'approved' };
    return this.cashBookService.update(id, updateDto);
  }

  @Put(':id/reject')
  async reject(@Param('id') id: string): Promise<CashBook> {
    const updateDto = { status: 'rejected' };
    return this.cashBookService.update(id, updateDto);
  }
}

================
File: cash-book/dtos/cash-book.dto.ts
================
// CashBookDTO: Đại diện toàn bộ schema
export class CashBookDTO {
    cashBookId: string; // Mã sổ quỹ
    storeId: string; // Mã cửa hàng
    type: string; // Loại giao dịch
    category: string; // Danh mục
    amount: number; // Số tiền
    paymentMethod: string; // Phương thức thanh toán
    reference: string; // Tham chiếu
    referenceId: string; // Mã tham chiếu
    description: string; // Mô tả
    date: Date; // Ngày giao dịch
    employeeId: string; // Mã nhân viên
    attachments: string[]; // Tệp đính kèm
    status: string; // Trạng thái
    notes: string; // Ghi chú
  }
  
  // CreateCashBookDTO: Dùng để tạo mới
  export class CreateCashBookDTO {
    storeId: string; // Mã cửa hàng
    type: string; // Loại giao dịch
    category: string; // Danh mục
    amount: number; // Số tiền
    paymentMethod: string; // Phương thức thanh toán
    reference: string; // Tham chiếu
    referenceId: string; // Mã tham chiếu
    description: string; // Mô tả
    date: Date; // Ngày giao dịch
    employeeId: string; // Mã nhân viên
    attachments: string[]; // Tệp đính kèm
    status: string; // Trạng thái
    notes: string; // Ghi chú
  }
  
  // UpdateCashBookDTO: Dùng để cập nhật
  export class UpdateCashBookDTO {
    type?: string; // Loại giao dịch
    category?: string; // Danh mục
    amount?: number; // Số tiền
    paymentMethod?: string; // Phương thức thanh toán
    reference?: string; // Tham chiếu
    referenceId?: string; // Mã tham chiếu
    description?: string; // Mô tả
    date?: Date; // Ngày giao dịch
    employeeId?: string; // Mã nhân viên
    attachments?: string[]; // Tệp đính kèm
    status?: string; // Trạng thái
    notes?: string; // Ghi chú
  }

================
File: cash-book/schemas/cash-book.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true, collection: 'CashBooks' })
export class CashBook extends Document {
  @Prop({ unique: true, required: true })
  cashBookId: string;

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ enum: ['Thu', 'Chi'], required: true })
  type: string;

  @Prop({
    enum: [
      'Thu từ bán hàng',
      'Thu từ khác',
      'Chi mua hàng',
      'Chi lương',
      'Chi vận chuyển',
      'Chi marketing',
      'Chi khác',
    ],
    required: true,
  })
  category: string;

  @Prop({ required: true })
  amount: number;

  @Prop({
    enum: ['Tiền mặt', 'Chuyển khoản', 'Thẻ tín dụng', 'Ví điện tử'],
    required: true,
  })
  paymentMethod: string;

  @Prop({
    enum: ['Đơn hàng', 'Hóa đơn', 'Phiếu nhập', 'Phiếu xuất', 'Khác'],
    required: true,
  })
  reference: string;

  @Prop({ type: Types.ObjectId, ref: 'Orders' })
  referenceId: Types.ObjectId;

  @Prop()
  description: string;

  @Prop({ required: true, default: Date.now })
  date: Date;

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId;

  @Prop([String])
  attachments: string[];

  @Prop({ enum: ['Đã xác nhận', 'Chờ xác nhận', 'Đã hủy'], default: 'Chờ xác nhận' })
  status: string;

  @Prop()
  notes: string;
}

export const CashBookSchema = SchemaFactory.createForClass(CashBook);

================
File: cash-book/services/cash-book.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CashBook } from '../schemas/cash-book.schema';

@Injectable()
export class CashBookService {
  constructor(
    @InjectModel('CashBooks') private cashBookModel: Model<CashBook>,
  ) { }

  async create(createCashBookDto: any): Promise<CashBook> {
    const lastCashBook = await this.cashBookModel.findOne().sort({ cashBookId: -1 }).exec();
    let newCashBookId = 'CB0001';
  
    if (lastCashBook && lastCashBook.cashBookId) {
      const lastNumber = parseInt(lastCashBook.cashBookId.replace('CB', ''), 10);
      const nextNumber = lastNumber + 1;
      newCashBookId = `CB${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCashBook = new this.cashBookModel({
      ...createCashBookDto,
      cashBookId: newCashBookId
    });
  
    return createdCashBook.save();
  }

  async findAll(): Promise<CashBook[]> {
    return this.cashBookModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
  }

  async findOne(id: string): Promise<CashBook> {
    const cashBook = await this.cashBookModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }

  async update(id: string, updateCashBookDto: any): Promise<CashBook> {
    const cashBook = await this.cashBookModel
      .findByIdAndUpdate(id, updateCashBookDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('account')
      .exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }

  async remove(id: string): Promise<CashBook> {
    const cashBook = await this.cashBookModel.findByIdAndDelete(id).exec();
    if (!cashBook) {
      throw new NotFoundException(`Cash book with ID ${id} not found`);
    }
    return cashBook;
  }
}

================
File: categories/categories.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CategoriesController } from './controllers/categories.controller';
import { CategoriesService } from './services/categories.service';
import { Categories, CategoriesSchema } from './schemas/categories.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Categories', schema: CategoriesSchema }])
  ],
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService]
})
export class CategoriesModule { }

================
File: categories/controllers/categories.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CategoriesService } from '../services/categories.service';

@Controller('api/categories')
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) { }

  @Post()
  create(@Body() createCategoriesDto: any) {
    return this.categoriesService.create(createCategoriesDto);
  }

  @Get()
  findAll() {
    return this.categoriesService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.categoriesService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCategoriesDto: any) {
    return this.categoriesService.update(id, updateCategoriesDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.categoriesService.remove(id);
  }
}

================
File: categories/dtos/categories.dto.ts
================
// CategoriesDTO: Đại diện toàn bộ schema
export class CategoriesDTO {
  categoryId: string; // Mã danh mục
  name: string; // Tên danh mục
  parentCategory: string; // Mã danh mục cha
  createdAt: Date; // Thời gian tạo
}

// CreateCategoriesDTO: Dùng để tạo mới
export class CreateCategoriesDTO {
  name: string; // Tên danh mục
  parentCategory: string; // Mã danh mục cha
}

// UpdateCategoriesDTO: Dùng để cập nhật
export class UpdateCategoriesDTO {
  name?: string; // Tên danh mục
  parentCategory?: string; // Mã danh mục cha
}

================
File: categories/schemas/categories.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Categories' })
export class Categories extends Document {
  @Prop({ unique: true, required: true })
  categoryId: string; // Mã danh mục

  @Prop({ required: true })
  name: string; // Tên danh mục

  @Prop({ type: Types.ObjectId, ref: 'Categories' })
  parentCategory: Types.ObjectId; // Mã danh mục cha

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CategoriesSchema = SchemaFactory.createForClass(Categories);

================
File: categories/services/categories.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Categories } from '../schemas/categories.schema';

@Injectable()
export class CategoriesService {
  constructor(
    @InjectModel('Categories') private categoriesModel: Model<Categories>,
  ) { }

  async create(createCategoriesDto: any): Promise<Categories> {
    const lastCategories = await this.categoriesModel.findOne().sort({ categoryId: -1 }).exec();
    let newCategoryId = 'CT0001';
  
    if (lastCategories && lastCategories.categoryId) {
      const lastNumber = parseInt(lastCategories.categoryId.replace('CT', ''), 10);
      const nextNumber = lastNumber + 1;
      newCategoryId = `CT${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCategories = new this.categoriesModel({
      ...createCategoriesDto,
      categoryId: newCategoryId
    });
  
    return createdCategories.save();
  }

  async findAll(): Promise<Categories[]> {
    return this.categoriesModel.find().populate('parentCategory').exec();
  }

  async findOne(id: string): Promise<Categories> {
    const category = await this.categoriesModel.findById(id).populate('parentCategory').exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async update(id: string, updateCategoriesDto: any): Promise<Categories> {
    const category = await this.categoriesModel
      .findByIdAndUpdate(id, updateCategoriesDto, { new: true })
      .populate('parentCategory')
      .exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }

  async remove(id: string): Promise<Categories> {
    const category = await this.categoriesModel.findByIdAndDelete(id).exec();
    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }
    return category;
  }
}

================
File: commission-setting/commission-setting.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CommissionSetting, CommissionSettingSchema } from './schemas/commission-setting.schema';
import { CommissionSettingController } from './controllers/commission-setting.controller';
import { CommissionSettingService } from './services/commission-setting.service';


@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CommissionSettings', schema: CommissionSettingSchema }])
  ],
  controllers: [CommissionSettingController],
  providers: [CommissionSettingService],
  exports: [CommissionSettingService]
})
export class CommissionSettingModule { }

================
File: commission-setting/controllers/commission-setting.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CommissionSettingService } from '../services/commission-setting.service';
import { CommissionSetting } from '../schemas/commission-setting.schema';

@Controller('api/commission-settings')
export class CommissionSettingController {
  constructor(private readonly commissionSettingService: CommissionSettingService) { }

  @Post()
  async create(@Body() createCashBookDto: any): Promise<CommissionSetting> {
    return this.commissionSettingService.create(createCashBookDto);
  }

  @Get()
  findAll() {
    return this.commissionSettingService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.commissionSettingService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.commissionSettingService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.commissionSettingService.remove(id);
  }
}

================
File: commission-setting/dtos/commisson-setting.dto.ts
================
// CommissionSettingDTO: Đại diện toàn bộ schema
export class CommissionSettingDTO {
  commissionId: string; // Mã thiết lập
  name: string; // Tên thiết lập
  scope: string; // Phạm vi
  branchId: string; // Mã chi nhánh
  status: string; // Trạng thái
  details: { productId: string; rate: number }[]; // Chi tiết hoa hồng
  createdAt: Date; // Thời gian tạo
}

// CreateCommissionSettingDTO: Dùng để tạo mới
export class CreateCommissionSettingDTO {
  name: string; // Tên thiết lập
  scope: string; // Phạm vi
  branchId: string; // Mã chi nhánh
  status: string; // Trạng thái
  details: { productId: string; rate: number }[]; // Chi tiết hoa hồng
}

// UpdateCommissionSettingDTO: Dùng để cập nhật
export class UpdateCommissionSettingDTO {
  name?: string; // Tên thiết lập
  scope?: string; // Phạm vi
  branchId?: string; // Mã chi nhánh
  status?: string; // Trạng thái
  details?: { productId: string; rate: number }[]; // Chi tiết hoa hồng
}

================
File: commission-setting/schemas/commission-setting.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'CommissionSettings' })
export class CommissionSetting extends Document {
  @Prop({ unique: true, required: true })
  commissionId: string; // Mã thiết lập hoa hồng

  @Prop({ required: true })
  name: string; // Tên thiết lập

  @Prop({ enum: ['global', 'branch'], required: true })
  scope: string; // Phạm vi áp dụng

  @Prop({ type: Types.ObjectId, ref: 'Branches' })
  branchId: Types.ObjectId; // Mã chi nhánh

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ type: [{ productId: Types.ObjectId, rate: Number }] })
  details: { productId: Types.ObjectId; rate: number }[]; // Chi tiết hoa hồng

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CommissionSettingSchema = SchemaFactory.createForClass(CommissionSetting);

================
File: commission-setting/services/commission-setting.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { CommissionSetting } from '../schemas/commission-setting.schema';

@Injectable()
export class CommissionSettingService {
  constructor(
    @InjectModel('CommissionSettings')
    private commissionSettingModel: Model<CommissionSetting>,
  ) {}

  async create(createCommissionSettingDto: any): Promise<CommissionSetting> {
    // Convert string IDs to ObjectIds in details array
    if (createCommissionSettingDto.details) {
      createCommissionSettingDto.details =
        createCommissionSettingDto.details.map((detail) => ({
          ...detail,
          productId: new Types.ObjectId(detail.productId),
        }));
    }

    const lastCommissionSetting = await this.commissionSettingModel
      .findOne()
      .sort({ commissionId: -1 })
      .exec();
    let newCommissionSettingId = 'CMS0001';

    if (lastCommissionSetting && lastCommissionSetting.commissionId) {
      const lastNumber = parseInt(
        lastCommissionSetting.commissionId.replace('CMS', ''),
        10,
      );
      const nextNumber = lastNumber + 1;
      newCommissionSettingId = `CS${nextNumber.toString().padStart(4, '0')}`;
    }

    const createdCommissionSetting = new this.commissionSettingModel({
      ...createCommissionSettingDto,
      commissionId: newCommissionSettingId,
    });

    return createdCommissionSetting.save();
  }

  async findAll(): Promise<CommissionSetting[]> {
    return this.commissionSettingModel.find().exec();
  }

  async findOne(id: string): Promise<CommissionSetting> {
    const commissionSetting = await this.commissionSettingModel
      .findById(id)
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }

  async update(
    id: string,
    updateCommissionSettingDto: any,
  ): Promise<CommissionSetting> {
    // Convert string IDs to ObjectIds in details array if present
    if (updateCommissionSettingDto.details) {
      updateCommissionSettingDto.details =
        updateCommissionSettingDto.details.map((detail) => ({
          ...detail,
          productId: new Types.ObjectId(detail.productId),
        }));
    }

    const commissionSetting = await this.commissionSettingModel
      .findByIdAndUpdate(id, updateCommissionSettingDto, { new: true })
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }

  async remove(id: string): Promise<CommissionSetting> {
    const commissionSetting = await this.commissionSettingModel
      .findByIdAndDelete(id)
      .exec();
    if (!commissionSetting) {
      throw new NotFoundException(`Commission setting with ID ${id} not found`);
    }
    return commissionSetting;
  }
}

================
File: customer-group/controllers/customer-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerGroupService } from '../services/customer-group.service';
import { CustomerGroup } from '../schemas/customer-group.schema';

@Controller('api/customer-groups')
export class CustomerGroupController {
  constructor(private readonly customerGroupService: CustomerGroupService) { }

  @Post()
  create(@Body() createCustomerGroupDto: any) {
    return this.customerGroupService.create(createCustomerGroupDto);
  }

  @Get()
  findAll() {
    return this.customerGroupService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerGroupService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerGroupDto: any) {
    return this.customerGroupService.update(id, updateCustomerGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerGroupService.remove(id);
  }
}

================
File: customer-group/customer-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerGroupSchema } from './schemas/customer-group.schema';
import { CustomerGroupController } from './controllers/customer-group.controller';
import { CustomerGroupService } from './services/customer-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CustomerGroups', schema: CustomerGroupSchema }])
  ],
  controllers: [CustomerGroupController],
  providers: [CustomerGroupService],
  exports: [CustomerGroupService]
})
export class CustomerModule { }

================
File: customer-group/dtos/customer-group.dto.ts
================
// CustomerGroupDTO: Đại diện toàn bộ schema
export class CustomerGroupDTO {
  groupId: string; // Mã nhóm
  name: string; // Tên nhóm
  discountType: string; // Loại chiết khấu
  discountValue: number; // Giá trị chiết khấu
  description: string; // Mô tả
  createdAt: Date; // Thời gian tạo
}

// CreateCustomerGroupDTO: Dùng để tạo mới
export class CreateCustomerGroupDTO {
  name: string; // Tên nhóm
  discountType: string; // Loại chiết khấu
  discountValue: number; // Giá trị chiết khấu
  description: string; // Mô tả
}

// UpdateCustomerGroupDTO: Dùng để cập nhật
export class UpdateCustomerGroupDTO {
  name?: string; // Tên nhóm
  discountType?: string; // Loại chiết khấu
  discountValue?: number; // Giá trị chiết khấu
  description?: string; // Mô tả
}

================
File: customer-group/schemas/customer-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'CustomerGroups' })
export class CustomerGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string; // Mã nhóm khách hàng

  @Prop({ required: true })
  name: string; // Tên nhóm

  @Prop({ enum: ['VND', '%'], required: true })
  discountType: string; // Loại chiết khấu

  @Prop({ required: true })
  discountValue: number; // Giá trị chiết khấu

  @Prop()
  description: string; // Mô tả

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CustomerGroupSchema = SchemaFactory.createForClass(CustomerGroup);

================
File: customer-group/services/customer-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CustomerGroup } from '../schemas/customer-group.schema';

@Injectable()
export class CustomerGroupService {
  constructor(
    @InjectModel('CustomerGroups') private customerGroupModel: Model<CustomerGroup>,
  ) { }

  async create(createCustomerGroupDto: any): Promise<CustomerGroup> {
    const lastCustomerGroup = await this.customerGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newCustomerGroupId = 'KHG0001';
  
    if (lastCustomerGroup && lastCustomerGroup.groupId) {
      const lastNumber = parseInt(lastCustomerGroup.groupId.replace('KHG', ''), 10);
      const nextNumber = lastNumber + 1;
      newCustomerGroupId = `KHG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCustomerGroup = new this.customerGroupModel({
      ...createCustomerGroupDto,
      groupId: newCustomerGroupId
    });
  
    return createdCustomerGroup.save();
  }

  async findAll(): Promise<CustomerGroup[]> {
    return this.customerGroupModel.find().exec();
  }

  async findOne(id: string): Promise<CustomerGroup> {
    const customerGroup = await this.customerGroupModel.findById(id).exec();
    if (!customerGroup) {
      throw new NotFoundException(`CustomerGroup with ID ${id} not found`);
    }
    return customerGroup;
  }

  async update(id: string, updateCustomerGroupDto: any): Promise<CustomerGroup> {
    const customerGroup = await this.customerGroupModel
      .findByIdAndUpdate(id, updateCustomerGroupDto, { new: true })
      .exec();
    if (!customerGroup) {
      throw new NotFoundException(`CustomerGroup with ID ${id} not found`);
    }
    return customerGroup;
  }

  async remove(id: string): Promise<CustomerGroup> {
    const customerGroup = await this.customerGroupModel.findByIdAndDelete(id).exec();
    if (!customerGroup) {
      throw new NotFoundException(`CustomerGroup with ID ${id} not found`);
    }
    return customerGroup;
  }
}

================
File: customer-loyalty-point/controllers/customer-loyalty-points.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerLoyaltyPointsService } from '../services/customer-loyalty-points.service';
import { CustomerLoyaltyPoints } from '../schemas/customer-loyalty-points.schema';

@Controller('api/customer-loyalty-points')
export class CustomerLoyaltyPointsController {
  constructor(private readonly customerLoyaltyPointsService: CustomerLoyaltyPointsService) { }

  @Post()
  create(@Body() customerLoyaltyPointsService: any) {
    return this.customerLoyaltyPointsService.create(customerLoyaltyPointsService);
  }

  @Get()
  findAll() {
    return this.customerLoyaltyPointsService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerLoyaltyPointsService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerLoyaltyPointsDto: any) {
    return this.customerLoyaltyPointsService.update(id, updateCustomerLoyaltyPointsDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerLoyaltyPointsService.remove(id);
  }
}

================
File: customer-loyalty-point/customer-loyalty.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerLoyaltyPointsSchema } from './schemas/customer-loyalty-points.schema';
import { CustomerLoyaltyPointsService } from './services/customer-loyalty-points.service';
import { CustomerLoyaltyPointsController } from './controllers/customer-loyalty-points.controller';
@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'CustomerLoyalty', schema: CustomerLoyaltyPointsSchema }])
  ],
  controllers: [CustomerLoyaltyPointsController],
  providers: [CustomerLoyaltyPointsService],
  exports: [CustomerLoyaltyPointsService]
})
export class CustomerLoyaltyPointsModule { }

================
File: customer-loyalty-point/dtos/customer-loyalty-point.dto.ts
================
// CustomerLoyaltyPointsDTO: Đại diện toàn bộ schema
export class CustomerLoyaltyPointsDTO {
  storeId: string; // Mã cửa hàng
  customerId: string; // Mã khách hàng
  programId: string; // Mã chương trình
  currentPoints: number; // Điểm hiện tại
  totalPointsEarned: number; // Tổng điểm kiếm được
  totalPointsRedeemed: number; // Tổng điểm đã đổi
  tier: string; // Cấp bậc
  pointsHistory: { type: string; points: number; orderId: string; rewardId: string; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

// CreateCustomerLoyaltyPointsDTO: Dùng để tạo mới
export class CreateCustomerLoyaltyPointsDTO {
  storeId: string; // Mã cửa hàng
  customerId: string; // Mã khách hàng
  programId: string; // Mã chương trình
  currentPoints: number; // Điểm hiện tại
  totalPointsEarned: number; // Tổng điểm kiếm được
  totalPointsRedeemed: number; // Tổng điểm đã đổi
  tier: string; // Cấp bậc
  pointsHistory: { type: string; points: number; orderId: string; rewardId: string; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

// UpdateCustomerLoyaltyPointsDTO: Dùng để cập nhật
export class UpdateCustomerLoyaltyPointsDTO {
  currentPoints?: number; // Điểm hiện tại
  totalPointsEarned?: number; // Tổng điểm kiếm được
  totalPointsRedeemed?: number; // Tổng điểm đã đổi
  tier?: string; // Cấp bậc
  pointsHistory?: { type: string; points: number; orderId: string; rewardId: string; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

================
File: customer-loyalty-point/schemas/customer-loyalty-points.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'CustomerLoyaltyPoints' })
export class CustomerLoyaltyPoints extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng

  @Prop({ type: Types.ObjectId, ref: 'LoyaltyPrograms', required: true })
  programId: Types.ObjectId; // Mã chương trình

  @Prop({ default: 0 })
  currentPoints: number; // Điểm hiện tại

  @Prop({ default: 0 })
  totalPointsEarned: number; // Tổng điểm kiếm được

  @Prop({ default: 0 })
  totalPointsRedeemed: number; // Tổng điểm đã đổi

  @Prop()
  tier: string; // Cấp bậc

  @Prop({ type: [{ type: String, points: Number, orderId: Types.ObjectId, rewardId: Types.ObjectId, description: String, expiryDate: Date, createdAt: Date }] })
  pointsHistory: { type: string; points: number; orderId: Types.ObjectId; rewardId: Types.ObjectId; description: string; expiryDate: Date; createdAt: Date }[]; // Lịch sử điểm
}

export const CustomerLoyaltyPointsSchema = SchemaFactory.createForClass(CustomerLoyaltyPoints);

================
File: customer-loyalty-point/services/customer-loyalty-points.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CustomerLoyaltyPoints } from './schemas/customer-loyalty-points.schema';

@Injectable()
export class CustomerLoyaltyPointsService {
  constructor(
    @InjectModel(CustomerLoyaltyPoints.name) private customerLoyaltyPointsModel: Model<CustomerLoyaltyPoints>,
  ) { }

  async create(createCustomerLoyaltyPointsDto: any): Promise<CustomerLoyaltyPoints> {
    const createdPoints = new this.customerLoyaltyPointsModel(createCustomerLoyaltyPointsDto);
    return createdPoints.save();
  }

  async findAll(): Promise<CustomerLoyaltyPoints[]> {
    return this.customerLoyaltyPointsModel
      .find()
      .populate('customer')
      .populate('program')
      .populate('transaction')
      .exec();
  }

  async findOne(id: string): Promise<CustomerLoyaltyPoints> {
    const points = await this.customerLoyaltyPointsModel
      .findById(id)
      .populate('customer')
      .populate('program')
      .populate('transaction')
      .exec();
    if (!points) {
      throw new NotFoundException(`Customer loyalty points with ID ${id} not found`);
    }
    return points;
  }

  async update(id: string, updateCustomerLoyaltyPointsDto: any): Promise<CustomerLoyaltyPoints> {
    const points = await this.customerLoyaltyPointsModel
      .findByIdAndUpdate(id, updateCustomerLoyaltyPointsDto, { new: true })
      .populate('customer')
      .populate('program')
      .populate('transaction')
      .exec();
    if (!points) {
      throw new NotFoundException(`Customer loyalty points with ID ${id} not found`);
    }
    return points;
  }

  async remove(id: string): Promise<CustomerLoyaltyPoints> {
    const points = await this.customerLoyaltyPointsModel.findByIdAndDelete(id).exec();
    if (!points) {
      throw new NotFoundException(`Customer loyalty points with ID ${id} not found`);
    }
    return points;
  }
}

================
File: customer/controllers/customer.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { CustomerService } from '../services/customer.service';
import { Customer } from '../schemas/customer.schema';

@Controller('api/customers')
export class CustomerController {
  constructor(private readonly customerService: CustomerService) { }

  @Post()
  create(@Body() createCustomerDto: any) {
    return this.customerService.create(createCustomerDto);
  }

  @Get()
  findAll() {
    return this.customerService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.customerService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateCustomerDto: any) {
    return this.customerService.update(id, updateCustomerDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.customerService.remove(id);
  }
}

================
File: customer/customer.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CustomerController } from './controllers/customer.controller';
import { CustomerService } from './services/customer.service';
import { Customer, CustomerSchema } from './schemas/customer.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Customers', schema: CustomerSchema }])
  ],
  controllers: [CustomerController],
  providers: [CustomerService],
  exports: [CustomerService]
})
export class CustomerModule { }

================
File: customer/dtos/customer.dto.ts
================
// CustomerDTO: Đại diện toàn bộ schema
export class CustomerDTO {
  customerId: string; // Mã khách hàng
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  customerType: string; // Loại khách hàng
  taxCode: string; // Mã số thuế
  idCard: string; // CMND/CCCD
  group: string; // Mã nhóm
  debt: number; // Nợ
  totalSales: number; // Tổng doanh số
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateCustomerDTO: Dùng để tạo mới
export class CreateCustomerDTO {
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  customerType: string; // Loại khách hàng
  taxCode: string; // Mã số thuế
  idCard: string; // CMND/CCCD
  group: string; // Mã nhóm
  status: string; // Trạng thái
}

// UpdateCustomerDTO: Dùng để cập nhật
export class UpdateCustomerDTO {
  name?: string; // Tên
  phone?: string; // Số điện thoại
  email?: string; // Email
  address?: string; // Địa chỉ
  customerType?: string; // Loại khách hàng
  taxCode?: string; // Mã số thuế
  idCard?: string; // CMND/CCCD
  group?: string; // Mã nhóm
  status?: string; // Trạng thái
}

================
File: customer/schemas/customer.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Customers' })
export class Customer extends Document {
  @Prop({ unique: true, required: true })
  customerId: string; // Mã khách hàng

  @Prop({ required: true })
  name: string; // Tên khách hàng

  @Prop()
  phone: string; // Số điện thoại

  @Prop()
  email: string; // Email

  @Prop()
  address: string; // Địa chỉ

  @Prop({ enum: ['individual', 'company'], required: true })
  customerType: string; // Loại khách hàng

  @Prop()
  taxCode: string; // Mã số thuế

  @Prop()
  idCard: string; // CMND/CCCD

  @Prop({ type: Types.ObjectId, ref: 'CustomerGroups' })
  group: Types.ObjectId; // Mã nhóm khách hàng

  @Prop({ default: 0 })
  debt: number; // Nợ hiện tại

  @Prop({ default: 0 })
  totalSales: number; // Tổng doanh số

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const CustomerSchema = SchemaFactory.createForClass(Customer);

================
File: customer/services/customer.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Customer } from '../schemas/customer.schema';

@Injectable()
export class CustomerService {
  constructor(
    @InjectModel('Customers') private customerModel: Model<Customer>,
  ) { }

  async create(createCustomerDto: any): Promise<Customer> {
    const lastCustomer = await this.customerModel.findOne().sort({ customerId: -1 }).exec();
    let newCustomerId = 'KH0001';
  
    if (lastCustomer && lastCustomer.customerId) {
      const lastNumber = parseInt(lastCustomer.customerId.replace('KH', ''), 10);
      const nextNumber = lastNumber + 1;
      newCustomerId = `KH${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdCustomer = new this.customerModel({
      ...createCustomerDto,
      customerId: newCustomerId
    });
  
    return createdCustomer.save();
  }

  async findAll(): Promise<Customer[]> {
    return this.customerModel.find().populate('group').exec();
  }

  async findOne(id: string): Promise<Customer> {
    const customer = await this.customerModel.findById(id).populate('group').exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }

  async update(id: string, updateCustomerDto: any): Promise<Customer> {
    const customer = await this.customerModel
      .findByIdAndUpdate(id, updateCustomerDto, { new: true })
      .populate('group')
      .exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }

  async remove(id: string): Promise<Customer> {
    const customer = await this.customerModel.findByIdAndDelete(id).exec();
    if (!customer) {
      throw new NotFoundException(`Customer with ID ${id} not found`);
    }
    return customer;
  }
}

================
File: department/controllers/department.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { DepartmentService } from '../services/department.service';
import { Department } from '../schemas/department.schema';

@Controller('api/departments')
export class DepartmentController {
  constructor(private readonly departmentService: DepartmentService) { }

  @Post()
  async create(@Body() createDepartmentDto: any): Promise<Department> {
    return this.departmentService.create(createDepartmentDto);
  }

  @Get()
  findAll() {
    return this.departmentService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.departmentService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateBrandDto: any) {
    return this.departmentService.update(id, updateBrandDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.departmentService.remove(id);
  }
}

================
File: department/department.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Department, DepartmentSchema } from './schemas/department.schema';
import { DepartmentController } from './controllers/department.controller';
import { DepartmentService } from './services/department.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Departments', schema: DepartmentSchema }])
  ],
  controllers: [DepartmentController],
  providers: [DepartmentService],
  exports: [DepartmentService]
})
export class DepartmentModule { }

================
File: department/dtos/department.dto.ts
================
// DepartmentDTO: Đại diện toàn bộ schema
export class DepartmentDTO {
  departmentId: string; // Mã phòng ban
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateDepartmentDTO: Dùng để tạo mới
export class CreateDepartmentDTO {
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
}

// UpdateDepartmentDTO: Dùng để cập nhật
export class UpdateDepartmentDTO {
  name?: string; // Tên
  description?: string; // Mô tả
  status?: string; // Trạng thái
}

================
File: department/schemas/department.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Departments' })
export class Department extends Document {
  @Prop({ unique: true, required: true })
  departmentId: string; // Mã phòng ban

  @Prop({ required: true })
  name: string; // Tên phòng ban

  @Prop()
  description: string; // Mô tả

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const DepartmentSchema = SchemaFactory.createForClass(Department);

================
File: department/services/department.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Department } from '../schemas/department.schema';

@Injectable()
export class DepartmentService {
  constructor(
    @InjectModel('Departments') private departmentModel: Model<Department>,
  ) { }

  async create(createDepartmentDto: any): Promise<Department> {
    const lastDepartment = await this.departmentModel.findOne().sort({ departmentId: -1 }).exec();
    let newDepartmentId = 'DV0001';
  
    if (lastDepartment && lastDepartment.departmentId) {
      const lastNumber = parseInt(lastDepartment.departmentId.replace('DV', ''), 10);
      const nextNumber = lastNumber + 1;
      newDepartmentId = `DV${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdDepartment = new this.departmentModel({
      ...createDepartmentDto,
      departmentId: newDepartmentId
    });
  
    return createdDepartment.save();
  }

  async findAll(): Promise<Department[]> {
    return this.departmentModel.find().exec();
  }

  async findOne(id: string): Promise<Department> {
    const department = await this.departmentModel.findById(id).exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }

  async update(id: string, updateDepartmentDto: any): Promise<Department> {
    const department = await this.departmentModel
      .findByIdAndUpdate(id, updateDepartmentDto, { new: true })
      .exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }

  async remove(id: string): Promise<Department> {
    const department = await this.departmentModel.findByIdAndDelete(id).exec();
    if (!department) {
      throw new NotFoundException(`Department with ID ${id} not found`);
    }
    return department;
  }
}

================
File: destruction/dtos/destruction.dto.ts
================
// DestructionDTO: Đại diện toàn bộ schema
export class DestructionDTO {
  destructionId: string; // Mã hủy hàng
  destructionCode: string; // Mã hiển thị
  products: { productId: string; quantity: number }[]; // Sản phẩm hủy
  totalValue: number; // Tổng giá trị
  status: string; // Trạng thái
}

// CreateDestructionDTO: Dùng để tạo mới
export class CreateDestructionDTO {
  destructionCode: string; // Mã hiển thị
  products: { productId: string; quantity: number }[]; // Sản phẩm hủy
  totalValue: number; // Tổng giá trị
  status: string; // Trạng thái
}

// UpdateDestructionDTO: Dùng để cập nhật
export class UpdateDestructionDTO {
  destructionCode?: string; // Mã hiển thị
  products?: { productId: string; quantity: number }[]; // Sản phẩm hủy
  totalValue?: number; // Tổng giá trị
  status?: string; // Trạng thái
}

================
File: destruction/schemas/destructions.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Destructions' })
export class Destruction extends Document {
  @Prop({ unique: true, required: true })
  destructionId: string; // Mã hủy hàng

  @Prop()
  destructionCode: string; // Mã hủy hàng hiển thị

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  products: { productId: Types.ObjectId; quantity: number }[]; // Danh sách sản phẩm hủy

  @Prop()
  totalValue: number; // Tổng giá trị

  @Prop({ enum: ['draft', 'completed', 'cancelled'], default: 'draft' })
  status: string; // Trạng thái
}

export const DestructionSchema = SchemaFactory.createForClass(Destruction);

================
File: employee/controllers/employee.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { EmployeeService } from '../services/employee.service';
import { Employee } from '../schemas/employee.schema';

@Controller('api/employees')
export class EmployeeController {
  constructor(private readonly employeeService: EmployeeService) { }

  @Post()
  create(@Body() createEmployeeDto: any) {
    return this.employeeService.create(createEmployeeDto);
  }

  @Get()
  findAll() {
    return this.employeeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.employeeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateEmployeeDto: any) {
    return this.employeeService.update(id, updateEmployeeDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.employeeService.remove(id);
  }
}

================
File: employee/dtos/employee.dto.ts
================
// EmployeeDTO: Đại diện toàn bộ schema
export class EmployeeDTO {
  employeeId: string; // Mã nhân viên
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  branchSalary: string; // Mã chi nhánh tính lương
  branchWork: string; // Mã chi nhánh làm việc
  startDate: Date; // Ngày bắt đầu
  position: string; // Mã vị trí
  department: string; // Mã phòng ban
  userAccount: string; // Mã tài khoản
  idCard: string; // CMND/CCCD
  dob: Date; // Ngày sinh
  gender: string; // Giới tính
  salaryType: string; // Loại lương
  salaryDetails: {
    shiftRate: number;
    hourlyRate: number;
    dailyRate: number;
    fixedRate: number;
  }; // Chi tiết lương
  bonus: { type: string; form: string; value: number }[]; // Thưởng
  commission: number; // Hoa hồng
  commissionTable: string; // Mã bảng hoa hồng
  allowance: { name: string; type: string; value: number; valueType: string }[]; // Phụ cấp
  deduction: { name: string; type: string; condition: string; value: number }[]; // Khấu trừ
  status: string; // Trạng thái
}

// CreateEmployeeDTO: Dùng để tạo mới
export class CreateEmployeeDTO {
  name: string; // Tên
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  branchSalary: string; // Mã chi nhánh tính lương
  branchWork: string; // Mã chi nhánh làm việc
  startDate: Date; // Ngày bắt đầu
  position: string; // Mã vị trí
  department: string; // Mã phòng ban
  userAccount: string; // Mã tài khoản
  idCard: string; // CMND/CCCD
  dob: Date; // Ngày sinh
  gender: string; // Giới tính
  salaryType: string; // Loại lương
  salaryDetails: {
    shiftRate: number;
    hourlyRate: number;
    dailyRate: number;
    fixedRate: number;
  }; // Chi tiết lương
  bonus: { type: string; form: string; value: number }[]; // Thưởng
  commission: number; // Hoa hồng
  commissionTable: string; // Mã bảng hoa hồng
  allowance: { name: string; type: string; value: number; valueType: string }[]; // Phụ cấp
  deduction: { name: string; type: string; condition: string; value: number }[]; // Khấu trừ
  status: string; // Trạng thái
}

// UpdateEmployeeDTO: Dùng để cập nhật
export class UpdateEmployeeDTO {
  name?: string; // Tên
  phone?: string; // Số điện thoại
  email?: string; // Email
  address?: string; // Địa chỉ
  branchSalary?: string; // Mã chi nhánh tính lương
  branchWork?: string; // Mã chi nhánh làm việc
  startDate?: Date; // Ngày bắt đầu
  position?: string; // Mã vị trí
  department?: string; // Mã phòng ban
  userAccount?: string; // Mã tài khoản
  idCard?: string; // CMND/CCCD
  dob?: Date; // Ngày sinh
  gender?: string; // Giới tính
  salaryType?: string; // Loại lương
  salaryDetails?: {
    shiftRate?: number;
    hourlyRate?: number;
    dailyRate?: number;
    fixedRate?: number;
  }; // Chi tiết lương
  bonus?: { type: string; form: string; value: number }[]; // Thưởng
  commission?: number; // Hoa hồng
  commissionTable?: string; // Mã bảng hoa hồng
  allowance?: { name: string; type: string; value: number; valueType: string }[]; // Phụ cấp
  deduction?: { name: string; type: string; condition: string; value: number }[]; // Khấu trừ
  status?: string; // Trạng thái
}

================
File: employee/employee.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { EmployeeController } from './controllers/employee.controller';
import { EmployeeService } from './services/employee.service';
import { Employee, EmployeeSchema } from './schemas/employee.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Employees', schema: EmployeeSchema }
    ]),
  ],
  controllers: [EmployeeController],
  providers: [EmployeeService],
  exports: [EmployeeService],
})
export class EmployeeModule { }

================
File: employee/schemas/employee.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
@Schema({ collection: 'Employees' })
export class Employee extends Document {
  @Prop({ unique: true, required: true })
  employeeId: string; // Mã nhân viên

  @Prop({ required: true })
  name: string; // Tên nhân viên

  @Prop({ required: true })
  phone: string; // Số điện thoại

  @Prop({ type: Types.ObjectId, ref: 'Stores' })
  storeId: Types.ObjectId; // Chi nhánh làm việc

  @Prop({ type: Types.ObjectId, ref: 'Stores' })
  payrollStoreId: Types.ObjectId; // Chi nhánh trả lương

  @Prop({ type: Types.ObjectId, ref: 'Departments' })
  departmentId: Types.ObjectId; // Mã phòng ban

  @Prop({ type: Types.ObjectId, ref: 'Positions' })
  positionId: Types.ObjectId; // Mã chức danh

  @Prop()
  startDate: Date; // Ngày bắt đầu làm việc

  @Prop({
    type: {
      gender: String,
      dateOfBirth: Date,
      idNumber: String,
    },
  })
  personalInfo: {
    gender: string; // Giới tính
    dateOfBirth: Date; // Ngày sinh
    idNumber: string; // CMND/CCCD
  }; // Thông tin cá nhân

  @Prop({
    type: {
      address: String,
      email: String,
      facebook: String,
    },
  })
  contactInfo: {
    address: string; // Địa chỉ
    email: string; // Email
    facebook: string; // Facebook
  }; // Thông tin liên hệ

  @Prop({
    type: {
      salaryType: String,
      baseSalary: Number,
      shiftRate: Number,
      hourlyRate: Number,
      dailyRate: Number,
      overtimeRate: Number,
    },
  })
  salarySettings: {
    salaryType: string; // Loại lương: 'shift', 'hourly', 'daily', 'fixed'
    baseSalary: number; // Lương cơ bản (nếu cố định)
    shiftRate: number; // Lương theo ca
    hourlyRate: number; // Lương theo giờ
    dailyRate: number; // Lương theo ngày công
    overtimeRate: number; // Tỷ lệ làm thêm giờ
  }; // Thiết lập lương

  @Prop({
    type: {
      bonusType: String,
      bonusRate: Number,
      bonusScope: String,
    },
  })
  bonusSettings: {
    bonusType: string; // Loại thưởng: 'revenue', 'branchProfit', 'totalProfit'
    bonusRate: number; // Tỷ lệ thưởng
    bonusScope: string; // Phạm vi: 'personal', 'branch', 'system'
  }; // Thiết lập thưởng

  @Prop({
    type: {
      commissionRate: Number,
    },
  })
  commissionSettings: {
    commissionRate: number; // Tỷ lệ hoa hồng
  }; // Thiết lập hoa hồng

  @Prop({ type: [{ name: String, amount: Number, type: String }] })
  allowanceSettings: { name: string; amount: number; type: string }[]; // Phụ cấp

  @Prop({ type: [{ name: String, amount: Number, condition: String }] })
  deductionSettings: { name: string; amount: number; condition: string }[]; // Giảm trừ

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  notes: string; // Ghi chú

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}
export const EmployeeSchema = SchemaFactory.createForClass(Employee);

================
File: employee/services/employee.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Employee } from '../schemas/employee.schema';

@Injectable()
export class EmployeeService {
  constructor(
    @InjectModel('Employees') private employeeModel: Model<Employee>,
  ) { }

  async create(createEmployeeDto: any): Promise<Employee> {
    const lastEmployee = await this.employeeModel.findOne().sort({ employeeId: -1 }).exec();
    let newEmployeeId = 'NV0001';
  
    if (lastEmployee && lastEmployee.employeeId) {
      const lastNumber = parseInt(lastEmployee.employeeId.replace('NV', ''), 10);
      const nextNumber = lastNumber + 1;
      newEmployeeId = `NV${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdEmployee = new this.employeeModel({
      ...createEmployeeDto,
      employeeId: newEmployeeId
    });
  
    return createdEmployee.save();
  }

  async findAll(): Promise<Employee[]> {
    return this.employeeModel
      .find()
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
  }

  async findOne(id: string): Promise<Employee> {
    const employee = await this.employeeModel
      .findById(id)
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }

  async update(id: string, updateEmployeeDto: any): Promise<Employee> {
    const employee = await this.employeeModel
      .findByIdAndUpdate(id, updateEmployeeDto, { new: true })
      .populate('branchSalary')
      .populate('branchWork')
      .populate('position')
      .populate('department')
      .populate('userAccount')
      .populate('commissionTable')
      .exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }

  async remove(id: string): Promise<Employee> {
    const employee = await this.employeeModel.findByIdAndDelete(id).exec();
    if (!employee) {
      throw new NotFoundException(`Employee with ID ${id} not found`);
    }
    return employee;
  }
}

================
File: holiday/controllers/holiday.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { HolidayService } from '../services/holiday.service';
import { Holiday } from '../schemas/holiday.schema';

@Controller('api/holidays')
export class HolidayController {
  constructor(private readonly holidayService: HolidayService) { }

  @Post()
  async create(@Body() createHolidayDto: any): Promise<Holiday> {
    return this.holidayService.create(createHolidayDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<Holiday[]> {
    return this.holidayService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Holiday> {
    return this.holidayService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateHolidayDto: any,
  ): Promise<Holiday> {
    return this.holidayService.update(id, updateHolidayDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Holiday> {
    return this.holidayService.remove(id);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<Holiday[]> {
    return this.holidayService.findByStore(storeId);
  }

  @Get('date/:date')
  async findByDate(@Param('date') date: string): Promise<Holiday[]> {
    return this.holidayService.findByDate(date);
  }

  @Get('month/:year/:month')
  async findByMonth(
    @Param('year') year: number,
    @Param('month') month: number,
  ): Promise<Holiday[]> {
    return this.holidayService.findByMonth(year, month);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<Holiday> {
    return this.holidayService.updateStatus(id, status);
  }
}

================
File: holiday/dtos/holiday.dto.ts
================
// HolidayDTO: Đại diện toàn bộ schema
export class HolidayDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên ngày lễ
  type: string; // Loại
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  duration: number; // Thời gian
  description: string; // Mô tả
  isRecurring: boolean; // Lặp lại
  recurringPattern: {
    frequency: string; // Tần suất
    interval: number; // Khoảng cách
    endAfter: Date; // Kết thúc sau
  };
  status: string; // Trạng thái
}

// CreateHolidayDTO: Dùng để tạo mới
export class CreateHolidayDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên ngày lễ
  type: string; // Loại
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  duration: number; // Thời gian
  description: string; // Mô tả
  isRecurring: boolean; // Lặp lại
  recurringPattern: {
    frequency: string; // Tần suất
    interval: number; // Khoảng cách
    endAfter: Date; // Kết thúc sau
  };
  status: string; // Trạng thái
}

// UpdateHolidayDTO: Dùng để cập nhật
export class UpdateHolidayDTO {
  name?: string; // Tên ngày lễ
  type?: string; // Loại
  startDate?: Date; // Ngày bắt đầu
  endDate?: Date; // Ngày kết thúc
  duration?: number; // Thời gian
  description?: string; // Mô tả
  isRecurring?: boolean; // Lặp lại
  recurringPattern?: {
    frequency?: string; // Tần suất
    interval?: number; // Khoảng cách
    endAfter?: Date; // Kết thúc sau
  };
  status?: string; // Trạng thái
}

================
File: holiday/holiday.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Holiday, HolidaySchema } from './schemas/holiday.schema';
import { HolidayController } from './controllers/holiday.controller';
import { HolidayService } from './services/holiday.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Holidays', schema: HolidaySchema }])
  ],
  controllers: [HolidayController],
  providers: [HolidayService],
  exports: [HolidayService]
})
export class HolidayModule { }

================
File: holiday/schemas/holiday.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Holidays' })
export class Holiday extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên ngày lễ

  @Prop({ enum: ['holiday', 'special', 'company'], required: true })
  type: string; // Loại ngày lễ

  @Prop({ required: true })
  startDate: Date; // Ngày bắt đầu

  @Prop({ required: true })
  endDate: Date; // Ngày kết thúc

  @Prop()
  duration: number; // Thời gian (ngày)

  @Prop()
  description: string; // Mô tả

  @Prop({ default: false })
  isRecurring: boolean; // Lặp lại hàng năm

  @Prop({ type: { frequency: String, interval: Number, endAfter: Date } })
  recurringPattern: {
    frequency: string; // Tần suất lặp
    interval: number; // Khoảng cách
    endAfter: Date; // Kết thúc sau
  };

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái
}

export const HolidaySchema = SchemaFactory.createForClass(Holiday);

================
File: holiday/services/holiday.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Holiday } from '../schemas/holiday.schema';

@Injectable()
export class HolidayService {
  constructor(
    @InjectModel('Holidays')
    private holidayModel: Model<Holiday>,
  ) { }

  async create(createHolidayDto: any): Promise<Holiday> {
    const created = new this.holidayModel(createHolidayDto);
    return created.save();
  }

  async findAll(query: any = {}): Promise<Holiday[]> {
    return this.holidayModel.find(query).exec();
  }

  async findOne(id: string): Promise<Holiday> {
    const holiday = await this.holidayModel.findById(id).exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async update(id: string, updateHolidayDto: any): Promise<Holiday> {
    const holiday = await this.holidayModel
      .findByIdAndUpdate(id, updateHolidayDto, { new: true })
      .exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async remove(id: string): Promise<Holiday> {
    const holiday = await this.holidayModel.findByIdAndDelete(id).exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }

  async findByStore(storeId: string): Promise<Holiday[]> {
    return this.holidayModel.find({ storeId }).exec();
  }

  async findByDate(date: string): Promise<Holiday[]> {
    const startDate = new Date(date);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(date);
    endDate.setHours(23, 59, 59, 999);

    return this.holidayModel.find({
      date: {
        $gte: startDate,
        $lte: endDate,
      },
    }).exec();
  }

  async findByMonth(year: number, month: number): Promise<Holiday[]> {
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0);

    return this.holidayModel.find({
      date: {
        $gte: startDate,
        $lte: endDate,
      },
    }).exec();
  }

  async updateStatus(id: string, status: string): Promise<Holiday> {
    const holiday = await this.holidayModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!holiday) {
      throw new NotFoundException(`Holiday with ID ${id} not found`);
    }
    return holiday;
  }
}

================
File: inventory-check/controllers/inventory-check.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete } from '@nestjs/common';
import { InventoryCheckService } from '../services/inventory-check.service';
import { InventoryCheck } from './inventory-check.schema';

@Controller('inventory-checks')
export class InventoryCheckController {
  constructor(private readonly inventoryCheckService: InventoryCheckService) { }

  @Post()
  async create(@Body() createInventoryCheckDto: any): Promise<InventoryCheck> {
    return this.inventoryCheckService.create(createInventoryCheckDto);
  }

  @Get()
  async findAll(): Promise<InventoryCheck[]> {
    return this.inventoryCheckService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<InventoryCheck> {
    return this.inventoryCheckService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateInventoryCheckDto: any,
  ): Promise<InventoryCheck> {
    return this.inventoryCheckService.update(id, updateInventoryCheckDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<InventoryCheck> {
    return this.inventoryCheckService.remove(id);
  }

  @Put(':id/approve')
  async approve(@Param('id') id: string): Promise<InventoryCheck> {
    const updateDto = { status: 'approved' };
    return this.inventoryCheckService.update(id, updateDto);
  }

  @Put(':id/reject')
  async reject(@Param('id') id: string): Promise<InventoryCheck> {
    const updateDto = { status: 'rejected' };
    return this.inventoryCheckService.update(id, updateDto);
  }
}

================
File: inventory-check/dtos/inventory-check.dto.ts
================
// InventoryCheckDTO: Đại diện toàn bộ schema
export class InventoryCheckDTO {
  checkId: string; // Mã kiểm kê
  storeId: string; // Mã cửa hàng
  warehouseId: string; // Mã kho
  checkDate: Date; // Ngày kiểm kê
  type: string; // Loại kiểm kê
  status: string; // Trạng thái
  items: { productId: string; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết
  totalItems: number; // Tổng sản phẩm
  totalValue: number; // Tổng giá trị
  totalDifference: number; // Tổng chênh lệch
  checkedBy: string; // Mã nhân viên kiểm kê
  verifiedBy: string; // Mã nhân viên xác nhận
  attachments: string[]; // Tệp đính kèm
  notes: string; // Ghi chú
}

// CreateInventoryCheckDTO: Dùng để tạo mới
export class CreateInventoryCheckDTO {
  storeId: string; // Mã cửa hàng
  warehouseId: string; // Mã kho
  checkDate: Date; // Ngày kiểm kê
  type: string; // Loại kiểm kê
  status: string; // Trạng thái
  items: { productId: string; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết
  totalItems: number; // Tổng sản phẩm
  totalValue: number; // Tổng giá trị
  totalDifference: number; // Tổng chênh lệch
  checkedBy: string; // Mã nhân viên kiểm kê
  verifiedBy: string; // Mã nhân viên xác nhận
  attachments: string[]; // Tệp đính kèm
  notes: string; // Ghi chú
}

// UpdateInventoryCheckDTO: Dùng để cập nhật
export class UpdateInventoryCheckDTO {
  checkDate?: Date; // Ngày kiểm kê
  type?: string; // Loại kiểm kê
  status?: string; // Trạng thái
  items?: { productId: string; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết
  totalItems?: number; // Tổng sản phẩm
  totalValue?: number; // Tổng giá trị
  totalDifference?: number; // Tổng chênh lệch
  checkedBy?: string; // Mã nhân viên kiểm kê
  verifiedBy?: string; // Mã nhân viên xác nhận
  attachments?: string[]; // Tệp đính kèm
  notes?: string; // Ghi chú
}

================
File: inventory-check/schemas/inventory-check.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'InventoryChecks' })
export class InventoryCheck extends Document {
  @Prop({ unique: true, required: true })
  checkId: string; // Mã kiểm kê

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  warehouseId: Types.ObjectId; // Mã kho

  @Prop({ required: true })
  checkDate: Date; // Ngày kiểm kê

  @Prop({ enum: ['periodic', 'spot', 'request'], required: true })
  type: string; // Loại kiểm kê

  @Prop({ enum: ['draft', 'in_progress', 'completed', 'cancelled'], default: 'draft' })
  status: string; // Trạng thái

  @Prop({ type: [{ productId: Types.ObjectId, systemQuantity: Number, actualQuantity: Number, difference: Number, unitPrice: Number, totalValue: Number, notes: String }] })
  items: { productId: Types.ObjectId; systemQuantity: number; actualQuantity: number; difference: number; unitPrice: number; totalValue: number; notes: string }[]; // Chi tiết kiểm kê

  @Prop({ default: 0 })
  totalItems: number; // Tổng số sản phẩm

  @Prop({ default: 0 })
  totalValue: number; // Tổng giá trị

  @Prop({ default: 0 })
  totalDifference: number; // Tổng chênh lệch

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  checkedBy: Types.ObjectId; // Mã nhân viên kiểm kê

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  verifiedBy: Types.ObjectId; // Mã nhân viên xác nhận

  @Prop([String])
  attachments: string[]; // Tệp đính kèm

  @Prop()
  notes: string; // Ghi chú
}

export const InventoryCheckSchema = SchemaFactory.createForClass(InventoryCheck);

================
File: inventory-check/services/inventory-check.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { InventoryCheck } from './schemas/inventory-check.schema';

@Injectable()
export class InventoryCheckService {
  constructor(
    @InjectModel(InventoryCheck.name) private inventoryCheckModel: Model<InventoryCheck>,
  ) { }

  async create(createInventoryCheckDto: any): Promise<InventoryCheck> {
    const createdCheck = new this.inventoryCheckModel(createInventoryCheckDto);
    return createdCheck.save();
  }

  async findAll(): Promise<InventoryCheck[]> {
    return this.inventoryCheckModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('approvedBy')
      .exec();
  }

  async findOne(id: string): Promise<InventoryCheck> {
    const check = await this.inventoryCheckModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('approvedBy')
      .exec();
    if (!check) {
      throw new NotFoundException(`Inventory check with ID ${id} not found`);
    }
    return check;
  }

  async update(id: string, updateInventoryCheckDto: any): Promise<InventoryCheck> {
    const check = await this.inventoryCheckModel
      .findByIdAndUpdate(id, updateInventoryCheckDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('approvedBy')
      .exec();
    if (!check) {
      throw new NotFoundException(`Inventory check with ID ${id} not found`);
    }
    return check;
  }

  async remove(id: string): Promise<InventoryCheck> {
    const check = await this.inventoryCheckModel.findByIdAndDelete(id).exec();
    if (!check) {
      throw new NotFoundException(`Inventory check with ID ${id} not found`);
    }
    return check;
  }
}

================
File: invoice/controllers/invoice.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { InvoiceService } from '../services/invoice.service';
import { Invoice } from '../schemas/invoice.schema';

@Controller('api/invoices')
export class InvoiceController {
  constructor(private readonly invoiceService: InvoiceService) { }

  @Post()
  create(@Body() createInvoiceDto: any) {
    return this.invoiceService.create(createInvoiceDto);
  }

  @Get()
  findAll() {
    return this.invoiceService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.invoiceService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateInvoiceDto: any) {
    return this.invoiceService.update(id, updateInvoiceDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.invoiceService.remove(id);
  }
}

================
File: invoice/dtos/invoice.dto.ts
================
// InvoiceDTO: Đại diện toàn bộ schema
export class InvoiceDTO {
  invoiceId: string; // Mã hóa đơn
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  invoiceNumber: string; // Số hóa đơn
  invoiceDate: Date; // Ngày hóa đơn
  dueDate: Date; // Ngày đến hạn
  items: { productId: string; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết
  subtotal: number; // Tạm tính
  tax: number; // Thuế
  shipping: number; // Phí vận chuyển
  total: number; // Tổng cộng
  paymentMethod: string; // Phương thức thanh toán
  paymentStatus: string; // Trạng thái thanh toán
  notes: string; // Ghi chú
  status: string; // Trạng thái
}

// CreateInvoiceDTO: Dùng để tạo mới
export class CreateInvoiceDTO {
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  invoiceNumber: string; // Số hóa đơn
  invoiceDate: Date; // Ngày hóa đơn
  dueDate: Date; // Ngày đến hạn
  items: { productId: string; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết
  subtotal: number; // Tạm tính
  tax: number; // Thuế
  shipping: number; // Phí vận chuyển
  total: number; // Tổng cộng
  paymentMethod: string; // Phương thức thanh toán
  paymentStatus: string; // Trạng thái thanh toán
  notes: string; // Ghi chú
  status: string; // Trạng thái
}

// UpdateInvoiceDTO: Dùng để cập nhật
export class UpdateInvoiceDTO {
  invoiceNumber?: string; // Số hóa đơn
  invoiceDate?: Date; // Ngày hóa đơn
  dueDate?: Date; // Ngày đến hạn
  items?: { productId: string; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết
  subtotal?: number; // Tạm tính
  tax?: number; // Thuế
  shipping?: number; // Phí vận chuyển
  total?: number; // Tổng cộng
  paymentMethod?: string; // Phương thức thanh toán
  paymentStatus?: string; // Trạng thái thanh toán
  notes?: string; // Ghi chú
  status?: string; // Trạng thái
}

================
File: invoice/invoice.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { InvoiceController } from './controllers/invoice.controller';
import { InvoiceService } from './services/invoice.service';
import { Invoice, InvoiceSchema } from './schemas/invoice.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Invoices', schema: InvoiceSchema }])
  ],
  controllers: [InvoiceController],
  providers: [InvoiceService],
  exports: [InvoiceService]
})
export class InvoiceModule { }

================
File: invoice/schemas/invoice.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Invoices' })
export class Invoice extends Document {
  @Prop({ unique: true, required: true })
  invoiceId: string; // Mã hóa đơn

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId; // Mã đơn hàng

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng

  @Prop({ required: true })
  invoiceNumber: string; // Số hóa đơn

  @Prop({ required: true, default: Date.now })
  invoiceDate: Date; // Ngày hóa đơn

  @Prop()
  dueDate: Date; // Ngày đến hạn

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number, unitPrice: Number, discount: Number, total: Number }] })
  items: { productId: Types.ObjectId; quantity: number; unitPrice: number; discount: number; total: number }[]; // Chi tiết hóa đơn

  @Prop({ required: true })
  subtotal: number; // Tạm tính

  @Prop({ default: 0 })
  tax: number; // Thuế

  @Prop({ default: 0 })
  shipping: number; // Phí vận chuyển

  @Prop({ required: true })
  total: number; // Tổng cộng

  @Prop({ enum: ['cash', 'bank_transfer', 'credit_card', 'wallet'], required: true })
  paymentMethod: string; // Phương thức thanh toán

  @Prop({ enum: ['unpaid', 'partial', 'paid', 'cancelled'], default: 'unpaid' })
  paymentStatus: string; // Trạng thái thanh toán

  @Prop()
  notes: string; // Ghi chú

  @Prop({ enum: ['draft', 'issued', 'cancelled', 'void'], default: 'draft' })
  status: string; // Trạng thái hóa đơn
}

export const InvoiceSchema = SchemaFactory.createForClass(Invoice);

================
File: invoice/services/invoice.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Invoice } from '../schemas/invoice.schema';

@Injectable()
export class InvoiceService {
  constructor(
    @InjectModel('Invoices') private invoiceModel: Model<Invoice>,
  ) { }

  async create(createInvoiceDto: any): Promise<Invoice> {
    const lastInvoice = await this.invoiceModel.findOne().sort({ invoiceId: -1 }).exec();
    let newInvoiceId = 'HD0001';
  
    if (lastInvoice && lastInvoice.invoiceId) {
      const lastNumber = parseInt(lastInvoice.invoiceId.replace('HD', ''), 10);
      const nextNumber = lastNumber + 1;
      newInvoiceId = `HD${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdInvoice = new this.invoiceModel({
      ...createInvoiceDto,
      invoiceId: newInvoiceId
    });
  
    return createdInvoice.save();
  }

  async findAll(): Promise<Invoice[]> {
    return this.invoiceModel
      .find()
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
  }

  async findOne(id: string): Promise<Invoice> {
    const invoice = await this.invoiceModel
      .findById(id)
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }

  async update(id: string, updateInvoiceDto: any): Promise<Invoice> {
    const invoice = await this.invoiceModel
      .findByIdAndUpdate(id, updateInvoiceDto, { new: true })
      .populate('storeId')
      .populate('orderId')
      .populate('customerId')
      .populate('items.productId')
      .exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }

  async remove(id: string): Promise<Invoice> {
    const invoice = await this.invoiceModel.findByIdAndDelete(id).exec();
    if (!invoice) {
      throw new NotFoundException(`Invoice with ID ${id} not found`);
    }
    return invoice;
  }
}

================
File: livestream/dtos/livestream.dto.ts
================
// LiveStreamDTO: Đại diện toàn bộ schema
export class LiveStreamDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  title: string; // Tiêu đề
  description: string; // Mô tả
  thumbnail: string; // Ảnh đại diện
  scheduledStartTime: Date; // Thời gian bắt đầu dự kiến
  actualStartTime: Date; // Thời gian bắt đầu thực tế
  endTime: Date; // Thời gian kết thúc
  duration: number; // Thời lượng
  status: string; // Trạng thái
  products: { productId: string; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm
  promotions: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi
  engagement: {
    viewers: number;
    likes: number;
    comments: number;
    shares: number;
    peakViewers: number;
  }; // Tương tác
  sales: {
    orders: number;
    totalRevenue: number;
    averageOrderValue: number;
  }; // Doanh số
  comments: { userId: string; userName: string; content: string; timestamp: Date; isPinned: boolean }[]; // Bình luận
  recording: {
    url: string;
    duration: number;
    size: number;
    format: string;
  }; // Bản ghi
  analytics: {
    viewerRetention: number;
    engagementRate: number;
    conversionRate: number;
    topProducts: { productId: string; sales: number; revenue: number }[];
  }; // Phân tích
}

// CreateLiveStreamDTO: Dùng để tạo mới
export class CreateLiveStreamDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  title: string; // Tiêu đề
  description: string; // Mô tả
  thumbnail: string; // Ảnh đại diện
  scheduledStartTime: Date; // Thời gian bắt đầu dự kiến
  status: string; // Trạng thái
  products: { productId: string; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm
  promotions: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi
}

// UpdateLiveStreamDTO: Dùng để cập nhật
export class UpdateLiveStreamDTO {
  title?: string; // Tiêu đề
  description?: string; // Mô tả
  thumbnail?: string; // Ảnh đại diện
  scheduledStartTime?: Date; // Thời gian bắt đầu dự kiến
  actualStartTime?: Date; // Thời gian bắt đầu thực tế
  endTime?: Date; // Thời gian kết thúc
  duration?: number; // Thời lượng
  status?: string; // Trạng thái
  products?: { productId: string; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm
  promotions?: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi
  engagement?: {
    viewers?: number;
    likes?: number;
    comments?: number;
    shares?: number;
    peakViewers?: number;
  }; // Tương tác
  sales?: {
    orders?: number;
    totalRevenue?: number;
    averageOrderValue?: number;
  }; // Doanh số
  comments?: { userId: string; userName: string; content: string; timestamp: Date; isPinned: boolean }[]; // Bình luận
  recording?: {
    url?: string;
    duration?: number;
    size?: number;
    format?: string;
  }; // Bản ghi
  analytics?: {
    viewerRetention?: number;
    engagementRate?: number;
    conversionRate?: number;
    topProducts?: { productId: string; sales: number; revenue: number }[];
  }; // Phân tích
}

================
File: livestream/schemas/livestream.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'LiveStreams' })
export class LiveStream extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels', required: true })
  channelId: Types.ObjectId; // Mã kênh bán hàng

  @Prop({ required: true })
  title: string; // Tiêu đề livestream

  @Prop()
  description: string; // Mô tả

  @Prop()
  thumbnail: string; // Ảnh đại diện

  @Prop({ required: true })
  scheduledStartTime: Date; // Thời gian bắt đầu dự kiến

  @Prop()
  actualStartTime: Date; // Thời gian bắt đầu thực tế

  @Prop()
  endTime: Date; // Thời gian kết thúc

  @Prop()
  duration: number; // Thời lượng (phút)

  @Prop({ enum: ['scheduled', 'live', 'ended', 'cancelled'], default: 'scheduled' })
  status: string; // Trạng thái

  @Prop({ type: [{ productId: Types.ObjectId, name: String, price: Number, discount: Number, stock: Number, order: Number }] })
  products: { productId: Types.ObjectId; name: string; price: number; discount: number; stock: number; order: number }[]; // Sản phẩm trong livestream

  @Prop({ type: [{ type: String, value: Number, description: String, startTime: Date, endTime: Date }] })
  promotions: { type: string; value: number; description: string; startTime: Date; endTime: Date }[]; // Khuyến mãi

  @Prop({ type: { viewers: Number, likes: Number, comments: Number, shares: Number, peakViewers: Number } })
  engagement: {
    viewers: number; // Số người xem
    likes: number; // Lượt thích
    comments: number; // Bình luận
    shares: number; // Chia sẻ
    peakViewers: number; // Số người xem cao nhất
  };

  @Prop({ type: { orders: Number, totalRevenue: Number, averageOrderValue: Number } })
  sales: {
    orders: number; // Số đơn hàng
    totalRevenue: number; // Doanh thu
    averageOrderValue: number; // Giá trị trung bình đơn hàng
  };

  @Prop({ type: [{ userId: String, userName: String, content: String, timestamp: Date, isPinned: Boolean }] })
  comments: { userId: string; userName: string; content: string; timestamp: Date; isPinned: boolean }[]; // Bình luận

  @Prop({ type: { url: String, duration: Number, size: Number, format: String } })
  recording: {
    url: string; // Đường dẫn bản ghi
    duration: number; // Thời lượng
    size: number; // Kích thước
    format: string; // Định dạng
  };

  @Prop({ type: { viewerRetention: Number, engagementRate: Number, conversionRate: Number, topProducts: [{ productId: Types.ObjectId, sales: Number, revenue: Number }] } })
  analytics: {
    viewerRetention: number; // Tỷ lệ giữ chân người xem
    engagementRate: number; // Tỷ lệ tương tác
    conversionRate: number; // Tỷ lệ chuyển đổi
    topProducts: { productId: Types.ObjectId; sales: number; revenue: number }[]; // Sản phẩm bán chạy
  };
}

export const LiveStreamSchema = SchemaFactory.createForClass(LiveStream);

================
File: loyalty-program/schemas/loyalty-program.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema()
export class Tier {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  minPoints: number;

  @Prop({
    type: [
      {
        type: { type: String, enum: ['Giảm giá', 'Miễn phí vận chuyển', 'Quà tặng', 'Quyền truy cập đặc biệt'] },
        value: Number,
        description: String,
      },
    ],
  })
  benefits: { type: string; value: number; description: string }[];
}

export const TierSchema = SchemaFactory.createForClass(Tier);

@Schema()
export class Reward {
  @Prop({ required: true })
  name: string;

  @Prop({ required: true })
  points: number;

  @Prop()
  description: string;

  @Prop()
  image: string;

  @Prop()
  stock: number;

  @Prop({ enum: ['Có sẵn', 'Hết hàng', 'Không hoạt động'], default: 'Có sẵn' })
  status: string;
}

export const RewardSchema = SchemaFactory.createForClass(Reward);

@Schema({ timestamps: true })
export class LoyaltyProgram extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ enum: ['Đang hoạt động', 'Ngừng hoạt động'], default: 'Đang hoạt động' })
  status: string;

  @Prop({
    type: {
      earnRate: Number,
      minPoints: Number,
      pointValue: Number,
      expiryDays: Number,
    },
  })
  pointRules: {
    earnRate: number;
    minPoints: number;
    pointValue: number;
    expiryDays: number;
  };

  @Prop({ type: [TierSchema] })
  tiers: Tier[];

  @Prop({ type: [RewardSchema] })
  rewards: Reward[];

  @Prop({
    type: {
      totalMembers: { type: Number, default: 0 },
      totalPointsIssued: { type: Number, default: 0 },
      totalPointsRedeemed: { type: Number, default: 0 },
      totalRewardsRedeemed: { type: Number, default: 0 },
    },
  })
  statistics: {
    totalMembers: number;
    totalPointsIssued: number;
    totalPointsRedeemed: number;
    totalRewardsRedeemed: number;
  };
}

export const LoyaltyProgramSchema = SchemaFactory.createForClass(LoyaltyProgram);

LoyaltyProgramSchema.index({ storeId: 1 });
LoyaltyProgramSchema.index({ status: 1 });
LoyaltyProgramSchema.index({ 'tiers.minPoints': 1 });
LoyaltyProgramSchema.index({ 'rewards.points': 1 });
LoyaltyProgramSchema.index({ 'rewards.status': 1 });

================
File: loyalty-program/services/loyalty-program.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { LoyaltyProgram } from '../schemas/loyalty-program.schema';

@Injectable()
export class LoyaltyProgramService {
  constructor(
    @InjectModel(LoyaltyProgram.name) private loyaltyProgramModel: Model<LoyaltyProgram>,
  ) { }

  async create(createLoyaltyProgramDto: any): Promise<LoyaltyProgram> {
    const createdProgram = new this.loyaltyProgramModel(createLoyaltyProgramDto);
    return createdProgram.save();
  }

  async findAll(): Promise<LoyaltyProgram[]> {
    return this.loyaltyProgramModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('customerGroup')
      .exec();
  }

  async findOne(id: string): Promise<LoyaltyProgram> {
    const program = await this.loyaltyProgramModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('customerGroup')
      .exec();
    if (!program) {
      throw new NotFoundException(`Loyalty program with ID ${id} not found`);
    }
    return program;
  }

  async update(id: string, updateLoyaltyProgramDto: any): Promise<LoyaltyProgram> {
    const program = await this.loyaltyProgramModel
      .findByIdAndUpdate(id, updateLoyaltyProgramDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('customerGroup')
      .exec();
    if (!program) {
      throw new NotFoundException(`Loyalty program with ID ${id} not found`);
    }
    return program;
  }

  async remove(id: string): Promise<LoyaltyProgram> {
    const program = await this.loyaltyProgramModel.findByIdAndDelete(id).exec();
    if (!program) {
      throw new NotFoundException(`Loyalty program with ID ${id} not found`);
    }
    return program;
  }
}

================
File: marketing-campaign/controllers/marketing-campaign.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { MarketingCampaignService } from '../services/marketing-campaign.service';
import { MarketingCampaign } from './marketing-campaign.schema';

@Controller('marketing-campaigns')
export class MarketingCampaignController {
  constructor(private readonly marketingCampaignService: MarketingCampaignService) { }

  @Post()
  async create(@Body() createCampaignDto: any): Promise<MarketingCampaign> {
    return this.marketingCampaignService.create(createCampaignDto);
  }

  @Get()
  async findAll(
    @Query('branchId') branchId?: string,
    @Query('status') status?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('type') type?: string,
  ): Promise<MarketingCampaign[]> {
    // TODO: Implement filtering logic in service
    return this.marketingCampaignService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateCampaignDto: any,
  ): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, updateCampaignDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status });
  }

  @Post(':id/schedule')
  async schedule(
    @Param('id') id: string,
    @Body() schedule: any,
  ): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, {
      'campaignSettings.schedule': schedule,
      status: 'scheduled',
    });
  }

  @Post(':id/launch')
  async launch(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'active' });
  }

  @Post(':id/pause')
  async pause(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'paused' });
  }

  @Post(':id/resume')
  async resume(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'active' });
  }

  @Post(':id/complete')
  async complete(@Param('id') id: string): Promise<MarketingCampaign> {
    return this.marketingCampaignService.update(id, { status: 'completed' });
  }

  // @Get(':id/analytics')
  // async getAnalytics(@Param('id') id: string): Promise<any> {
  //   const campaign = await this.marketingCampaignService.findOne(id);
  //   return campaign.analytics;
  // }
}

================
File: marketing-campaign/dtos/marketing-campaign.dto.ts
================
// MarketingCampaignDTO: Đại diện toàn bộ schema
export class MarketingCampaignDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên chiến dịch
  type: string; // Loại chiến dịch
  description: string; // Mô tả
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  status: string; // Trạng thái
  conditions: {
    minOrderValue: number;
    maxDiscount: number;
    applicableProducts: string[];
    applicableCategories: string[];
    applicableCustomerGroups: string[];
    usageLimit: number;
    usagePerCustomer: number;
  }; // Điều kiện
  rewards: {
    discountType: string;
    discountValue: number;
    freeShipping: boolean;
    giftProduct: string;
    bundleProducts: { product: string; quantity: number }[];
    loyaltyPoints: number;
  }; // Phần thưởng
  statistics: {
    totalUsage: number;
    totalRevenue: number;
    totalCustomers: number;
  }; // Thống kê
}

// CreateMarketingCampaignDTO: Dùng để tạo mới
export class CreateMarketingCampaignDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên chiến dịch
  type: string; // Loại chiến dịch
  description: string; // Mô tả
  startDate: Date; // Ngày bắt đầu
  endDate: Date; // Ngày kết thúc
  status: string; // Trạng thái
  conditions: {
    minOrderValue: number;
    maxDiscount: number;
    applicableProducts: string[];
    applicableCategories: string[];
    applicableCustomerGroups: string[];
    usageLimit: number;
    usagePerCustomer: number;
  }; // Điều kiện
  rewards: {
    discountType: string;
    discountValue: number;
    freeShipping: boolean;
    giftProduct: string;
    bundleProducts: { product: string; quantity: number }[];
    loyaltyPoints: number;
  }; // Phần thưởng
}

// UpdateMarketingCampaignDTO: Dùng để cập nhật
export class UpdateMarketingCampaignDTO {
  name?: string; // Tên chiến dịch
  type?: string; // Loại chiến dịch
  description?: string; // Mô tả
  startDate?: Date; // Ngày bắt đầu
  endDate?: Date; // Ngày kết thúc
  status?: string; // Trạng thái
  conditions?: {
    minOrderValue?: number;
    maxDiscount?: number;
    applicableProducts?: string[];
    applicableCategories?: string[];
    applicableCustomerGroups?: string[];
    usageLimit?: number;
    usagePerCustomer?: number;
  }; // Điều kiện
  rewards?: {
    discountType?: string;
    discountValue?: number;
    freeShipping?: boolean;
    giftProduct?: string;
    bundleProducts?: { product: string; quantity: number }[];
    loyaltyPoints?: number;
  }; // Phần thưởng
  statistics?: {
    totalUsage?: number;
    totalRevenue?: number;
    totalCustomers?: number;
  }; // Thống kê
}

================
File: marketing-campaign/schemas/marketing-campaign.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'MarketingCampaigns' })
export class MarketingCampaign extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên chiến dịch

  @Prop({ enum: ['discount', 'free_shipping', 'gift', 'bundle', 'loyalty_points'], required: true })
  type: string; // Loại chiến dịch

  @Prop()
  description: string; // Mô tả

  @Prop({ required: true })
  startDate: Date; // Ngày bắt đầu

  @Prop({ required: true })
  endDate: Date; // Ngày kết thúc

  @Prop({ enum: ['draft', 'active', 'paused', 'ended', 'cancelled'], default: 'draft' })
  status: string; // Trạng thái

  @Prop({ type: { minOrderValue: Number, maxDiscount: Number, applicableProducts: [Types.ObjectId], applicableCategories: [Types.ObjectId], applicableCustomerGroups: [Types.ObjectId], usageLimit: Number, usagePerCustomer: Number } })
  conditions: {
    minOrderValue: number; // Giá trị đơn hàng tối thiểu
    maxDiscount: number; // Chiết khấu tối đa
    applicableProducts: Types.ObjectId[]; // Sản phẩm áp dụng
    applicableCategories: Types.ObjectId[]; // Danh mục áp dụng
    applicableCustomerGroups: Types.ObjectId[]; // Nhóm khách hàng áp dụng
    usageLimit: number; // Giới hạn sử dụng
    usagePerCustomer: number; // Giới hạn sử dụng mỗi khách
  };

  @Prop({ type: { discountType: String, discountValue: Number, freeShipping: Boolean, giftProduct: Types.ObjectId, bundleProducts: [{ product: Types.ObjectId, quantity: Number }], loyaltyPoints: Number } })
  rewards: {
    discountType: string; // Loại chiết khấu
    discountValue: number; // Giá trị chiết khấu
    freeShipping: boolean; // Miễn phí vận chuyển
    giftProduct: Types.ObjectId; // Sản phẩm tặng
    bundleProducts: { product: Types.ObjectId; quantity: number }[]; // Gói sản phẩm
    loyaltyPoints: number; // Điểm khách hàng thân thiết
  };

  @Prop({ type: { totalUsage: Number, totalRevenue: Number, totalCustomers: Number } })
  statistics: {
    totalUsage: number; // Tổng lần sử dụng
    totalRevenue: number; // Tổng doanh thu
    totalCustomers: number; // Tổng khách hàng
  };
}

export const MarketingCampaignSchema = SchemaFactory.createForClass(MarketingCampaign);

================
File: marketing-campaign/services/marketing-campaign.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MarketingCampaign } from '../schemas/marketing-campaign.schema';

@Injectable()
export class MarketingCampaignService {
  constructor(
    @InjectModel(MarketingCampaign.name) private marketingCampaignModel: Model<MarketingCampaign>,
  ) { }

  async create(createMarketingCampaignDto: any): Promise<MarketingCampaign> {
    const createdCampaign = new this.marketingCampaignModel(createMarketingCampaignDto);
    return createdCampaign.save();
  }

  async findAll(): Promise<MarketingCampaign[]> {
    return this.marketingCampaignModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('targetCustomers')
      .populate('products')
      .exec();
  }

  async findOne(id: string): Promise<MarketingCampaign> {
    const campaign = await this.marketingCampaignModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('targetCustomers')
      .populate('products')
      .exec();
    if (!campaign) {
      throw new NotFoundException(`Marketing campaign with ID ${id} not found`);
    }
    return campaign;
  }

  async update(id: string, updateMarketingCampaignDto: any): Promise<MarketingCampaign> {
    const campaign = await this.marketingCampaignModel
      .findByIdAndUpdate(id, updateMarketingCampaignDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('targetCustomers')
      .populate('products')
      .exec();
    if (!campaign) {
      throw new NotFoundException(`Marketing campaign with ID ${id} not found`);
    }
    return campaign;
  }

  async remove(id: string): Promise<MarketingCampaign> {
    const campaign = await this.marketingCampaignModel.findByIdAndDelete(id).exec();
    if (!campaign) {
      throw new NotFoundException(`Marketing campaign with ID ${id} not found`);
    }
    return campaign;
  }
}

================
File: marketplace-listing/controllers/marketplace-listing.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { MarketplaceListingService } from '../services/marketplace-listing.service';
import { MarketplaceListing } from './schemas/marketplace-listing.schema';

@Controller('marketplace-listings')
export class MarketplaceListingController {
  constructor(private readonly marketplaceListingService: MarketplaceListingService) { }

  @Post()
  create(@Body() createMarketplaceListingDto: any) {
    return this.marketplaceListingService.create(createMarketplaceListingDto);
  }

  @Get()
  findAll() {
    return this.marketplaceListingService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.marketplaceListingService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateMarketplaceListingDto: any) {
    return this.marketplaceListingService.update(id, updateMarketplaceListingDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.marketplaceListingService.remove(id);
  }
}

================
File: marketplace-listing/dtos/marketplace-listing.dto.ts
================
// MarketplaceListingDTO: Đại diện toàn bộ schema
export class MarketplaceListingDTO {
  storeId: string; // Mã cửa hàng
  productId: string; // Mã sản phẩm
  marketplace: string; // Tên sàn
  listingId: string; // Mã listing
  listingUrl: string; // Đường dẫn
  title: string; // Tiêu đề
  description: string; // Mô tả
  images: string[]; // Ảnh
  price: number; // Giá
  originalPrice: number; // Giá gốc
  stock: number; // Tồn kho
  sku: string; // SKU
  attributes: { name: string; value: string }[]; // Thuộc tính
  category: string; // Danh mục
  subCategory: string; // Danh mục con
  shipping: {
    methods: string[];
    weight: number;
    dimensions: {
      length: number;
      width: number;
      height: number;
    };
  }; // Vận chuyển
  sales: {
    totalSales: number;
    totalRevenue: number;
    rating: number;
    reviews: number;
  }; // Doanh số
  status: string; // Trạng thái
  lastSync: Date; // Đồng bộ cuối
  syncStatus: string; // Trạng thái đồng bộ
  syncError: string; // Lỗi đồng bộ
}

// CreateMarketplaceListingDTO: Dùng để tạo mới
export class CreateMarketplaceListingDTO {
  storeId: string; // Mã cửa hàng
  productId: string; // Mã sản phẩm
  marketplace: string; // Tên sàn
  title: string; // Tiêu đề
  description: string; // Mô tả
  images: string[]; // Ảnh
  price: number; // Giá
  originalPrice: number; // Giá gốc
  stock: number; // Tồn kho
  sku: string; // SKU
  attributes: { name: string; value: string }[]; // Thuộc tính
  category: string; // Danh mục
  subCategory: string; // Danh mục con
  shipping: {
    methods: string[];
    weight: number;
    dimensions: {
      length: number;
      width: number;
      height: number;
    };
  }; // Vận chuyển
  status: string; // Trạng thái
}

// UpdateMarketplaceListingDTO: Dùng để cập nhật
export class UpdateMarketplaceListingDTO {
  title?: string; // Tiêu đề
  description?: string; // Mô tả
  images?: string[]; // Ảnh
  price?: number; // Giá
  originalPrice?: number; // Giá gốc
  stock?: number; // Tồn kho
  sku?: string; // SKU
  attributes?: { name: string; value: string }[]; // Thuộc tính
  category?: string; // Danh mục
  subCategory?: string; // Danh mục con
  shipping?: {
    methods?: string[];
    weight?: number;
    dimensions?: {
      length?: number;
      width?: number;
      height?: number;
    };
  }; // Vận chuyển
  status?: string; // Trạng thái
  syncStatus?: string; // Trạng thái đồng bộ
  syncError?: string; // Lỗi đồng bộ
}

================
File: marketplace-listing/marketplace-listing.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MarketplaceListingController } from './marketplace-listing.controller';
import { MarketplaceListingService } from './marketplace-listing.service';
import { MarketplaceListing, MarketplaceListingSchema } from './schemas/marketplace-listing.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: MarketplaceListing.name, schema: MarketplaceListingSchema }
    ])
  ],
  controllers: [MarketplaceListingController],
  providers: [MarketplaceListingService],
  exports: [MarketplaceListingService]
})
export class MarketplaceListingModule { }

================
File: marketplace-listing/schemas/marketplace-listing.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'MarketplaceListings' })
export class MarketplaceListing extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Products', required: true })
  productId: Types.ObjectId; // Mã sản phẩm

  @Prop({ enum: ['Shopee', 'Lazada', 'Tiki', 'Sendo', 'ZaloShop', 'FacebookShop'], required: true })
  marketplace: string; // Tên sàn thương mại

  @Prop()
  listingId: string; // Mã listing trên sàn

  @Prop()
  listingUrl: string; // Đường dẫn listing

  @Prop({ required: true })
  title: string; // Tiêu đề listing

  @Prop()
  description: string; // Mô tả

  @Prop([String])
  images: string[]; // Ảnh

  @Prop({ required: true })
  price: number; // Giá

  @Prop()
  originalPrice: number; // Giá gốc

  @Prop({ required: true })
  stock: number; // Tồn kho

  @Prop()
  sku: string; // Mã SKU

  @Prop({ type: [{ name: String, value: String }] })
  attributes: { name: string; value: string }[]; // Thuộc tính

  @Prop()
  category: string; // Danh mục

  @Prop()
  subCategory: string; // Danh mục con

  @Prop({ type: { methods: [String], weight: Number, dimensions: { length: Number, width: Number, height: Number } } })
  shipping: {
    methods: string[]; // Phương thức vận chuyển
    weight: number; // Trọng lượng
    dimensions: {
      length: number; // Chiều dài
      width: number; // Chiều rộng
      height: number; // Chiều cao
    };
  };

  @Prop({ type: { totalSales: Number, totalRevenue: Number, rating: Number, reviews: Number } })
  sales: {
    totalSales: number; // Tổng bán
    totalRevenue: number; // Tổng doanh thu
    rating: number; // Đánh giá
    reviews: number; // Số đánh giá
  };

  @Prop({ enum: ['active', 'paused', 'deleted', 'error'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  lastSync: Date; // Thời gian đồng bộ cuối

  @Prop({ enum: ['success', 'failed', 'processing'], default: 'success' })
  syncStatus: string; // Trạng thái đồng bộ

  @Prop()
  syncError: string; // Lỗi đồng bộ
}

export const MarketplaceListingSchema = SchemaFactory.createForClass(MarketplaceListing);

================
File: marketplace-listing/services/marketplace-listing.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { MarketplaceListing } from './schemas/marketplace-listing.schema';

@Injectable()
export class MarketplaceListingService {
  constructor(
    @InjectModel(MarketplaceListing.name)
    private marketplaceListingModel: Model<MarketplaceListing>,
  ) {}

  async create(createMarketplaceListingDto: any): Promise<MarketplaceListing> {
    const createdListing = new this.marketplaceListingModel(createMarketplaceListingDto);
    return createdListing.save();
  }

  async findAll(): Promise<MarketplaceListing[]> {
    return this.marketplaceListingModel.find().exec();
  }

  async findOne(id: string): Promise<MarketplaceListing> {
    const listing = await this.marketplaceListingModel.findById(id).exec();
    if (!listing) {
      throw new NotFoundException(`Marketplace listing with ID ${id} not found`);
    }
    return listing;
  }

  async update(id: string, updateMarketplaceListingDto: any): Promise<MarketplaceListing> {
    const updatedListing = await this.marketplaceListingModel
      .findByIdAndUpdate(id, updateMarketplaceListingDto, { new: true })
      .exec();
    if (!updatedListing) {
      throw new NotFoundException(`Marketplace listing with ID ${id} not found`);
    }
    return updatedListing;
  }

  async remove(id: string): Promise<MarketplaceListing> {
    const deletedListing = await this.marketplaceListingModel.findByIdAndDelete(id).exec();
    if (!deletedListing) {
      throw new NotFoundException(`Marketplace listing with ID ${id} not found`);
    }
    return deletedListing;
  }
}

================
File: order/controllers/order.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { OrderService } from '../services/order.service';
import { Order } from '../schemas/order.schema';

@Controller('api/orders')
export class OrderController {
  constructor(private readonly orderService: OrderService) { }

  @Post()
  create(@Body() createOrderDto: any) {
    return this.orderService.create(createOrderDto);
  }

  @Get()
  findAll() {
    return this.orderService.findAll();
  }

  @Get('doanhthu')
  doanhThu() {
    return this.orderService.doanhThu();
  }
  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.orderService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateOrderDto: any) {
    return this.orderService.update(id, updateOrderDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.orderService.remove(id);
  }
}

================
File: order/dtos/order.dto.ts
================
// OrderDTO: Đại diện toàn bộ schema
export class OrderDTO {
  orderId: string; // Mã đơn hàng
  orderCode: string; // Mã hiển thị
  customerId: string; // Mã khách hàng
  products: { productId: string; quantity: number; price: number; discount: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  discount: number; // Chiết khấu
  paymentMethod: string; // Phương thức thanh toán
  status: string; // Trạng thái
  channel: string; // Mã kênh
  carrierId: string; // Mã đơn vị vận chuyển
  deliveryDate: Date; // Ngày giao hàng
}

// CreateOrderDTO: Dùng để tạo mới
export class CreateOrderDTO {
  customerId: string; // Mã khách hàng
  products: { productId: string; quantity: number; price: number; discount: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  discount: number; // Chiết khấu
  paymentMethod: string; // Phương thức thanh toán
  status: string; // Trạng thái
  channel: string; // Mã kênh
  carrierId: string; // Mã đơn vị vận chuyển
  deliveryDate: Date; // Ngày giao hàng
}

// UpdateOrderDTO: Dùng để cập nhật
export class UpdateOrderDTO {
  customerId?: string; // Mã khách hàng
  products?: { productId: string; quantity: number; price: number; discount: number }[]; // Sản phẩm
  totalAmount?: number; // Tổng tiền
  discount?: number; // Chiết khấu
  paymentMethod?: string; // Phương thức thanh toán
  status?: string; // Trạng thái
  channel?: string; // Mã kênh
  carrierId?: string; // Mã đơn vị vận chuyển
  deliveryDate?: Date; // Ngày giao hàng
}

================
File: order/order.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { OrderController } from './controllers/order.controller';
import { OrderService } from './services/order.service';
import { Order, OrderSchema } from './schemas/order.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Orders', schema: OrderSchema }])
  ],
  controllers: [OrderController],
  providers: [OrderService],
  exports: [OrderService]
})
export class OrderModule { }

================
File: order/schemas/order.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Orders' })
export class Order extends Document {
  @Prop({ unique: true, required: true })
  orderId: string; // Mã đơn hàng

  @Prop({ unique: true, required: true })
  orderCode: string; // Mã đơn hàng hiển thị

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number, price: Number, discount: Number }] })
  products: { productId: Types.ObjectId; quantity: number; price: number; discount: number }[]; // Sản phẩm

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền

  @Prop({ default: 0 })
  discount: number; // Chiết khấu

  @Prop({ enum: ['cash', 'bank_transfer', 'card', 'wallet'] })
  paymentMethod: string; // Phương thức thanh toán

  @Prop({ enum: ['pending', 'confirmed', 'shipping', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels' })
  channel: Types.ObjectId; // Mã kênh bán hàng

  @Prop({ type: Types.ObjectId, ref: 'Carriers' })
  carrierId: Types.ObjectId; // Mã đơn vị vận chuyển

  @Prop()
  deliveryDate: Date; // Ngày giao hàng
}

export const OrderSchema = SchemaFactory.createForClass(Order);

================
File: order/services/order.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Order } from '../schemas/order.schema';

@Injectable()
export class OrderService {
  constructor(
    @InjectModel('Orders') private orderModel: Model<Order>,
  ) { }

  async create(createOrderDto: any): Promise<Order> {
    const lastOrder = await this.orderModel.findOne().sort({ orderId: -1 }).exec();
    let newOrderId = 'HD0001';
  
    if (lastOrder && lastOrder.orderId) {
      const lastNumber = parseInt(lastOrder.orderId.replace('HD', ''), 10);
      const nextNumber = lastNumber + 1;
      newOrderId = `HD${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdOrder = new this.orderModel({
      ...createOrderDto,
      orderId: newOrderId
    });
  
    return createdOrder.save();
  }

  async findAll(): Promise<Order[]> {
    return this.orderModel
      .find()
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
  }
  async doanhThu(): Promise<Order[]> {
    return this.orderModel
      .find()
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .populate('products.productId.priceList')
      .exec();
  }
  async findOne(id: string): Promise<Order> {
    const order = await this.orderModel
      .findById(id)
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  async update(id: string, updateOrderDto: any): Promise<Order> {
    const order = await this.orderModel
      .findByIdAndUpdate(id, updateOrderDto, { new: true })
      .populate('customerId')
      .populate('products.productId')
      .populate('channel')
      .populate('carrierId')
      .exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  async remove(id: string): Promise<Order> {
    const order = await this.orderModel.findByIdAndDelete(id).exec();
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

}

================
File: payroll/controllers/payroll.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Payroll } from '../schemas/payroll.schema';
import { PayrollService } from '../services/payroll.service';

@Controller('api/payrolls')
export class PayrollController {
  constructor(private readonly payrollService: PayrollService) { }

  @Post()
  async create(@Body() createPayrollDto: any): Promise<Payroll> {
    return this.payrollService.create(createPayrollDto);
  }

  @Get()
  findAll() {
    return this.payrollService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.payrollService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatepayrollDto: any) {
    return this.payrollService.update(id, updatepayrollDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.payrollService.remove(id);
  }
}

================
File: payroll/dtos/payroll.dto.ts
================
// PayrollDTO: Đại diện toàn bộ schema
export class PayrollDTO {
  payrollId: string; // Mã bảng lương
  employeeId: string; // Mã nhân viên
  month: number; // Tháng
  year: number; // Năm
  basicSalary: number; // Lương cơ bản
  bonus: number; // Thưởng
  commission: number; // Hoa hồng
  allowance: number; // Phụ cấp
  deduction: number; // Khấu trừ
  total: number; // Tổng lương
  paid: number; // Đã trả
  status: string; // Trạng thái
  branch: string; // Mã chi nhánh
}

// CreatePayrollDTO: Dùng để tạo mới
export class CreatePayrollDTO {
  employeeId: string; // Mã nhân viên
  month: number; // Tháng
  year: number; // Năm
  basicSalary: number; // Lương cơ bản
  bonus: number; // Thưởng
  commission: number; // Hoa hồng
  allowance: number; // Phụ cấp
  deduction: number; // Khấu trừ
  total: number; // Tổng lương
  paid: number; // Đã trả
  status: string; // Trạng thái
  branch: string; // Mã chi nhánh
}

// UpdatePayrollDTO: Dùng để cập nhật
export class UpdatePayrollDTO {
  month?: number; // Tháng
  year?: number; // Năm
  basicSalary?: number; // Lương cơ bản
  bonus?: number; // Thưởng
  commission?: number; // Hoa hồng
  allowance?: number; // Phụ cấp
  deduction?: number; // Khấu trừ
  total?: number; // Tổng lương
  paid?: number; // Đã trả
  status?: string; // Trạng thái
  branch?: string; // Mã chi nhánh
}

================
File: payroll/payroll.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Payroll, PayrollSchema } from './schemas/payroll.schema';
import { PayrollController } from './controllers/payroll.controller';
import { PayrollService } from  './services/payroll.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Payrolls', schema: PayrollSchema }])
  ],
  controllers: [PayrollController],
  providers: [PayrollService],
  exports: [PayrollService]
})
export class PayrollModule { }

================
File: payroll/schemas/payroll.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Payrolls' })
export class Payroll extends Document {
  @Prop({ unique: true, required: true })
  payrollId: string; // Mã bảng lương

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId; // Mã nhân viên

  @Prop({ required: true })
  month: number; // Tháng

  @Prop({ required: true })
  year: number; // Năm

  @Prop({ required: true })
  basicSalary: number; // Lương cơ bản

  @Prop({ default: 0 })
  bonus: number; // Thưởng

  @Prop({ default: 0 })
  commission: number; // Hoa hồng

  @Prop({ default: 0 })
  allowance: number; // Phụ cấp

  @Prop({ default: 0 })
  deduction: number; // Khấu trừ

  @Prop({ required: true })
  total: number; // Tổng lương

  @Prop({ default: 0 })
  paid: number; // Đã trả

  @Prop({ enum: ['creating', 'calculated', 'confirmed', 'cancelled'], default: 'creating' })
  status: string; // Trạng thái

  @Prop({ type: Types.ObjectId, ref: 'Branches', required: true })
  branch: Types.ObjectId; // Mã chi nhánh
}

export const PayrollSchema = SchemaFactory.createForClass(Payroll);

================
File: payroll/services/payroll.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Payroll } from '../schemas/payroll.schema';

@Injectable()
export class PayrollService {
  constructor(
    @InjectModel('Payrolls') private payrollModel: Model<Payroll>,
  ) { }

  async create(createPayrollDto: any): Promise<Payroll> {
    const lastPayroll = await this.payrollModel.findOne().sort({ payrollId: -1 }).exec();
    let newPayrollId = 'PR0001';
  
    if (lastPayroll && lastPayroll.payrollId) {
      const lastNumber = parseInt(lastPayroll.payrollId.replace('PR', ''), 10);
      const nextNumber = lastNumber + 1;
      newPayrollId = `PR${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPayroll = new this.payrollModel({
      ...createPayrollDto,
      payrollId: newPayrollId
    });
  
    return createdPayroll.save();
  }

  async findAll(): Promise<Payroll[]> {
    return this.payrollModel.find().exec();
  }

  async findOne(id: string): Promise<Payroll> {
    const payroll = await this.payrollModel.findById(id).exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }

  async update(id: string, updatePayrollDto: any): Promise<Payroll> {
    const payroll = await this.payrollModel
      .findByIdAndUpdate(id, updatePayrollDto, { new: true })
      .exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }

  async remove(id: string): Promise<Payroll> {
    const payroll = await this.payrollModel.findByIdAndDelete(id).exec();
    if (!payroll) {
      throw new NotFoundException(`payroll with ID ${id} not found`);
    }
    return payroll;
  }
}

================
File: position/controllers/position.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { Position } from '../schemas/position.schema';
import { PositionService } from '../services/position.service';

@Controller('api/positions')
export class PositionController {
  constructor(private readonly positionService: PositionService) { }

  @Post()
  async create(@Body() createPositionDto: any): Promise<Position> {
    return this.positionService.create(createPositionDto);
  }

  @Get()
  findAll() {
    return this.positionService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.positionService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePositionDto: any) {
    return this.positionService.update(id, updatePositionDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.positionService.remove(id);
  }
}

================
File: position/dtos/position.dto.ts
================
// PositionDTO: Đại diện toàn bộ schema
export class PositionDTO {
  positionId: string; // Mã vị trí
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreatePositionDTO: Dùng để tạo mới
export class CreatePositionDTO {
  name: string; // Tên
  description: string; // Mô tả
  status: string; // Trạng thái
}

// UpdatePositionDTO: Dùng để cập nhật
export class UpdatePositionDTO {
  name?: string; // Tên
  description?: string; // Mô tả
  status?: string; // Trạng thái
}

================
File: position/position.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Position, PositionSchema } from './schemas/position.schema';
import { PositionService } from './services/position.service';
import { PositionController } from  './controllers/position.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Positions', schema: PositionSchema }])
  ],
  controllers: [PositionController],
  providers: [PositionService],
  exports: [PositionService]
})
export class PositionModule { }

================
File: position/schemas/position.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'Positions' })
export class Position extends Document {
  @Prop({ unique: true, required: true })
  positionId: string; // Mã vị trí

  @Prop({ required: true })
  name: string; // Tên vị trí

  @Prop()
  description: string; // Mô tả

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const PositionSchema = SchemaFactory.createForClass(Position);

================
File: position/services/position.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Position } from '../schemas/position.schema';

@Injectable()
export class PositionService {
  constructor(
    @InjectModel('Positions') private PositionModel: Model<Position>,
  ) { }

  async create(createPositionDto: any): Promise<Position> {
    const lastPosition = await this.PositionModel.findOne().sort({ positionId: -1 }).exec();
    let newPositionId = 'CV0001';
  
    if (lastPosition && lastPosition.positionId) {
      const lastNumber = parseInt(lastPosition.positionId.replace('CV', ''), 10);
      const nextNumber = lastNumber + 1;
      newPositionId = `CV${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPosition = new this.PositionModel({
      ...createPositionDto,
      positionId: newPositionId
    });
  
    return createdPosition.save();
  }

  async findAll(): Promise<Position[]> {
    return this.PositionModel.find().exec();
  }

  async findOne(id: string): Promise<Position> {
    const position = await this.PositionModel.findById(id).exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }

  async update(id: string, updatePositionDto: any): Promise<Position> {
    const position = await this.PositionModel
      .findByIdAndUpdate(id, updatePositionDto, { new: true })
      .exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }

  async remove(id: string): Promise<Position> {
    const position = await this.PositionModel.findByIdAndDelete(id).exec();
    if (!position) {
      throw new NotFoundException(`Position with ID ${id} not found`);
    }
    return position;
  }
}

================
File: price-list/controllers/price-list.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { PriceListService } from '../services/price-list.service';
import { PriceList } from './price-list.schema';

@Controller('price-lists')
export class PriceListController {
  constructor(private readonly priceListService: PriceListService) { }

  @Post()
  async create(@Body() createPriceListDto: any): Promise<PriceList> {
    return this.priceListService.create(createPriceListDto);
  }

  @Get()
  async findAll(
    @Query('branchId') branchId?: string,
    @Query('status') status?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
  ): Promise<PriceList[]> {
    // TODO: Implement filtering logic in service
    return this.priceListService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<PriceList> {
    return this.priceListService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updatePriceListDto: any,
  ): Promise<PriceList> {
    return this.priceListService.update(id, updatePriceListDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<PriceList> {
    return this.priceListService.remove(id);
  }

  @Put(':id/activate')
  async activate(@Param('id') id: string): Promise<PriceList> {
    const updateDto = { status: 'active' };
    return this.priceListService.update(id, updateDto);
  }

  @Put(':id/deactivate')
  async deactivate(@Param('id') id: string): Promise<PriceList> {
    const updateDto = { status: 'inactive' };
    return this.priceListService.update(id, updateDto);
  }

  @Post(':id/products')
  async addProducts(
    @Param('id') id: string,
    @Body() products: any[],
  ): Promise<PriceList> {
    const priceList = await this.priceListService.findOne(id);
    priceList.products = [...priceList.products, ...products];
    return this.priceListService.update(id, priceList);
  }

  @Delete(':id/products/:productId')
  async removeProduct(
    @Param('id') id: string,
    @Param('productId') productId: string,
  ): Promise<PriceList> {
    const priceList = await this.priceListService.findOne(id);
    priceList.products = priceList.products.filter(
      (p: any) => p.product.toString() !== productId,
    );
    return this.priceListService.update(id, priceList);
  }
}

================
File: price-list/dtos/price-list.dto.ts
================
// PriceListDTO: Đại diện toàn bộ schema
export class PriceListDTO {
  priceListId: string; // Mã bảng giá
  storeId: string; // Mã cửa hàng
  name: string; // Tên
  description: string; // Mô tả
  type: string; // Loại
  status: string; // Trạng thái
  validFrom: Date; // Ngày bắt đầu
  validTo: Date; // Ngày kết thúc
  products: { productId: string; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm
  customerGroups: string[]; // Nhóm khách hàng
  conditions: {
    minOrderValue: number;
    maxOrderValue: number;
    paymentMethods: string[];
    locations: string[];
  }; // Điều kiện
}

// CreatePriceListDTO: Dùng để tạo mới
export class CreatePriceListDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên
  description: string; // Mô tả
  type: string; // Loại
  status: string; // Trạng thái
  validFrom: Date; // Ngày bắt đầu
  validTo: Date; // Ngày kết thúc
  products: { productId: string; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm
  customerGroups: string[]; // Nhóm khách hàng
  conditions: {
    minOrderValue: number;
    maxOrderValue: number;
    paymentMethods: string[];
    locations: string[];
  }; // Điều kiện
}

// UpdatePriceListDTO: Dùng để cập nhật
export class UpdatePriceListDTO {
  name?: string; // Tên
  description?: string; // Mô tả
  type?: string; // Loại
  status?: string; // Trạng thái
  validFrom?: Date; // Ngày bắt đầu
  validTo?: Date; // Ngày kết thúc
  products?: { productId: string; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm
  customerGroups?: string[]; // Nhóm khách hàng
  conditions?: {
    minOrderValue?: number;
    maxOrderValue?: number;
    paymentMethods?: string[];
    locations?: string[];
  }; // Điều kiện
}

================
File: price-list/schemas/price-list.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PriceLists' })
export class PriceList extends Document {
  @Prop({ unique: true, required: true })
  priceListId: string; // Mã bảng giá

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên bảng giá

  @Prop()
  description: string; // Mô tả

  @Prop({ enum: ['retail', 'wholesale', 'agency', 'promotion'], required: true })
  type: string; // Loại bảng giá

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  validFrom: Date; // Ngày bắt đầu

  @Prop()
  validTo: Date; // Ngày kết thúc

  @Prop({ type: [{ productId: Types.ObjectId, price: Number, minQuantity: Number, maxQuantity: Number, discount: Number, discountType: String }] })
  products: { productId: Types.ObjectId; price: number; minQuantity: number; maxQuantity: number; discount: number; discountType: string }[]; // Sản phẩm

  @Prop({ type: [Types.ObjectId], ref: 'CustomerGroups' })
  customerGroups: Types.ObjectId[]; // Nhóm khách hàng

  @Prop({ type: { minOrderValue: Number, maxOrderValue: Number, paymentMethods: [String], locations: [String] } })
  conditions: {
    minOrderValue: number; // Giá trị đơn hàng tối thiểu
    maxOrderValue: number; // Giá trị đơn hàng tối đa
    paymentMethods: string[]; // Phương thức thanh toán
    locations: string[]; // Vị trí
  };
}

export const PriceListSchema = SchemaFactory.createForClass(PriceList);

================
File: price-list/services/price-list.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PriceList } from '../schemas/price-list.schema';

@Injectable()
export class PriceListService {
  constructor(
    @InjectModel(PriceList.name) private priceListModel: Model<PriceList>,
  ) { }

  async create(createPriceListDto: any): Promise<PriceList> {
    const createdPriceList = new this.priceListModel(createPriceListDto);
    return createdPriceList.save();
  }

  async findAll(): Promise<PriceList[]> {
    return this.priceListModel
      .find()
      .populate('branch')
      .populate('createdBy')
      .populate('products')
      .exec();
  }

  async findOne(id: string): Promise<PriceList> {
    const priceList = await this.priceListModel
      .findById(id)
      .populate('branch')
      .populate('createdBy')
      .populate('products')
      .exec();
    if (!priceList) {
      throw new NotFoundException(`Price list with ID ${id} not found`);
    }
    return priceList;
  }

  async update(id: string, updatePriceListDto: any): Promise<PriceList> {
    const priceList = await this.priceListModel
      .findByIdAndUpdate(id, updatePriceListDto, { new: true })
      .populate('branch')
      .populate('createdBy')
      .populate('products')
      .exec();
    if (!priceList) {
      throw new NotFoundException(`Price list with ID ${id} not found`);
    }
    return priceList;
  }

  async remove(id: string): Promise<PriceList> {
    const priceList = await this.priceListModel.findByIdAndDelete(id).exec();
    if (!priceList) {
      throw new NotFoundException(`Price list with ID ${id} not found`);
    }
    return priceList;
  }
}

================
File: product/controllers/product.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ProductService } from '../services/product.service';
import { Product } from '../schemas/product.schema';

@Controller('api/products')
export class ProductController {
  constructor(private readonly productService: ProductService) { }

  @Post()
  create(@Body() createProductDto: any) {
    return this.productService.create(createProductDto);
  }

  @Get()
  findAll() {
    return this.productService.findAll();
  }

  @Get(':id')
  async getProduct(@Param('id') id: string) {
    return this.productService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateProductDto: any) {
    return this.productService.update(id, updateProductDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.productService.remove(id);
  }
}

================
File: product/dtos/product.schema.ts
================
// ProductDTO: Đại diện toàn bộ schema
export class ProductDTO {
  productId: string; // Mã sản phẩm
  barcode: string; // Mã vạch
  name: string; // Tên
  category: string; // Mã danh mục
  brand: string; // Mã thương hiệu
  price: number; // Giá bán
  cost: number; // Giá vốn
  stock: number; // Tồn kho
  location: string; // Vị trí
  minStock: number; // Tồn kho tối thiểu
  maxStock: number; // Tồn kho tối đa
  status: string; // Trạng thái
  image: string; // Ảnh
  weight: number; // Trọng lượng
  unit: string; // Đơn vị
  description: string; // Mô tả
  images: string[]; // Danh sách ảnh
  reviews: { userId: string; rating: number; comment: string; createdAt: Date }[]; // Đánh giá
}

// CreateProductDTO: Dùng để tạo mới
export class CreateProductDTO {
  name: string; // Tên
  barcode: string; // Mã vạch
  category: string; // Mã danh mục
  brand: string; // Mã thương hiệu
  price: number; // Giá bán
  cost: number; // Giá vốn
  stock: number; // Tồn kho
  location: string; // Vị trí
  minStock: number; // Tồn kho tối thiểu
  maxStock: number; // Tồn kho tối đa
  status: string; // Trạng thái
  image: string; // Ảnh
  weight: number; // Trọng lượng
  unit: string; // Đơn vị
  description: string; // Mô tả
  images: string[]; // Danh sách ảnh
}

// UpdateProductDTO: Dùng để cập nhật
export class UpdateProductDTO {
  name?: string; // Tên
  barcode?: string; // Mã vạch
  category?: string; // Mã danh mục
  brand?: string; // Mã thương hiệu
  price?: number; // Giá bán
  cost?: number; // Giá vốn
  stock?: number; // Tồn kho
  location?: string; // Vị trí
  minStock?: number; // Tồn kho tối thiểu
  maxStock?: number; // Tồn kho tối đa
  status?: string; // Trạng thái
  image?: string; // Ảnh
  weight?: number; // Trọng lượng
  unit?: string; // Đơn vị
  description?: string; // Mô tả
  images?: string[]; // Danh sách ảnh
  reviews?: { userId: string; rating: number; comment: string; createdAt: Date }[]; // Đánh giá
}

================
File: product/product.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ProductController } from './controllers/product.controller';
import { ProductService } from './services/product.service';
import { ProductSchema } from './schemas/product.schema';
import { BrandModule } from '../brand/brand.module';
import { CategoriesModule } from '../category/categories.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Products', schema: ProductSchema }]),
    BrandModule,
    CategoriesModule
  ],
  controllers: [ProductController],
  providers: [ProductService],
  exports: [ProductService]
})
export class ProductModule { }

================
File: product/schemas/product.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Products' })
export class Product extends Document {
  @Prop({ unique: true, required: true })
  productId: string; // Mã sản phẩm

  @Prop({ unique: true })
  barcode: string; // Mã vạch

  @Prop({ required: true })
  name: string; // Tên sản phẩm

  @Prop({ type: Types.ObjectId, ref: 'Categories', required: true })
  category: Types.ObjectId; // Mã danh mục

  @Prop({ type: Types.ObjectId, ref: 'Brands', required: true })
  brand: Types.ObjectId; // Mã thương hiệu

  @Prop({ required: true })
  price: number; // Giá bán

  @Prop({ required: true })
  cost: number; // Giá vốn

  @Prop({ default: 0 })
  stock: number; // Tồn kho

  @Prop()
  location: string; // Vị trí kho

  @Prop({ default: 0 })
  minStock: number; // Tồn kho tối thiểu

  @Prop({ default: 100 })
  maxStock: number; // Tồn kho tối đa

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop()
  image: string; // Ảnh

  @Prop()
  weight: number; // Trọng lượng

  @Prop({ required: true })
  unit: string; // Đơn vị

  @Prop()
  description: string; // Mô tả

  @Prop({ type: [String], default: [] })
  images: string[]; // Danh sách ảnh

  @Prop({ type: [{ userId: Types.ObjectId, rating: Number, comment: String, createdAt: Date }], default: [] })
  reviews: { userId: Types.ObjectId; rating: number; comment: string; createdAt: Date }[]; // Đánh giá
}

export const ProductSchema = SchemaFactory.createForClass(Product);

================
File: product/services/product.service.ts
================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Product } from '../schemas/product.schema';

@Injectable()
export class ProductService {
  constructor(
    @InjectModel('Products') private productModel: Model<Product>,
  ) { }

  async create(createProductDto: any): Promise<Product> {
    const lastUser = await this.productModel.findOne().sort({ productId: -1 }).exec();
    let newProductId = 'SP0001';
  
    if (lastUser && lastUser.productId) {
      const lastNumber = parseInt(lastUser.productId.replace('SP', ''), 10);
      const nextNumber = lastNumber + 1;
      newProductId = `SP${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdProduct = new this.productModel({
      ...createProductDto,
      productId: newProductId
    });
  
    return createdProduct.save();
  }

  async findAll(): Promise<Product[]> {
    try {
      const products = await this.productModel.find().exec();
      
      // Populate category and brand only if they exist
      const populatedProducts = await Promise.all(
        products.map(async (product) => {
          if (product.category) {
            await product.populate('category');
          }
          if (product.brand) {
            await product.populate('brand');
          }
          return product;
        })
      );
      
      return populatedProducts;
    } catch (error) {
      console.error('Error in findAll:', error);
      throw error;
    }
  }

  async findOne(id: string): Promise<Product | null> {
    try {
      const product = await this.productModel.findById(id).exec();
      if (!product) {
        return null;
      }
      
      if (product.category) {
        await product.populate('category');
      }
      if (product.brand) {
        await product.populate('brand');
      }
      
      return product;
    } catch (error) {
      console.error('Error in findOne:', error);
      throw error;
    }
  }

  async update(id: string, updateProductDto: any): Promise<Product | null> {
    try {
      const product = await this.productModel
        .findByIdAndUpdate(id, updateProductDto, { new: true })
        .exec();
        
      if (!product) {
        return null;
      }
      
      if (product.category) {
        await product.populate('category');
      }
      if (product.brand) {
        await product.populate('brand');
      }
      
      return product;
    } catch (error) {
      console.error('Error in update:', error);
      throw error;
    }
  }

  async remove(id: string): Promise<Product | null> {
    return this.productModel.findByIdAndDelete(id).exec();
  }
}

================
File: purchase-history/controllers/purchase-history.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PurchaseHistoryService } from '../services/purchase-history.service';
import { PurchaseHistory } from '../schemas/purchase-history.schema';

@Controller('api/purchase-historys')
export class PurchaseHistoryController {
  constructor(private readonly PurchaseHistoryService: PurchaseHistoryService) { }

  @Post()
  async create(@Body() createPurchaseHistoryDto: any): Promise<PurchaseHistory> {
    return this.PurchaseHistoryService.create(createPurchaseHistoryDto);
  }

  @Get()
  findAll() {
    return this.PurchaseHistoryService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.PurchaseHistoryService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatePurchaseHistoryDto: any) {
    return this.PurchaseHistoryService.update(id, updatePurchaseHistoryDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.PurchaseHistoryService.remove(id);
  }
}

================
File: purchase-history/dtos/purchase-history.dto.ts
================
// PurchaseHistoryDTO: Đại diện toàn bộ schema
export class PurchaseHistoryDTO {
  purchaseHistoryId: string; // Mã lịch sử mua hàng
  storeId: string; // Mã cửa hàng
  packageId: string; // Mã gói dịch vụ
  purchaseDate: Date; // Ngày mua
  amount: number; // Số tiền
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreatePurchaseHistoryDTO: Dùng để tạo mới
export class CreatePurchaseHistoryDTO {
  storeId: string; // Mã cửa hàng
  packageId: string; // Mã gói dịch vụ
  purchaseDate: Date; // Ngày mua
  amount: number; // Số tiền
  status: string; // Trạng thái
}

// UpdatePurchaseHistoryDTO: Dùng để cập nhật
export class UpdatePurchaseHistoryDTO {
  purchaseDate?: Date; // Ngày mua
  amount?: number; // Số tiền
  status?: string; // Trạng thái
}

================
File: purchase-history/purchase-history.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PurchaseHistory, PurchaseHistorySchema } from './schemas/purchase-history.schema';
import { PurchaseHistoryService } from './services/purchase-history.service';
import { PurchaseHistoryController } from './controllers/purchase-history.controller';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PurchaseHistories', schema: PurchaseHistorySchema }])
  ],
  controllers: [PurchaseHistoryController],
  providers: [PurchaseHistoryService],
  exports: [PurchaseHistoryService]
})
export class PurchaseHistoryModule { }

================
File: purchase-history/schemas/purchase-history.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PurchaseHistories' })
export class PurchaseHistory extends Document {
  @Prop({ unique: true, required: true })
  purchaseHistoryId: string; // Mã lịch sử mua hàng

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'ServicePackages', required: true })
  packageId: Types.ObjectId; // Mã gói dịch vụ

  @Prop({ required: true })
  purchaseDate: Date; // Ngày mua

  @Prop({ required: true })
  amount: number; // Số tiền

  @Prop({ enum: ['paid', 'pending', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop()
  paymentMethod: string; // Phương thức thanh toán

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}
export const PurchaseHistorySchema = SchemaFactory.createForClass(PurchaseHistory);

================
File: purchase-history/services/purchase-history.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PurchaseHistory } from '../schemas/purchase-history.schema';

@Injectable()
export class PurchaseHistoryService {
  constructor(
    @InjectModel('PurchaseHistories') private PurchaseHistoryModel: Model<PurchaseHistory>,
  ) { }

  async create(createPurchaseHistoryDto: any): Promise<PurchaseHistory> {
    const lastPurchaseHistory = await this.PurchaseHistoryModel.findOne().sort({ purchaseHistoryId: -1 }).exec();
    let newPurchaseHistoryId = 'PH0001';
  
    if (lastPurchaseHistory && lastPurchaseHistory.purchaseHistoryId) {
      const lastNumber = parseInt(lastPurchaseHistory.purchaseHistoryId.replace('PH', ''), 10);
      const nextNumber = lastNumber + 1;
      newPurchaseHistoryId = `PH${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPurchaseHistory = new this.PurchaseHistoryModel({
      ...createPurchaseHistoryDto,
      purchaseHistoryId: newPurchaseHistoryId
    });
  
    return createdPurchaseHistory.save();
  }

  async findAll(): Promise<PurchaseHistory[]> {
    return this.PurchaseHistoryModel.find().exec();
  }

  async findOne(id: string): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel.findById(id).exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }

  async update(id: string, updatePurchaseHistoryDto: any): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel
      .findByIdAndUpdate(id, updatePurchaseHistoryDto, { new: true })
      .exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }

  async remove(id: string): Promise<PurchaseHistory> {
    const PurchaseHistory = await this.PurchaseHistoryModel.findByIdAndDelete(id).exec();
    if (!PurchaseHistory) {
      throw new NotFoundException(`PurchaseHistory with ID ${id} not found`);
    }
    return PurchaseHistory;
  }
}

================
File: purchase-order/controllers/purchase-orders.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { PurchaseOrderService } from '../services/purchase-orders.service';
import { PurchaseOrder } from '../schemas/purchase-orders.schema';

@Controller('api/purchase-orders')
export class PurchaseOrderController {
  constructor(private readonly purchaseOrderService: PurchaseOrderService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<PurchaseOrder> {
    return this.purchaseOrderService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.purchaseOrderService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.purchaseOrderService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updatepurchaseOrderDto: any) {
    return this.purchaseOrderService.update(id, updatepurchaseOrderDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.purchaseOrderService.remove(id);
  }
}

================
File: purchase-order/dtos/purchase-order.dto.ts
================
// PurchaseOrderDTO: Đại diện toàn bộ schema
export class PurchaseOrderDTO {
  purchaseOrderId: string; // Mã đơn đặt hàng
  supplierId: string; // Mã nhà cung cấp
  products: { productId: string; quantity: number; price: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreatePurchaseOrderDTO: Dùng để tạo mới
export class CreatePurchaseOrderDTO {
  supplierId: string; // Mã nhà cung cấp
  products: { productId: string; quantity: number; price: number }[]; // Sản phẩm
  totalAmount: number; // Tổng tiền
  status: string; // Trạng thái
}

// UpdatePurchaseOrderDTO: Dùng để cập nhật
export class UpdatePurchaseOrderDTO {
  supplierId?: string; // Mã nhà cung cấp
  products?: { productId: string; quantity: number; price: number }[]; // Sản phẩm
  totalAmount?: number; // Tổng tiền
  status?: string; // Trạng thái
}

================
File: purchase-order/purchase-orders.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PurchaseOrder, PurchaseOrderSchema } from './schemas/purchase-orders.schema';
import { PurchaseOrderController } from './controllers/purchase-orders.controller';
import { PurchaseOrderService } from './services/purchase-orders.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'PurchaseOrders', schema: PurchaseOrderSchema }])
  ],
  controllers: [PurchaseOrderController],
  providers: [PurchaseOrderService],
  exports: [PurchaseOrderService]
})
export class PurchaseOrderModule { }

================
File: purchase-order/schemas/purchase-orders.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'PurchaseOrders' })
export class PurchaseOrder extends Document {
  @Prop({ unique: true, required: true })
  purchaseOrderId: string; // Mã đơn đặt hàng

  @Prop({ type: Types.ObjectId, ref: 'Suppliers', required: true })
  supplierId: Types.ObjectId; // Mã nhà cung cấp

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number, price: Number }] })
  products: { productId: Types.ObjectId; quantity: number; price: number }[]; // Sản phẩm

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền

  @Prop({ enum: ['pending', 'confirmed', 'shipping', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const PurchaseOrderSchema = SchemaFactory.createForClass(PurchaseOrder);

================
File: purchase-order/services/purchase-orders.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { PurchaseOrder } from '../schemas/purchase-orders.schema';

@Injectable()
export class PurchaseOrderService {
  constructor(
    @InjectModel('PurchaseOrders') private PurchaseOrderModel: Model<PurchaseOrder>,
  ) { }

  async create(createPurchaseOrderDto: any): Promise<PurchaseOrder> {
    const lastPurchaseOrder = await this.PurchaseOrderModel.findOne().sort({ purchaseOrderId: -1 }).exec();
    let newPurchaseOrderId = 'PO0001';
  
    if (lastPurchaseOrder && lastPurchaseOrder.purchaseOrderId) {
      const lastNumber = parseInt(lastPurchaseOrder.purchaseOrderId.replace('PO', ''), 10);
      const nextNumber = lastNumber + 1;
      newPurchaseOrderId = `PO${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdPurchaseOrder = new this.PurchaseOrderModel({
      ...createPurchaseOrderDto,
      purchaseOrderId: newPurchaseOrderId
    });
  
    return createdPurchaseOrder.save();
  }

  async findAll(): Promise<PurchaseOrder[]> {
    return this.PurchaseOrderModel.find().exec();
  }

  async findOne(id: string): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel.findById(id).exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }

  async update(id: string, updatePurchaseOrderDto: any): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel
      .findByIdAndUpdate(id, updatePurchaseOrderDto, { new: true })
      .exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }

  async remove(id: string): Promise<PurchaseOrder> {
    const PurchaseOrder = await this.PurchaseOrderModel.findByIdAndDelete(id).exec();
    if (!PurchaseOrder) {
      throw new NotFoundException(`PurchaseOrder with ID ${id} not found`);
    }
    return PurchaseOrder;
  }
}

================
File: return-purchase/dtos/return-purchase.dto.ts
================
// ReturnPurchaseDTO: Đại diện toàn bộ schema
export class ReturnPurchaseDTO {
  returnPurchaseId: string; // Mã trả hàng
  purchaseOrderId: string; // Mã đơn đặt hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateReturnPurchaseDTO: Dùng để tạo mới
export class CreateReturnPurchaseDTO {
  purchaseOrderId: string; // Mã đơn đặt hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
}

// UpdateReturnPurchaseDTO: Dùng để cập nhật
export class UpdateReturnPurchaseDTO {
  products?: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount?: number; // Tổng tiền trả
  status?: string; // Trạng thái
}

================
File: return-purchase/schemas/return-purchase.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'ReturnPurchases' })
export class ReturnPurchase extends Document {
  @Prop({ unique: true, required: true })
  returnPurchaseId: string; // Mã trả hàng

  @Prop({ type: Types.ObjectId, ref: 'PurchaseOrders', required: true })
  purchaseOrderId: Types.ObjectId; // Mã đơn đặt hàng

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  products: { productId: Types.ObjectId; quantity: number }[]; // Sản phẩm trả

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền trả

  @Prop({ enum: ['pending', 'confirmed', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const ReturnPurchaseSchema = SchemaFactory.createForClass(ReturnPurchase);

================
File: ruturn/controllers/return.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ReturnService } from '../services/return.service';
import { Return } from '../schemas/return.schema';

@Controller('api/returns')
export class ReturnController {
  constructor(private readonly returnService: ReturnService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<Return> {
    return this.returnService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.returnService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.returnService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateReturnDto: any) {
    return this.returnService.update(id, updateReturnDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.returnService.remove(id);
  }
}

================
File: ruturn/dtos/return.dto.ts
================
// ReturnDTO: Đại diện toàn bộ schema
export class ReturnDTO {
  returnId: string; // Mã trả hàng
  orderId: string; // Mã đơn hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateReturnDTO: Dùng để tạo mới
export class CreateReturnDTO {
  orderId: string; // Mã đơn hàng
  products: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount: number; // Tổng tiền trả
  status: string; // Trạng thái
}

// UpdateReturnDTO: Dùng để cập nhật
export class UpdateReturnDTO {
  products?: { productId: string; quantity: number }[]; // Sản phẩm trả
  totalAmount?: number; // Tổng tiền trả
  status?: string; // Trạng thái
}

================
File: ruturn/return.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Return, ReturnSchema } from './schemas/return.schema';
import { ReturnController } from './controllers/return.controller';
import { ReturnService } from './services/return.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Returns', schema: ReturnSchema }])
  ],
  controllers: [ReturnController],
  providers: [ReturnService],
  exports: [ReturnService]
})
export class ReturnModule { }

================
File: ruturn/schemas/return.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Returns' })
export class Return extends Document {
  @Prop({ unique: true, required: true })
  returnId: string; // Mã trả hàng

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId; // Mã đơn hàng

  @Prop({ type: [{ productId: Types.ObjectId, quantity: Number }] })
  products: { productId: Types.ObjectId; quantity: number }[]; // Sản phẩm trả

  @Prop({ required: true })
  totalAmount: number; // Tổng tiền trả

  @Prop({ enum: ['pending', 'confirmed', 'completed', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}

export const ReturnSchema = SchemaFactory.createForClass(Return);

================
File: ruturn/services/return.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Return } from '../schemas/return.schema';

@Injectable()
export class ReturnService {
  constructor(
    @InjectModel('Returns') private ReturnModel: Model<Return>,
  ) { }

  async create(createReturnDto: any): Promise<Return> {
    const lastReturn = await this.ReturnModel.findOne().sort({ returnId: -1 }).exec();
    let newReturnId = 'RT0001';
  
    if (lastReturn && lastReturn.returnId) {
      const lastNumber = parseInt(lastReturn.returnId.replace('RT', ''), 10);
      const nextNumber = lastNumber + 1;
      newReturnId = `RT${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdReturn = new this.ReturnModel({
      ...createReturnDto,
      returnId: newReturnId
    });
  
    return createdReturn.save();
  }

  async findAll(): Promise<Return[]> {
    return this.ReturnModel.find().exec();
  }

  async findOne(id: string): Promise<Return> {
    const Return = await this.ReturnModel.findById(id).exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }

  async update(id: string, updateReturnDto: any): Promise<Return> {
    const Return = await this.ReturnModel
      .findByIdAndUpdate(id, updateReturnDto, { new: true })
      .exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }

  async remove(id: string): Promise<Return> {
    const Return = await this.ReturnModel.findByIdAndDelete(id).exec();
    if (!Return) {
      throw new NotFoundException(`Return with ID ${id} not found`);
    }
    return Return;
  }
}

================
File: sale-channel/dtos/sale-channel.dto.ts
================
// SalesChannelDTO: Đại diện toàn bộ schema
export class SalesChannelDTO {
  channelId: string; // Mã kênh bán hàng
  storeId: string; // Mã cửa hàng
  name: string; // Tên kênh
  type: string; // Loại kênh
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateSalesChannelDTO: Dùng để tạo mới
export class CreateSalesChannelDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên kênh
  type: string; // Loại kênh
  status: string; // Trạng thái
}

// UpdateSalesChannelDTO: Dùng để cập nhật
export class UpdateSalesChannelDTO {
  name?: string; // Tên kênh (tùy chọn)
  type?: string; // Loại kênh (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: sale-channel/schemas/sale-channel.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true })
export class SalesChannel extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop({
    enum: [
      'Trực tiếp',
      'Shopee',
      'Tiki',
      'Lazada',
      'Sendo',
      'Facebook',
      'Instagram',
    ],
    required: true,
  })
  type: string;

  @Prop()
  description: string;

  @Prop({ enum: ['Đang hoạt động', 'Ngừng hoạt động'], default: 'Đang hoạt động' })
  status: string;

  @Prop({
    type: {
      syncProducts: { type: Boolean, default: false },
      syncPrices: { type: Boolean, default: false },
      syncStock: { type: Boolean, default: false },
      shopee: {
        shopId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      tiki: {
        sellerId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      lazada: {
        sellerId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      sendo: {
        sellerId: String,
        accessToken: String,
        refreshToken: String,
        tokenExpiry: Date,
      },
      facebook: {
        pageId: String,
        accessToken: String,
        tokenExpiry: Date,
      },
      instagram: {
        businessAccountId: String,
        accessToken: String,
        tokenExpiry: Date,
      },
    },
  })
  settings: {
    syncProducts: boolean;
    syncPrices: boolean;
    syncStock: boolean;
    shopee: {
      shopId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    tiki: {
      sellerId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    lazada: {
      sellerId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    sendo: {
      sellerId: string;
      accessToken: string;
      refreshToken: string;
      tokenExpiry: Date;
    };
    facebook: {
      pageId: string;
      accessToken: string;
      tokenExpiry: Date;
    };
    instagram: {
      businessAccountId: string;
      accessToken: string;
      tokenExpiry: Date;
    };
  };

  @Prop({
    type: {
      totalOrders: { type: Number, default: 0 },
      totalRevenue: { type: Number, default: 0 },
      totalProducts: { type: Number, default: 0 },
    },
  })
  statistics: {
    totalOrders: number;
    totalRevenue: number;
    totalProducts: number;
  };
}

export const SalesChannelSchema = SchemaFactory.createForClass(SalesChannel);

================
File: service-package/controllers/service-package.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { ServicePackageService } from '../services/service-package.service';
import { ServicePackage } from '../schemas/service-package.schems';

@Controller('api/service-packages')
export class ServicePackageController {
  constructor(private readonly ServicePackageService: ServicePackageService) { }

  @Post()
  async create(@Body() createServicePackageDto: any): Promise<ServicePackage> {
    return this.ServicePackageService.create(createServicePackageDto);
  }

  @Get()
  findAll() {
    return this.ServicePackageService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.ServicePackageService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateServicePackageDto: any) {
    return this.ServicePackageService.update(id, updateServicePackageDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.ServicePackageService.remove(id);
  }
}

================
File: service-package/dtos/service-package.dto.ts
================
// ServicePackageDTO: Đại diện toàn bộ schema
export class ServicePackageDTO {
  packageId: string; // Mã gói dịch vụ
  name: string; // Tên gói
  description: string; // Mô tả
  price: number; // Giá
  type: string; // Loại gói
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateServicePackageDTO: Dùng để tạo mới
export class CreateServicePackageDTO {
  name: string; // Tên gói
  description: string; // Mô tả
  price: number; // Giá
  type: string; // Loại gói
  status: string; // Trạng thái
}

// UpdateServicePackageDTO: Dùng để cập nhật
export class UpdateServicePackageDTO {
  name?: string; // Tên gói (tùy chọn)
  description?: string; // Mô tả (tùy chọn)
  price?: number; // Giá (tùy chọn)
  type?: string; // Loại gói (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: service-package/schemas/service-package.schems.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'ServicePackages' })
export class ServicePackage extends Document {
  @Prop({ unique: true, required: true })
  packageId: string; // Mã gói dịch vụ, định danh duy nhất

  @Prop({ required: true })
  name: string; // Tên gói dịch vụ

  @Prop()
  description: string; // Mô tả gói dịch vụ

  @Prop({ required: true })
  price: number; // Giá của gói dịch vụ

  @Prop({ enum: ['monthly', 'yearly', 'lifetime'], required: true })
  type: string; // Loại gói: hàng tháng, hàng năm, trọn đời

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái: hoạt động hoặc không hoạt động

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const ServicePackageSchema = SchemaFactory.createForClass(ServicePackage);

================
File: service-package/service-package.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ServicePackage, ServicePackageSchema } from './schemas/service-package.schems';
import { ServicePackageService } from './services/service-package.service';
import { ServicePackageController } from './controllers/service-package.controller';


@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'ServicePackages', schema: ServicePackageSchema }])
  ],
  controllers: [ServicePackageController],
  providers: [ServicePackageService],
  exports: [ServicePackageService]
})
export class ServicePackageModule { }

================
File: service-package/services/service-package.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { ServicePackage } from '../schemas/service-package.schems';

@Injectable()
export class ServicePackageService {
  constructor(
    @InjectModel('ServicePackages') private ServicePackageModel: Model<ServicePackage>,
  ) { }

  async create(createServicePackageDto: any): Promise<ServicePackage> {
    const lastServicePackage = await this.ServicePackageModel.findOne().sort({ packageId: -1 }).exec();
    let newServicePackageId = 'SVP0001';
  
    if (lastServicePackage && lastServicePackage.packageId) {
      const lastNumber = parseInt(lastServicePackage.packageId.replace('SVP', ''), 10);
      const nextNumber = lastNumber + 1;
      newServicePackageId = `SVP${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdServicePackage = new this.ServicePackageModel({
      ...createServicePackageDto,
      servicePackageId: newServicePackageId
    });
  
    return createdServicePackage.save();
  }

  async findAll(): Promise<ServicePackage[]> {
    return this.ServicePackageModel.find().exec();
  }

  async findOne(id: string): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel.findById(id).exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }

  async update(id: string, updateServicePackageDto: any): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel
      .findByIdAndUpdate(id, updateServicePackageDto, { new: true })
      .exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }

  async remove(id: string): Promise<ServicePackage> {
    const ServicePackage = await this.ServicePackageModel.findByIdAndDelete(id).exec();
    if (!ServicePackage) {
      throw new NotFoundException(`ServicePackage with ID ${id} not found`);
    }
    return ServicePackage;
  }
}

================
File: shipment/controllers/shipment.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete, Query } from '@nestjs/common';
import { ShipmentService } from '../services/shipment.service';
import { Shipment } from '../schemas/shipment.schema';

@Controller('api/shipments')
export class ShipmentController {
  constructor(private readonly shipmentService: ShipmentService) { }

  @Post()
  async create(@Body() createShipmentDto: any): Promise<Shipment> {
    return this.shipmentService.create(createShipmentDto);
  }

  @Get()
  async findAll(@Query() query: any): Promise<Shipment[]> {
    return this.shipmentService.findAll(query);
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Shipment> {
    return this.shipmentService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateShipmentDto: any,
  ): Promise<Shipment> {
    return this.shipmentService.update(id, updateShipmentDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<Shipment> {
    return this.shipmentService.remove(id);
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<Shipment> {
    return this.shipmentService.updateStatus(id, status);
  }

  @Put(':id/tracking')
  async updateTracking(
    @Param('id') id: string,
    @Body() tracking: any,
  ): Promise<Shipment> {
    return this.shipmentService.updateTracking(id, tracking);
  }

  @Put(':id/carrier')
  async updateCarrier(
    @Param('id') id: string,
    @Body('carrierId') carrierId: string,
  ): Promise<Shipment> {
    return this.shipmentService.updateCarrier(id, carrierId);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<Shipment[]> {
    return this.shipmentService.findByStore(storeId);
  }

  @Get('order/:orderId')
  async findByOrder(@Param('orderId') orderId: string): Promise<Shipment[]> {
    return this.shipmentService.findByOrder(orderId);
  }
}

================
File: shipment/dtos/shipment.dto.ts
================
// ShipmentDTO: Đại diện toàn bộ schema
export class ShipmentDTO {
  shipmentId: string; // Mã vận chuyển
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  shippingAddress: string; // Địa chỉ giao hàng
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateShipmentDTO: Dùng để tạo mới
export class CreateShipmentDTO {
  storeId: string; // Mã cửa hàng
  orderId: string; // Mã đơn hàng
  customerId: string; // Mã khách hàng
  shippingAddress: string; // Địa chỉ giao hàng
  status: string; // Trạng thái
}

// UpdateShipmentDTO: Dùng để cập nhật
export class UpdateShipmentDTO {
  shippingAddress?: string; // Địa chỉ giao hàng (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: shipment/schemas/shipment.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Shipments' })
export class Shipment extends Document {
  @Prop({ unique: true, required: true })
  shipmentId: string; // Mã vận chuyển, định danh duy nhất

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng, liên kết đến bảng Stores

  @Prop({ type: Types.ObjectId, ref: 'Orders', required: true })
  orderId: Types.ObjectId; // Mã đơn hàng, liên kết đến bảng Orders

  @Prop({ type: Types.ObjectId, ref: 'Customers', required: true })
  customerId: Types.ObjectId; // Mã khách hàng, liên kết đến bảng Customers

  @Prop({ required: true })
  shippingAddress: string; // Địa chỉ giao hàng

  @Prop({ enum: ['pending', 'shipped', 'delivered', 'cancelled'], default: 'pending' })
  status: string; // Trạng thái: đang chờ, đã giao, hoàn thành, hủy

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const ShipmentSchema = SchemaFactory.createForClass(Shipment);

================
File: shipment/services/shipment.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Shipment } from '../schemas/shipment.schema';

@Injectable()
export class ShipmentService {
  constructor(
    @InjectModel('Shipments')
    private shipmentModel: Model<Shipment>,
  ) { }

  async create(createShipmentDto: any): Promise<Shipment> {
    const lastShipment = await this.shipmentModel.findOne().sort({ shipmentId: -1 }).exec();
    let newShipmentId = 'SM0001';
  
    if (lastShipment && lastShipment.shipmentId) {
      const lastNumber = parseInt(lastShipment.shipmentId.replace('SM', ''), 10);
      const nextNumber = lastNumber + 1;
      newShipmentId = `SM${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdShipment = new this.shipmentModel({
      ...createShipmentDto,
      shipmentId: newShipmentId
    });
  
    return createdShipment.save();
  }

  async findAll(query: any = {}): Promise<Shipment[]> {
    return this.shipmentModel.find(query).exec();
  }

  async findOne(id: string): Promise<Shipment> {
    const shipment = await this.shipmentModel.findById(id).exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async update(id: string, updateShipmentDto: any): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, updateShipmentDto, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async remove(id: string): Promise<Shipment> {
    const shipment = await this.shipmentModel.findByIdAndDelete(id).exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateStatus(id: string, status: string): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { status }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateTracking(id: string, tracking: any): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { tracking }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async updateCarrier(id: string, carrierId: string): Promise<Shipment> {
    const shipment = await this.shipmentModel
      .findByIdAndUpdate(id, { carrier: carrierId }, { new: true })
      .exec();
    if (!shipment) {
      throw new NotFoundException(`Shipment with ID ${id} not found`);
    }
    return shipment;
  }

  async findByStore(storeId: string): Promise<Shipment[]> {
    return this.shipmentModel.find({ storeId }).exec();
  }

  async findByOrder(orderId: string): Promise<Shipment[]> {
    return this.shipmentModel.find({ order: orderId }).exec();
  }
}

================
File: shipment/shipment.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { Shipment, ShipmentSchema } from './schemas/shipment.schema';
import { ShipmentController } from './controllers/shipment.controller';
import { ShipmentService } from './services/shipment.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'Shipments', schema: ShipmentSchema }])
  ],
  controllers: [ShipmentController],
  providers: [ShipmentService],
  exports: [ShipmentService]
})
export class ShipmentModule { }

================
File: social-media-conversation/controllers/social-media-conversation.controller.ts
================
import { Controller, Get, Post, Body, Put, Param, Delete, Query } from '@nestjs/common';
import { SocialMediaConversationService } from './social-media-conversation.service';
import { SocialMediaConversation } from './social-media-conversation.schema';

@Controller('social-media-conversations')
export class SocialMediaConversationController {
  constructor(private readonly conversationService: SocialMediaConversationService) { }

  @Post()
  async create(@Body() createConversationDto: any): Promise<SocialMediaConversation> {
    return this.conversationService.create(createConversationDto);
  }

  @Get()
  async findAll(
    @Query('branchId') branchId?: string,
    @Query('status') status?: string,
    @Query('platform') platform?: string,
    @Query('assignedTo') assignedTo?: string,
  ): Promise<SocialMediaConversation[]> {
    // TODO: Implement filtering logic in service
    return this.conversationService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<SocialMediaConversation> {
    return this.conversationService.findOne(id);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateConversationDto: any,
  ): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, updateConversationDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<SocialMediaConversation> {
    return this.conversationService.remove(id);
  }

  // @Post(':id/messages')
  // async addMessage(
  //   @Param('id') id: string,
  //   @Body() message: any,
  // ): Promise<SocialMediaConversation> {
  //   const conversation = await this.conversationService.findOne(id);
  //   conversation.messages.push(message);
  //   conversation.metadata.lastMessageAt = new Date();
  //   conversation.metadata.unreadCount += 1;
  //   return this.conversationService.update(id, conversation);
  // }

  @Put(':id/assign')
  async assignTo(
    @Param('id') id: string,
    @Body('userId') userId: string,
  ): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, { assignedTo: userId });
  }

  @Put(':id/status')
  async updateStatus(
    @Param('id') id: string,
    @Body('status') status: string,
  ): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, { status });
  }

  @Put(':id/read')
  async markAsRead(@Param('id') id: string): Promise<SocialMediaConversation> {
    return this.conversationService.update(id, { 'metadata.unreadCount': 0 });
  }
}

================
File: social-media-conversation/dtos/social-media-conversation.dto.ts
================
// SocialMediaConversationDTO: Đại diện toàn bộ schema
export class SocialMediaConversationDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  platform: string; // Nền tảng
  conversationId: string; // Mã cuộc trò chuyện
  customerName: string; // Tên khách hàng
  messages: { sender: string; message: string; timestamp: Date }[]; // Danh sách tin nhắn
  status: string; // Trạng thái
  assignedTo: string; // Mã nhân viên phụ trách
  relatedOrders: { orderId: string }[]; // Danh sách đơn hàng liên quan
  relatedProducts: { productId: string }[]; // Danh sách sản phẩm liên quan
  createdAt: Date; // Thời gian tạo
}

// CreateSocialMediaConversationDTO: Dùng để tạo mới
export class CreateSocialMediaConversationDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  platform: string; // Nền tảng
  conversationId: string; // Mã cuộc trò chuyện
  customerName: string; // Tên khách hàng
  messages: { sender: string; message: string; timestamp: Date }[]; // Danh sách tin nhắn
  status: string; // Trạng thái
  assignedTo: string; // Mã nhân viên phụ trách
  relatedOrders: { orderId: string }[]; // Danh sách đơn hàng liên quan
  relatedProducts: { productId: string }[]; // Danh sách sản phẩm liên quan
}

// UpdateSocialMediaConversationDTO: Dùng để cập nhật
export class UpdateSocialMediaConversationDTO {
  messages?: { sender: string; message: string; timestamp: Date }[]; // Danh sách tin nhắn (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
  assignedTo?: string; // Mã nhân viên phụ trách (tùy chọn)
  relatedOrders?: { orderId: string }[]; // Danh sách đơn hàng liên quan (tùy chọn)
  relatedProducts?: { productId: string }[]; // Danh sách sản phẩm liên quan (tùy chọn)
}

================
File: social-media-conversation/schemas/social-media-conversation.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'SocialMediaConversations' })
export class SocialMediaConversation extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng, liên kết đến bảng Stores

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels', required: true })
  channelId: Types.ObjectId; // Mã kênh, liên kết đến bảng SalesChannels

  @Prop({ required: true })
  platform: string; // Nền tảng (Facebook, Instagram, v.v.)

  @Prop({ required: true })
  conversationId: string; // Mã cuộc trò chuyện, định danh duy nhất

  @Prop({ required: true })
  customerName: string; // Tên khách hàng

  @Prop({ type: [{ sender: String, message: String, timestamp: Date }] })
  messages: { sender: string; message: string; timestamp: Date }[]; // Danh sách tin nhắn

  @Prop({ enum: ['open', 'closed', 'pending'], default: 'open' })
  status: string; // Trạng thái: đang mở, đã đóng, đang chờ

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  assignedTo: Types.ObjectId; // Mã nhân viên phụ trách, liên kết đến bảng Employees

  @Prop({ type: [{ orderId: Types.ObjectId }] })
  relatedOrders: { orderId: Types.ObjectId }[]; // Danh sách đơn hàng liên quan

  @Prop({ type: [{ productId: Types.ObjectId }] })
  relatedProducts: { productId: Types.ObjectId }[]; // Danh sách sản phẩm liên quan

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const SocialMediaConversationSchema = SchemaFactory.createForClass(SocialMediaConversation);

================
File: social-media-conversation/services/social-media-conversation.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SocialMediaConversation } from './schemas/social-media-conversation.schema';

@Injectable()
export class SocialMediaConversationService {
  constructor(
    @InjectModel(SocialMediaConversation.name) private conversationModel: Model<SocialMediaConversation>,
  ) { }

  async create(createConversationDto: any): Promise<SocialMediaConversation> {
    const createdConversation = new this.conversationModel(createConversationDto);
    return createdConversation.save();
  }

  async findAll(): Promise<SocialMediaConversation[]> {
    return this.conversationModel
      .find()
      .populate('branch')
      .populate('customer')
      .populate('assignedTo')
      .populate('channel')
      .exec();
  }

  async findOne(id: string): Promise<SocialMediaConversation> {
    const conversation = await this.conversationModel
      .findById(id)
      .populate('branch')
      .populate('customer')
      .populate('assignedTo')
      .populate('channel')
      .exec();
    if (!conversation) {
      throw new NotFoundException(`Social media conversation with ID ${id} not found`);
    }
    return conversation;
  }

  async update(id: string, updateConversationDto: any): Promise<SocialMediaConversation> {
    const conversation = await this.conversationModel
      .findByIdAndUpdate(id, updateConversationDto, { new: true })
      .populate('branch')
      .populate('customer')
      .populate('assignedTo')
      .populate('channel')
      .exec();
    if (!conversation) {
      throw new NotFoundException(`Social media conversation with ID ${id} not found`);
    }
    return conversation;
  }

  async remove(id: string): Promise<SocialMediaConversation> {
    const conversation = await this.conversationModel.findByIdAndDelete(id).exec();
    if (!conversation) {
      throw new NotFoundException(`Social media conversation with ID ${id} not found`);
    }
    return conversation;
  }
}

================
File: social-media-post/controllers/social-media-post.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete, Query } from '@nestjs/common';
import { SocialMediaPostService } from './social-media-post.service';
import { SocialMediaPost } from './social-media-post.schema';

@Controller('social-media-posts')
export class SocialMediaPostController {
  constructor(private readonly socialMediaPostService: SocialMediaPostService) { }

  @Post()
  create(@Body() createSocialMediaPostDto: any) {
    return this.socialMediaPostService.create(createSocialMediaPostDto);
  }

  @Get()
  findAll() {
    return this.socialMediaPostService.findAll();
  }

  @Get('store/:storeId')
  findByStore(@Param('storeId') storeId: string) {
    return this.socialMediaPostService.findByStore(storeId);
  }

  @Get('channel/:channelId')
  findByChannel(@Param('channelId') channelId: string) {
    return this.socialMediaPostService.findByChannel(channelId);
  }

  @Get('scheduled')
  findScheduledPosts() {
    return this.socialMediaPostService.findScheduledPosts();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.socialMediaPostService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSocialMediaPostDto: any) {
    return this.socialMediaPostService.update(id, updateSocialMediaPostDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.socialMediaPostService.remove(id);
  }
}

================
File: social-media-post/dtos/social-media-post.dto.ts
================
// SocialMediaPostDTO: Đại diện toàn bộ schema
export class SocialMediaPostDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  platform: string; // Nền tảng
  postId: string; // Mã bài đăng
  content: string; // Nội dung
  images: string[]; // Danh sách ảnh
  products: { productId: string }[]; // Danh sách sản phẩm
  postedBy: string; // Mã nhân viên đăng
  postDate: Date; // Ngày đăng
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateSocialMediaPostDTO: Dùng để tạo mới
export class CreateSocialMediaPostDTO {
  storeId: string; // Mã cửa hàng
  channelId: string; // Mã kênh
  platform: string; // Nền tảng
  content: string; // Nội dung
  images: string[]; // Danh sách ảnh
  products: { productId: string }[]; // Danh sách sản phẩm
  postedBy: string; // Mã nhân viên đăng
  postDate: Date; // Ngày đăng
  status: string; // Trạng thái
}

// UpdateSocialMediaPostDTO: Dùng để cập nhật
export class UpdateSocialMediaPostDTO {
  content?: string; // Nội dung (tùy chọn)
  images?: string[]; // Danh sách ảnh (tùy chọn)
  products?: { productId: string }[]; // Danh sách sản phẩm (tùy chọn)
  postDate?: Date; // Ngày đăng (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: social-media-post/schemas/social-media-post.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'SocialMediaPosts' })
export class SocialMediaPost extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng, liên kết đến bảng Stores

  @Prop({ type: Types.ObjectId, ref: 'SalesChannels', required: true })
  channelId: Types.ObjectId; // Mã kênh, liên kết đến bảng SalesChannels

  @Prop({ required: true })
  platform: string; // Nền tảng (Facebook, Instagram, v.v.)

  @Prop({ required: true })
  postId: string; // Mã bài đăng, định danh duy nhất

  @Prop({ required: true })
  content: string; // Nội dung bài đăng

  @Prop([String])
  images: string[]; // Danh sách URL ảnh

  @Prop({ type: [{ productId: Types.ObjectId }] })
  products: { productId: Types.ObjectId }[]; // Danh sách sản phẩm liên quan

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  postedBy: Types.ObjectId; // Mã nhân viên đăng bài, liên kết đến bảng Employees

  @Prop({ required: true })
  postDate: Date; // Ngày đăng bài

  @Prop({ enum: ['draft', 'published', 'archived'], default: 'draft' })
  status: string; // Trạng thái: nháp, đã đăng, lưu trữ

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const SocialMediaPostSchema = SchemaFactory.createForClass(SocialMediaPost);

================
File: social-media-post/social-media-post.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SocialMediaPostController } from './social-media-post.controller';
import { SocialMediaPostService } from './services/social-media-post.service';
import { SocialMediaPost, SocialMediaPostSchema } from './schemas/social-media-post.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: SocialMediaPost.name, schema: SocialMediaPostSchema }
    ])
  ],
  controllers: [SocialMediaPostController],
  providers: [SocialMediaPostService],
  exports: [SocialMediaPostService]
})
export class SocialMediaPostModule { }

================
File: store/controllers/store.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { StoreService } from '../services/store.service';
import { Store } from '../schemas/store.schema';

@Controller('api/stores')
export class StoreController {
  constructor(private readonly storeService: StoreService) { }

  @Post()
  create(@Body() createStoreDto: any) {
    return this.storeService.create(createStoreDto);
  }

  @Get()
  findAll() {
    return this.storeService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.storeService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateStoreDto: any) {
    return this.storeService.update(id, updateStoreDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.storeService.remove(id);
  }
}

================
File: store/dtos/store.dto.ts
================
// StoreDTO: Đại diện toàn bộ schema
export class StoreDTO {
  storeId: string; // Mã cửa hàng
  name: string; // Tên cửa hàng
  address: string; // Địa chỉ
  phone: string; // Số điện thoại
  email: string; // Email
  servicePackage: string; // Mã gói dịch vụ
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateStoreDTO: Dùng để tạo mới
export class CreateStoreDTO {
  name: string; // Tên cửa hàng
  address: string; // Địa chỉ
  phone: string; // Số điện thoại
  email: string; // Email
  servicePackage: string; // Mã gói dịch vụ
  status: string; // Trạng thái
}

// UpdateStoreDTO: Dùng để cập nhật
export class UpdateStoreDTO {
  name?: string; // Tên cửa hàng (tùy chọn)
  address?: string; // Địa chỉ (tùy chọn)
  phone?: string; // Số điện thoại (tùy chọn)
  email?: string; // Email (tùy chọn)
  servicePackage?: string; // Mã gói dịch vụ (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: store/schemas/store.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Stores' })
export class Store extends Document {
  @Prop({ unique: true, required: true })
  storeId: string; // Mã cửa hàng

  @Prop({ required: true })
  name: string; // Tên cửa hàng

  @Prop()
  address: string; // Địa chỉ

  @Prop()
  phone: string; // Số điện thoại

  @Prop()
  email: string; // Email

  @Prop({ type: Types.ObjectId, ref: 'Employees' })
  managerId: Types.ObjectId; // Mã quản lý chi nhánh

  @Prop({ type: { timezone: String } })
  settings: { timezone: string }; // Thiết lập múi giờ

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}
export const StoreSchema = SchemaFactory.createForClass(Store);

================
File: store/services/store.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Store } from '../schemas/store.schema';

@Injectable()
export class StoreService {
  constructor(
    @InjectModel('Stores') private storeModel: Model<Store>,
  ) {}

  async create(createStoreDto: any): Promise<Store> {
    const lastStore = await this.storeModel.findOne().sort({ storeId: -1 }).exec();
    let newStoreId = 'ST0001';
  
    if (lastStore && lastStore.storeId) {
      const lastNumber = parseInt(lastStore.storeId.replace('ST', ''), 10);
      const nextNumber = lastNumber + 1;
      newStoreId = `ST${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdStore = new this.storeModel({
      ...createStoreDto,
      storeId: newStoreId
    });
  
    return createdStore.save();
  }

  async findAll(): Promise<Store[]> {
    return this.storeModel.find().populate('servicePackage').exec();
  }

  async findOne(id: string): Promise<Store> {
    const store = await this.storeModel.findById(id).populate('servicePackage').exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }

  async update(id: string, updateStoreDto: any): Promise<Store> {
    const store = await this.storeModel
      .findByIdAndUpdate(id, updateStoreDto, { new: true })
      .populate('servicePackage')
      .exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }

  async remove(id: string): Promise<Store> {
    const store = await this.storeModel.findByIdAndDelete(id).exec();
    if (!store) {
      throw new NotFoundException(`Store with ID ${id} not found`);
    }
    return store;
  }
}

================
File: store/store.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { StoreController } from './controllers/store.controller';
import { StoreService } from './services/store.service';
import { Store, StoreSchema } from './schemas/store.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Stores', schema: StoreSchema },
    ]),
  ],
  controllers: [StoreController],
  providers: [StoreService],
  exports: [StoreService],
})
export class StoreModule { }

================
File: supplier-group/controllers/supplier-group.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SupplierGroupService } from '../services/supplier-group.service';
import { SupplierGroup } from '../schemas/supplier-group.schema';

@Controller('api/supplier-groups')
export class SupplierGroupController {
  constructor(private readonly supplierGroupService: SupplierGroupService) { }

  @Post()
  async create(@Body() createBranchDto: any): Promise<SupplierGroup> {
    return this.supplierGroupService.create(createBranchDto);
  }

  @Get()
  findAll() {
    return this.supplierGroupService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.supplierGroupService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSupplierGroupDto: any) {
    return this.supplierGroupService.update(id, updateSupplierGroupDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.supplierGroupService.remove(id);
  }
}

================
File: supplier-group/dtos/supplier-group.dto.ts
================
// SupplierGroupDTO: Đại diện toàn bộ schema
export class SupplierGroupDTO {
  groupId: string; // Mã nhóm nhà cung cấp
  name: string; // Tên nhóm
  description: string; // Mô tả
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateSupplierGroupDTO: Dùng để tạo mới
export class CreateSupplierGroupDTO {
  name: string; // Tên nhóm
  description: string; // Mô tả
  status: string; // Trạng thái
}

// UpdateSupplierGroupDTO: Dùng để cập nhật
export class UpdateSupplierGroupDTO {
  name?: string; // Tên nhóm (tùy chọn)
  description?: string; // Mô tả (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: supplier-group/schemas/supplier-group.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ collection: 'SupplierGroups' })
export class SupplierGroup extends Document {
  @Prop({ unique: true, required: true })
  groupId: string; // Mã nhóm nhà cung cấp, định danh duy nhất

  @Prop({ required: true })
  name: string; // Tên nhóm nhà cung cấp

  @Prop()
  description: string; // Mô tả nhóm

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái: hoạt động hoặc không hoạt động

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const SupplierGroupSchema = SchemaFactory.createForClass(SupplierGroup);

================
File: supplier-group/services/supplier-group.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { SupplierGroup } from '../schemas/supplier-group.schema';

@Injectable()
export class SupplierGroupService {
  constructor(
    @InjectModel('SupplierGroups') private SupplierGroupModel: Model<SupplierGroup>,
  ) { }

  async create(createSupplierGroupDto: any): Promise<SupplierGroup> {
    const lastSupplierGroup = await this.SupplierGroupModel.findOne().sort({ groupId: -1 }).exec();
    let newSupplierGroupId = 'SSG0001';
  
    if (lastSupplierGroup && lastSupplierGroup.groupId) {
      const lastNumber = parseInt(lastSupplierGroup.groupId.replace('SSG', ''), 10);
      const nextNumber = lastNumber + 1;
      newSupplierGroupId = `SSG${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdSupplierGroup = new this.SupplierGroupModel({
      ...createSupplierGroupDto,
      supplierGroupId: newSupplierGroupId
    });
  
    return createdSupplierGroup.save();
  }

  async findAll(): Promise<SupplierGroup[]> {
    return this.SupplierGroupModel.find().exec();
  }

  async findOne(id: string): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel.findById(id).exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }

  async update(id: string, updateSupplierGroupDto: any): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel
      .findByIdAndUpdate(id, updateSupplierGroupDto, { new: true })
      .exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }

  async remove(id: string): Promise<SupplierGroup> {
    const SupplierGroup = await this.SupplierGroupModel.findByIdAndDelete(id).exec();
    if (!SupplierGroup) {
      throw new NotFoundException(`SupplierGroup with ID ${id} not found`);
    }
    return SupplierGroup;
  }
}

================
File: supplier-group/supplier-group.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SupplierGroup, SupplierGroupSchema } from './schemas/supplier-group.schema';
import { SupplierGroupController } from './controllers/supplier-group.controller';
import { SupplierGroupService } from './services/supplier-group.service';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: 'SupplierGroups', schema: SupplierGroupSchema }])
  ],
  controllers: [SupplierGroupController],
  providers: [SupplierGroupService],
  exports: [SupplierGroupService]
})
export class SupplierGroupModule { }

================
File: supplier/controllers/supplier.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { SupplierService } from '../services/supplier.service';
import { Supplier } from '../schemas/supplier.schema';

@Controller('api/suppliers')
export class SupplierController {
  constructor(private readonly supplierService: SupplierService) { }

  @Post()
  create(@Body() createSupplierDto: any) {
    return this.supplierService.create(createSupplierDto);
  }

  @Get()
  findAll() {
    return this.supplierService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.supplierService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateSupplierDto: any) {
    return this.supplierService.update(id, updateSupplierDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.supplierService.remove(id);
  }
}

================
File: supplier/dto/supplier.dto.ts
================
// SupplierDTO: Đại diện toàn bộ schema
export class SupplierDTO {
  supplierId: string; // Mã nhà cung cấp
  name: string; // Tên nhà cung cấp
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  group: string; // Mã nhóm nhà cung cấp
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateSupplierDTO: Dùng để tạo mới
export class CreateSupplierDTO {
  name: string; // Tên nhà cung cấp
  phone: string; // Số điện thoại
  email: string; // Email
  address: string; // Địa chỉ
  group: string; // Mã nhóm nhà cung cấp
  status: string; // Trạng thái
}

// UpdateSupplierDTO: Dùng để cập nhật
export class UpdateSupplierDTO {
  name?: string; // Tên nhà cung cấp (tùy chọn)
  phone?: string; // Số điện thoại (tùy chọn)
  email?: string; // Email (tùy chọn)
  address?: string; // Địa chỉ (tùy chọn)
  group?: string; // Mã nhóm nhà cung cấp (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: supplier/schemas/supplier.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Suppliers' })
export class Supplier extends Document {
  @Prop({ unique: true, required: true })
  supplierId: string; // Mã nhà cung cấp, định danh duy nhất

  @Prop({ required: true })
  name: string; // Tên nhà cung cấp

  @Prop()
  phone: string; // Số điện thoại

  @Prop()
  email: string; // Email liên hệ

  @Prop()
  address: string; // Địa chỉ nhà cung cấp

  @Prop({ type: Types.ObjectId, ref: 'SupplierGroups' })
  group: Types.ObjectId; // Mã nhóm nhà cung cấp, liên kết đến bảng SupplierGroups

  @Prop({ enum: ['active', 'inactive'], default: 'active' })
  status: string; // Trạng thái: hoạt động hoặc không hoạt động

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const SupplierSchema = SchemaFactory.createForClass(Supplier);

================
File: supplier/services/supplier.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Supplier } from '../schemas/supplier.schema';
import { Product } from '../../product/schemas/product.schema';

@Injectable()
export class SupplierService {
  constructor(
    @InjectModel('Suppliers') private supplierModel: Model<Supplier>,
  ) { }

  async create(createSupplierDto: any): Promise<Supplier> {
    const lastSupplier = await this.supplierModel.findOne().sort({ supplierId: -1 }).exec();
    let newSupplierId = 'SSE0001';
  
    if (lastSupplier && lastSupplier.supplierId) {
      const lastNumber = parseInt(lastSupplier.supplierId.replace('SSE', ''), 10);
      const nextNumber = lastNumber + 1;
      newSupplierId = `SSE${nextNumber.toString().padStart(4, '0')}`;
    }
  
    const createdSupplier = new this.supplierModel({
      ...createSupplierDto,
      supplierId: newSupplierId
    });
  
    return createdSupplier.save();
  }
  async findAll(): Promise<Supplier[]> {
    return this.supplierModel.find().populate('group').exec();
  }

  async findOne(id: string): Promise<Supplier> {
    const supplier = await this.supplierModel.findById(id).populate('group').exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }

  async update(id: string, updateSupplierDto: any): Promise<Supplier> {
    const supplier = await this.supplierModel
      .findByIdAndUpdate(id, updateSupplierDto, { new: true })
      .populate('group')
      .exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }

  async remove(id: string): Promise<Supplier> {
    const supplier = await this.supplierModel.findByIdAndDelete(id).exec();
    if (!supplier) {
      throw new NotFoundException(`Supplier with ID ${id} not found`);
    }
    return supplier;
  }
}

================
File: supplier/supplier.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SupplierController } from './controllers/supplier.controller';
import { SupplierService } from './services/supplier.service';
import { Supplier, SupplierSchema } from './schemas/supplier.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: 'Suppliers', schema: SupplierSchema }
    ]),
  ],
  controllers: [SupplierController],
  providers: [SupplierService],
  exports: [SupplierService],
})
export class SupplierModule { }

================
File: transaction/dtos/transaction.dto.ts
================
// TransactionDTO: Đại diện toàn bộ schema
export class TransactionDTO {
  transactionId: string; // Mã giao dịch
  storeId: string; // Mã cửa hàng
  amount: number; // Số tiền
  type: string; // Loại giao dịch
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateTransactionDTO: Dùng để tạo mới
export class CreateTransactionDTO {
  storeId: string; // Mã cửa hàng
  amount: number; // Số tiền
  type: string; // Loại giao dịch
  status: string; // Trạng thái
}

// UpdateTransactionDTO: Dùng để cập nhật
export class UpdateTransactionDTO {
  amount?: number; // Số tiền (tùy chọn)
  type?: string; // Loại giao dịch (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: transaction/schemas/transaction.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'Transactions' })
export class Transaction extends Document {
  @Prop({ unique: true, required: true })
  transactionId: string; // Mã giao dịch, định danh duy nhất

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng, liên kết đến bảng Stores

  @Prop({ required: true })
  amount: number; // Số tiền giao dịch

  @Prop({ enum: ['payment', 'refund', 'transfer'], required: true })
  type: string; // Loại giao dịch: thanh toán, hoàn tiền, chuyển khoản

  @Prop({ enum: ['pending', 'completed', 'failed'], default: 'pending' })
  status: string; // Trạng thái: đang chờ, hoàn thành, thất bại

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo bản ghi
}

export const TransactionSchema = SchemaFactory.createForClass(Transaction);

================
File: website-setting/controllers/website-settings.controller.ts
================
import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { WebsiteSettingsService } from '../services/website-settings.service';
import { WebsiteSettings } from './website-settings.schema';

@Controller('website-settings')
export class WebsiteSettingsController {
  constructor(private readonly websiteSettingsService: WebsiteSettingsService) { }

  @Post()
  async create(@Body() createWebsiteSettingsDto: any): Promise<WebsiteSettings> {
    return this.websiteSettingsService.create(createWebsiteSettingsDto);
  }

  @Get()
  async findAll(): Promise<WebsiteSettings[]> {
    return this.websiteSettingsService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<WebsiteSettings> {
    return this.websiteSettingsService.findOne(id);
  }

  @Get('store/:storeId')
  async findByStore(@Param('storeId') storeId: string): Promise<WebsiteSettings> {
    return this.websiteSettingsService.findByStore(storeId);
  }

  @Put(':id')
  async update(
    @Param('id') id: string,
    @Body() updateWebsiteSettingsDto: any,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, updateWebsiteSettingsDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string): Promise<WebsiteSettings> {
    return this.websiteSettingsService.remove(id);
  }

  @Put(':id/maintenance')
  async toggleMaintenance(
    @Param('id') id: string,
    @Body() data: { isEnabled: boolean; message?: string },
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, {
      'maintenance.isEnabled': data.isEnabled,
      'maintenance.message': data.message,
    });
  }

  @Put(':id/theme')
  async updateTheme(
    @Param('id') id: string,
    @Body() theme: any,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, { theme });
  }

  @Put(':id/seo')
  async updateSEO(
    @Param('id') id: string,
    @Body() seo: any,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, { seo });
  }

  @Put(':id/contact')
  async updateContact(
    @Param('id') id: string,
    @Body() contact: any,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, { contact });
  }

  @Put(':id/social-media')
  async updateSocialMedia(
    @Param('id') id: string,
    @Body() socialMedia: any,
  ): Promise<WebsiteSettings> {
    return this.websiteSettingsService.update(id, { socialMedia });
  }
}

================
File: website-setting/dtos/website-setting.dto.ts
================
// WebsiteSettingsDTO: Đại diện toàn bộ schema
export class WebsiteSettingsDTO {
  storeId: string; // Mã cửa hàng
  domain: string; // Tên miền
  logo: string; // Logo
  favicon: string; // Favicon
  seo: {
    title: string;
    description: string;
    keywords: string[];
  }; // Cài đặt SEO
  general: {
    currency: string;
    language: string;
    timezone: string;
  }; // Cài đặt chung
  payment: {
    methods: string[];
    defaultMethod: string;
  }; // Cài đặt thanh toán
  shipping: {
    carriers: string[];
    defaultCarrier: string;
  }; // Cài đặt vận chuyển
  social: {
    facebook: string;
    twitter: string;
    instagram: string;
  }; // Liên kết mạng xã hội
  customization: {
    header: string;
    footer: string;
    css: string;
  }; // Tùy chỉnh giao diện
}

// CreateWebsiteSettingsDTO: Dùng để tạo mới
export class CreateWebsiteSettingsDTO {
  storeId: string; // Mã cửa hàng
  domain: string; // Tên miền
  logo: string; // Logo
  favicon: string; // Favicon
  seo: {
    title: string;
    description: string;
    keywords: string[];
  }; // Cài đặt SEO
  general: {
    currency: string;
    language: string;
    timezone: string;
  }; // Cài đặt chung
  payment: {
    methods: string[];
    defaultMethod: string;
  }; // Cài đặt thanh toán
  shipping: {
    carriers: string[];
    defaultCarrier: string;
  }; // Cài đặt vận chuyển
  social: {
    facebook: string;
    twitter: string;
    instagram: string;
  }; // Liên kết mạng xã hội
  customization: {
    header: string;
    footer: string;
    css: string;
  }; // Tùy chỉnh giao diện
}

// UpdateWebsiteSettingsDTO: Dùng để cập nhật
export class UpdateWebsiteSettingsDTO {
  domain?: string; // Tên miền (tùy chọn)
  logo?: string; // Logo (tùy chọn)
  favicon?: string; // Favicon (tùy chọn)
  seo?: {
    title?: string;
    description?: string;
    keywords?: string[];
  }; // Cài đặt SEO (tùy chọn)
  general?: {
    currency?: string;
    language?: string;
    timezone?: string;
  }; // Cài đặt chung (tùy chọn)
  payment?: {
    methods?: string[];
    defaultMethod?: string;
  }; // Cài đặt thanh toán (tùy chọn)
  shipping?: {
    carriers?: string[];
    defaultCarrier?: string;
  }; // Cài đặt vận chuyển (tùy chọn)
  social?: {
    facebook?: string;
    twitter?: string;
    instagram?: string;
  }; // Liên kết mạng xã hội (tùy chọn)
  customization?: {
    header?: string;
    footer?: string;
    css?: string;
  }; // Tùy chỉnh giao diện (tùy chọn)
}

================
File: website-setting/schemas/website-settings.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'WebsiteSettings' })
export class WebsiteSettings extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng, liên kết đến bảng Stores

  @Prop({ required: true })
  domain: string; // Tên miền website

  @Prop()
  logo: string; // URL logo

  @Prop()
  favicon: string; // URL favicon

  @Prop({ type: { title: String, description: String, keywords: [String] } })
  seo: {
    title: string; // Tiêu đề SEO
    description: string; // Mô tả SEO
    keywords: string[]; // Từ khóa SEO
  };

  @Prop({ type: { currency: String, language: String, timezone: String } })
  general: {
    currency: string; // Đơn vị tiền tệ
    language: string; // Ngôn ngữ
    timezone: string; // Múi giờ
  };

  @Prop({ type: { methods: [String], defaultMethod: String } })
  payment: {
    methods: string[]; // Danh sách phương thức thanh toán
    defaultMethod: string; // Phương thức mặc định
  };

  @Prop({ type: { carriers: [String], defaultCarrier: String } })
  shipping: {
    carriers: string[]; // Danh sách đơn vị vận chuyển
    defaultCarrier: string; // Đơn vị mặc định
  };

  @Prop({ type: { facebook: String, twitter: String, instagram: String } })
  social: {
    facebook: string; // Liên kết Facebook
    twitter: string; // Liên kết Twitter
    instagram: string; // Liên kết Instagram
  };

  @Prop({ type: { header: String, footer: String, css: String } })
  customization: {
    header: string; // Tùy chỉnh header
    footer: string; // Tùy chỉnh footer
    css: string; // CSS tùy chỉnh
  };
}

export const WebsiteSettingsSchema = SchemaFactory.createForClass(WebsiteSettings);

================
File: website-setting/services/website-settings.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { WebsiteSettings } from '../website-setting/website-settings.schema';

@Injectable()
export class WebsiteSettingsService {
  constructor(
    @InjectModel(WebsiteSettings.name)
    private websiteSettingsModel: Model<WebsiteSettings>,
  ) { }

  async create(createWebsiteSettingsDto: any): Promise<WebsiteSettings> {
    const created = new this.websiteSettingsModel(createWebsiteSettingsDto);
    return created.save();
  }

  async findAll(): Promise<WebsiteSettings[]> {
    return this.websiteSettingsModel.find().exec();
  }

  async findOne(id: string): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel.findById(id).exec();
    if (!settings) {
      throw new NotFoundException(`Website settings with ID ${id} not found`);
    }
    return settings;
  }

  async findByStore(storeId: string): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel.findOne({ storeId }).exec();
    if (!settings) {
      throw new NotFoundException(`Website settings for store ${storeId} not found`);
    }
    return settings;
  }

  async update(id: string, updateWebsiteSettingsDto: any): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel
      .findByIdAndUpdate(id, updateWebsiteSettingsDto, { new: true })
      .exec();
    if (!settings) {
      throw new NotFoundException(`Website settings with ID ${id} not found`);
    }
    return settings;
  }

  async remove(id: string): Promise<WebsiteSettings> {
    const settings = await this.websiteSettingsModel.findByIdAndDelete(id).exec();
    if (!settings) {
      throw new NotFoundException(`Website settings with ID ${id} not found`);
    }
    return settings;
  }
}

================
File: work-schedule/controllers/work-schedule.controller.ts
================
import { Controller, Get, Post, Body, Patch, Param, Delete, Query } from '@nestjs/common';
import { WorkScheduleService } from '../services/work-schedule.service';
import { WorkSchedule } from '../schemas/work-schedule.schema';

@Controller('work-schedules')
export class WorkScheduleController {
  constructor(private readonly workScheduleService: WorkScheduleService) { }

  @Post()
  create(@Body() createWorkScheduleDto: any) {
    return this.workScheduleService.create(createWorkScheduleDto);
  }

  @Get()
  findAll() {
    return this.workScheduleService.findAll();
  }

  @Get('store/:storeId')
  findByStore(@Param('storeId') storeId: string) {
    return this.workScheduleService.findByStore(storeId);
  }

  @Get('employee/:employeeId')
  findByEmployee(@Param('employeeId') employeeId: string) {
    return this.workScheduleService.findByEmployee(employeeId);
  }

  @Get('special-schedules')
  findSpecialSchedulesByDate(@Query('date') date: string) {
    return this.workScheduleService.findSpecialSchedulesByDate(new Date(date));
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.workScheduleService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateWorkScheduleDto: any) {
    return this.workScheduleService.update(id, updateWorkScheduleDto);
  }

  @Patch(':id/special-schedule')
  updateSpecialSchedule(
    @Param('id') id: string,
    @Body() specialSchedule: {
      date: Date;
      isWorking: boolean;
      startTime: string;
      endTime: string;
      breakTime: string;
      reason: string;
    }
  ) {
    return this.workScheduleService.updateSpecialSchedule(id, specialSchedule);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.workScheduleService.remove(id);
  }
}

================
File: work-schedule/dtos/work-schedule.dto.ts
================
// WorkScheduleDTO: Đại diện toàn bộ schema
export class WorkScheduleDTO {
  storeId: string; // Mã cửa hàng
  employeeId: string; // Mã nhân viên
  date: Date; // Ngày làm việc
  startTime: Date; // Giờ bắt đầu
  endTime: Date; // Giờ kết thúc
  shift: string; // Ca làm việc
  status: string; // Trạng thái
  createdAt: Date; // Thời gian tạo
}

// CreateWorkScheduleDTO: Dùng để tạo mới
export class CreateWorkScheduleDTO {
  storeId: string; // Mã cửa hàng
  employeeId: string; // Mã nhân viên
  date: Date; // Ngày làm việc
  startTime: Date; // Giờ bắt đầu
  endTime: Date; // Giờ kết thúc
  shift: string; // Ca làm việc
  status: string; // Trạng thái
}

// UpdateWorkScheduleDTO: Dùng để cập nhật
export class UpdateWorkScheduleDTO {
  date?: Date; // Ngày làm việc (tùy chọn)
  startTime?: Date; // Giờ bắt đầu (tùy chọn)
  endTime?: Date; // Giờ kết thúc (tùy chọn)
  shift?: string; // Ca làm việc (tùy chọn)
  status?: string; // Trạng thái (tùy chọn)
}

================
File: work-schedule/schemas/work-schedule.schema.ts
================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ collection: 'WorkSchedules' })
export class WorkSchedule extends Document {
  @Prop({ unique: true, required: true })
  scheduleId: string; // Mã lịch làm việc duy nhất

  @Prop({ type: Types.ObjectId, ref: 'Stores', required: true })
  storeId: Types.ObjectId; // Mã cửa hàng

  @Prop({ type: Types.ObjectId, ref: 'Employees', required: true })
  employeeId: Types.ObjectId; // Mã nhân viên

  @Prop({ required: true })
  date: Date; // Ngày làm việc

  @Prop({ required: true })
  startTime: Date; // Giờ bắt đầu ca

  @Prop({ required: true })
  endTime: Date; // Giờ kết thúc ca

  @Prop({ required: true })
  shiftName: string; // Tên ca (hành chính hoặc tùy chỉnh)

  @Prop({ enum: ['scheduled', 'completed', 'missed'], default: 'scheduled' })
  status: string; // Trạng thái

  @Prop({ default: false })
  isHoliday: boolean; // Làm việc ngày lễ/tết

  @Prop({ type: { repeat: Boolean, daysOfWeek: [String], endRepeat: Date } })
  repeatSettings: {
    repeat: boolean; // Lặp lại hàng tuần
    daysOfWeek: string[]; // Các ngày trong tuần (e.g., ['monday', 'tuesday'])
    endRepeat: Date; // Ngày kết thúc lặp
  }; // Thiết lập lặp lại

  @Prop()
  notes: string; // Ghi chú (ví dụ: lý do nghỉ, yêu cầu đặc biệt)

  @Prop({ default: Date.now })
  createdAt: Date; // Thời gian tạo
}
export const WorkScheduleSchema = SchemaFactory.createForClass(WorkSchedule);

================
File: work-schedule/services/work-schedule.service.ts
================
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { WorkSchedule } from './schemas/work-schedule.schema';

@Injectable()
export class WorkScheduleService {
  constructor(
    @InjectModel(WorkSchedule.name)
    private workScheduleModel: Model<WorkSchedule>,
  ) { }

  async create(createWorkScheduleDto: any): Promise<WorkSchedule> {
    const createdSchedule = new this.workScheduleModel(createWorkScheduleDto);
    return createdSchedule.save();
  }

  async findAll(): Promise<WorkSchedule[]> {
    return this.workScheduleModel.find().exec();
  }

  async findOne(id: string): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel.findById(id).exec();
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }
    return schedule;
  }

  async update(id: string, updateWorkScheduleDto: any): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel
      .findByIdAndUpdate(id, updateWorkScheduleDto, { new: true })
      .exec();
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }
    return schedule;
  }

  async remove(id: string): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel.findByIdAndDelete(id).exec();
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }
    return schedule;
  }

  async findByStore(storeId: string): Promise<WorkSchedule[]> {
    return this.workScheduleModel.find({ storeId }).exec();
  }

  async findByEmployee(employeeId: string): Promise<WorkSchedule[]> {
    return this.workScheduleModel.find({ employeeId }).exec();
  }

  async findSpecialSchedulesByDate(date: Date): Promise<WorkSchedule[]> {
    return this.workScheduleModel
      .find({
        'specialSchedules.date': {
          $gte: new Date(date.setHours(0, 0, 0, 0)),
          $lt: new Date(date.setHours(23, 59, 59, 999))
        }
      })
      .exec();
  }

  async updateSpecialSchedule(
    id: string,
    specialSchedule: {
      date: Date;
      isWorking: boolean;
      startTime: string;
      endTime: string;
      breakTime: string;
      reason: string;
    }
  ): Promise<WorkSchedule> {
    const schedule = await this.workScheduleModel.findById(id);
    if (!schedule) {
      throw new NotFoundException(`Work schedule with ID ${id} not found`);
    }

    const existingScheduleIndex = schedule.specialSchedules.findIndex(
      s => s.date.getTime() === specialSchedule.date.getTime()
    );

    if (existingScheduleIndex >= 0) {
      schedule.specialSchedules[existingScheduleIndex] = specialSchedule;
    } else {
      schedule.specialSchedules.push(specialSchedule);
    }

    return schedule.save();
  }
}

================
File: work-schedule/work-schedule.module.ts
================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { WorkScheduleController } from '../work-schedule/controllers/work-schedule.controller';
import { WorkScheduleService } from '../services/work-schedule.service';
import { WorkSchedule, WorkScheduleSchema } from './schemas/work-schedule.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: WorkSchedule.name, schema: WorkScheduleSchema }
    ])
  ],
  controllers: [WorkScheduleController],
  providers: [WorkScheduleService],
  exports: [WorkScheduleService]
})
export class WorkScheduleModule { }



================================================================
End of Codebase
================================================================
